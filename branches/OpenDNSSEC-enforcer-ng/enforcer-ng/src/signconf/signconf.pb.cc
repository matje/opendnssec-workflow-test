// Generated by the protocol buffer compiler.  DO NOT EDIT!

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "signconf.pb.h"
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>

namespace signconf {
namespace pb {

namespace {

const ::google::protobuf::Descriptor* SignerConfigurationDocument_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SignerConfigurationDocument_reflection_ = NULL;
const ::google::protobuf::Descriptor* SignerConfiguration_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SignerConfiguration_reflection_ = NULL;
const ::google::protobuf::Descriptor* Zone_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Zone_reflection_ = NULL;
const ::google::protobuf::Descriptor* Signatures_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Signatures_reflection_ = NULL;
const ::google::protobuf::Descriptor* Denial_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Denial_reflection_ = NULL;
const ::google::protobuf::Descriptor* NSEC_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  NSEC_reflection_ = NULL;
const ::google::protobuf::Descriptor* NSEC3_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  NSEC3_reflection_ = NULL;
const ::google::protobuf::Descriptor* Keys_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Keys_reflection_ = NULL;
const ::google::protobuf::Descriptor* Key_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Key_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* serial_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_signconf_2eproto() {
  protobuf_AddDesc_signconf_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "signconf.proto");
  GOOGLE_CHECK(file != NULL);
  SignerConfigurationDocument_descriptor_ = file->message_type(0);
  static const int SignerConfigurationDocument_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignerConfigurationDocument, signerconfiguration_),
  };
  SignerConfigurationDocument_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SignerConfigurationDocument_descriptor_,
      SignerConfigurationDocument::default_instance_,
      SignerConfigurationDocument_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignerConfigurationDocument, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignerConfigurationDocument, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SignerConfigurationDocument));
  SignerConfiguration_descriptor_ = file->message_type(1);
  static const int SignerConfiguration_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignerConfiguration, zone_),
  };
  SignerConfiguration_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SignerConfiguration_descriptor_,
      SignerConfiguration::default_instance_,
      SignerConfiguration_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignerConfiguration, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignerConfiguration, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SignerConfiguration));
  Zone_descriptor_ = file->message_type(2);
  static const int Zone_offsets_[8] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Zone, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Zone, signatures_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Zone, denial_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Zone, keys_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Zone, ttl_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Zone, min_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Zone, serial_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Zone, audit_),
  };
  Zone_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Zone_descriptor_,
      Zone::default_instance_,
      Zone_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Zone, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Zone, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Zone));
  Signatures_descriptor_ = file->message_type(3);
  static const int Signatures_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Signatures, resign_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Signatures, refresh_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Signatures, valdefault_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Signatures, valdenial_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Signatures, jitter_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Signatures, inceptionoffset_),
  };
  Signatures_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Signatures_descriptor_,
      Signatures::default_instance_,
      Signatures_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Signatures, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Signatures, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Signatures));
  Denial_descriptor_ = file->message_type(4);
  static const int Denial_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Denial, nsec_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Denial, nsec3_),
  };
  Denial_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Denial_descriptor_,
      Denial::default_instance_,
      Denial_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Denial, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Denial, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Denial));
  NSEC_descriptor_ = file->message_type(5);
  static const int NSEC_offsets_[1] = {
  };
  NSEC_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      NSEC_descriptor_,
      NSEC::default_instance_,
      NSEC_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NSEC, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NSEC, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(NSEC));
  NSEC3_descriptor_ = file->message_type(6);
  static const int NSEC3_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NSEC3, optout_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NSEC3, algorithm_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NSEC3, iterations_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NSEC3, salt_),
  };
  NSEC3_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      NSEC3_descriptor_,
      NSEC3::default_instance_,
      NSEC3_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NSEC3, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NSEC3, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(NSEC3));
  Keys_descriptor_ = file->message_type(7);
  static const int Keys_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Keys, ttl_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Keys, keys_),
  };
  Keys_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Keys_descriptor_,
      Keys::default_instance_,
      Keys_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Keys, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Keys, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Keys));
  Key_descriptor_ = file->message_type(8);
  static const int Key_offsets_[7] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Key, flags_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Key, algorithm_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Key, locator_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Key, ksk_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Key, zsk_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Key, publish_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Key, deactivate_),
  };
  Key_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Key_descriptor_,
      Key::default_instance_,
      Key_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Key, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Key, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Key));
  serial_descriptor_ = file->enum_type(0);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_signconf_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SignerConfigurationDocument_descriptor_, &SignerConfigurationDocument::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SignerConfiguration_descriptor_, &SignerConfiguration::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Zone_descriptor_, &Zone::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Signatures_descriptor_, &Signatures::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Denial_descriptor_, &Denial::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    NSEC_descriptor_, &NSEC::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    NSEC3_descriptor_, &NSEC3::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Keys_descriptor_, &Keys::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Key_descriptor_, &Key::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_signconf_2eproto() {
  delete SignerConfigurationDocument::default_instance_;
  delete SignerConfigurationDocument_reflection_;
  delete SignerConfiguration::default_instance_;
  delete SignerConfiguration_reflection_;
  delete Zone::default_instance_;
  delete Zone_reflection_;
  delete Signatures::default_instance_;
  delete Signatures_reflection_;
  delete Denial::default_instance_;
  delete Denial_reflection_;
  delete NSEC::default_instance_;
  delete NSEC_reflection_;
  delete NSEC3::default_instance_;
  delete NSEC3_reflection_;
  delete Keys::default_instance_;
  delete Keys_reflection_;
  delete Key::default_instance_;
  delete Key_reflection_;
}

void protobuf_AddDesc_signconf_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::protobuf_AddDesc_xmlext_2eproto();
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\016signconf.proto\022\013signconf.pb\032\014xmlext.pr"
    "oto\"w\n\033SignerConfigurationDocument\022X\n\023si"
    "gnerconfiguration\030\001 \002(\0132 .signconf.pb.Si"
    "gnerConfigurationB\031\202\265\030\025\n\023SignerConfigura"
    "tion\"B\n\023SignerConfiguration\022+\n\004zone\030\001 \002("
    "\0132\021.signconf.pb.ZoneB\n\202\265\030\006\n\004Zone\"\333\002\n\004Zon"
    "e\022\031\n\004name\030\001 \002(\tB\013\202\265\030\007\n\005@name\022=\n\nsignatur"
    "es\030\002 \002(\0132\027.signconf.pb.SignaturesB\020\202\265\030\014\n"
    "\nSignatures\0221\n\006denial\030\003 \002(\0132\023.signconf.p"
    "b.DenialB\014\202\265\030\010\n\006Denial\022+\n\004keys\030\004 \002(\0132\021.s"
    "ignconf.pb.KeysB\n\202\265\030\006\n\004Keys\022 \n\003ttl\030\005 \002(\005"
    "B\023\202\265\030\t\n\007SOA/TTL\202\265\030\002\020\002\022$\n\003min\030\006 \002(\005B\027\202\265\030\r"
    "\n\013SOA/Minimum\202\265\030\002\020\002\0225\n\006serial\030\007 \002(\0162\023.si"
    "gnconf.pb.serialB\020\202\265\030\014\n\nSOA/Serial\022\032\n\005au"
    "dit\030\010 \001(\010B\013\202\265\030\007\n\005Audit\"\222\002\n\nSignatures\022\"\n"
    "\006resign\030\001 \002(\005B\022\202\265\030\010\n\006Resign\202\265\030\002\020\002\022$\n\007ref"
    "resh\030\002 \002(\005B\023\202\265\030\t\n\007Refresh\202\265\030\002\020\002\0220\n\nvalde"
    "fault\030\003 \002(\005B\034\202\265\030\022\n\020Validity/Default\202\265\030\002\020"
    "\002\022.\n\tvaldenial\030\004 \002(\005B\033\202\265\030\021\n\017Validity/Den"
    "ial\202\265\030\002\020\002\022\"\n\006jitter\030\005 \002(\005B\022\202\265\030\010\n\006Jitter\202"
    "\265\030\002\020\002\0224\n\017inceptionOffset\030\006 \002(\005B\033\202\265\030\021\n\017In"
    "ceptionOffset\202\265\030\002\020\002\"e\n\006Denial\022+\n\004nsec\030\001 "
    "\001(\0132\021.signconf.pb.NSECB\n\202\265\030\006\n\004NSEC\022.\n\005ns"
    "ec3\030\002 \001(\0132\022.signconf.pb.NSEC3B\013\202\265\030\007\n\005NSE"
    "C3\"\006\n\004NSEC\"\230\001\n\005NSEC3\022\034\n\006optout\030\001 \001(\010B\014\202\265"
    "\030\010\n\006OptOut\022\'\n\talgorithm\030\002 \002(\005B\024\202\265\030\020\n\016Has"
    "h/Algorithm\022)\n\niterations\030\003 \002(\005B\025\202\265\030\021\n\017H"
    "ash/Iterations\022\035\n\004salt\030\004 \002(\tB\017\202\265\030\013\n\tHash"
    "/Salt\"P\n\004Keys\022\034\n\003ttl\030\001 \002(\005B\017\202\265\030\005\n\003TTL\202\265\030"
    "\002\020\002\022*\n\004keys\030\002 \003(\0132\020.signconf.pb.KeyB\n\202\265\030"
    "\006\n\004Keys\"\333\001\n\003Key\022\032\n\005flags\030\001 \002(\rB\013\202\265\030\007\n\005Fl"
    "ags\022\"\n\talgorithm\030\002 \002(\rB\017\202\265\030\013\n\tAlgorithm\022"
    "\036\n\007locator\030\003 \002(\tB\r\202\265\030\t\n\007Locator\022\026\n\003ksk\030\004"
    " \001(\010B\t\202\265\030\005\n\003KSK\022\026\n\003zsk\030\005 \001(\010B\t\202\265\030\005\n\003ZSK\022"
    "\036\n\007publish\030\006 \001(\010B\r\202\265\030\t\n\007Publish\022$\n\ndeact"
    "ivate\030\007 \001(\010B\020\202\265\030\014\n\nDeactivate*>\n\006serial\022"
    "\013\n\007counter\020\001\022\017\n\013datecounter\020\002\022\014\n\010unixtim"
    "e\020\003\022\010\n\004keep\020\004", 1493);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "signconf.proto", &protobuf_RegisterTypes);
  SignerConfigurationDocument::default_instance_ = new SignerConfigurationDocument();
  SignerConfiguration::default_instance_ = new SignerConfiguration();
  Zone::default_instance_ = new Zone();
  Signatures::default_instance_ = new Signatures();
  Denial::default_instance_ = new Denial();
  NSEC::default_instance_ = new NSEC();
  NSEC3::default_instance_ = new NSEC3();
  Keys::default_instance_ = new Keys();
  Key::default_instance_ = new Key();
  SignerConfigurationDocument::default_instance_->InitAsDefaultInstance();
  SignerConfiguration::default_instance_->InitAsDefaultInstance();
  Zone::default_instance_->InitAsDefaultInstance();
  Signatures::default_instance_->InitAsDefaultInstance();
  Denial::default_instance_->InitAsDefaultInstance();
  NSEC::default_instance_->InitAsDefaultInstance();
  NSEC3::default_instance_->InitAsDefaultInstance();
  Keys::default_instance_->InitAsDefaultInstance();
  Key::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_signconf_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_signconf_2eproto {
  StaticDescriptorInitializer_signconf_2eproto() {
    protobuf_AddDesc_signconf_2eproto();
  }
} static_descriptor_initializer_signconf_2eproto_;

const ::google::protobuf::EnumDescriptor* serial_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return serial_descriptor_;
}
bool serial_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}


// ===================================================================

#ifndef _MSC_VER
const int SignerConfigurationDocument::kSignerconfigurationFieldNumber;
#endif  // !_MSC_VER

SignerConfigurationDocument::SignerConfigurationDocument() {
  SharedCtor();
}

void SignerConfigurationDocument::InitAsDefaultInstance() {
  signerconfiguration_ = const_cast< ::signconf::pb::SignerConfiguration*>(&::signconf::pb::SignerConfiguration::default_instance());
}

SignerConfigurationDocument::SignerConfigurationDocument(const SignerConfigurationDocument& from) {
  SharedCtor();
  MergeFrom(from);
}

void SignerConfigurationDocument::SharedCtor() {
  _cached_size_ = 0;
  signerconfiguration_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SignerConfigurationDocument::~SignerConfigurationDocument() {
  SharedDtor();
}

void SignerConfigurationDocument::SharedDtor() {
  if (this != default_instance_) {
    delete signerconfiguration_;
  }
}

const ::google::protobuf::Descriptor* SignerConfigurationDocument::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SignerConfigurationDocument_descriptor_;
}

const SignerConfigurationDocument& SignerConfigurationDocument::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_signconf_2eproto();  return *default_instance_;
}

SignerConfigurationDocument* SignerConfigurationDocument::default_instance_ = NULL;

SignerConfigurationDocument* SignerConfigurationDocument::New() const {
  return new SignerConfigurationDocument;
}

void SignerConfigurationDocument::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (_has_bit(0)) {
      if (signerconfiguration_ != NULL) signerconfiguration_->::signconf::pb::SignerConfiguration::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SignerConfigurationDocument::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .signconf.pb.SignerConfiguration signerconfiguration = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
        DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
             input, mutable_signerconfiguration()));
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SignerConfigurationDocument::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  ::google::protobuf::uint8* raw_buffer = output->GetDirectBufferForNBytesAndAdvance(_cached_size_);
  if (raw_buffer != NULL) {
    SignerConfigurationDocument::SerializeWithCachedSizesToArray(raw_buffer);
    return;
  }
  
  // required .signconf.pb.SignerConfiguration signerconfiguration = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageNoVirtual(
      1, this->signerconfiguration(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* SignerConfigurationDocument::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .signconf.pb.SignerConfiguration signerconfiguration = 1;
  if (_has_bit(0)) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->signerconfiguration(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int SignerConfigurationDocument::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .signconf.pb.SignerConfiguration signerconfiguration = 1;
    if (has_signerconfiguration()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->signerconfiguration());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  _cached_size_ = total_size;
  return total_size;
}

void SignerConfigurationDocument::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SignerConfigurationDocument* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SignerConfigurationDocument*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SignerConfigurationDocument::MergeFrom(const SignerConfigurationDocument& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      mutable_signerconfiguration()->::signconf::pb::SignerConfiguration::MergeFrom(from.signerconfiguration());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SignerConfigurationDocument::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SignerConfigurationDocument::CopyFrom(const SignerConfigurationDocument& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SignerConfigurationDocument::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  if (has_signerconfiguration()) {
    if (!this->signerconfiguration().IsInitialized()) return false;
  }
  return true;
}

void SignerConfigurationDocument::Swap(SignerConfigurationDocument* other) {
  if (other != this) {
    std::swap(signerconfiguration_, other->signerconfiguration_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SignerConfigurationDocument::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SignerConfigurationDocument_descriptor_;
  metadata.reflection = SignerConfigurationDocument_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int SignerConfiguration::kZoneFieldNumber;
#endif  // !_MSC_VER

SignerConfiguration::SignerConfiguration() {
  SharedCtor();
}

void SignerConfiguration::InitAsDefaultInstance() {
  zone_ = const_cast< ::signconf::pb::Zone*>(&::signconf::pb::Zone::default_instance());
}

SignerConfiguration::SignerConfiguration(const SignerConfiguration& from) {
  SharedCtor();
  MergeFrom(from);
}

void SignerConfiguration::SharedCtor() {
  _cached_size_ = 0;
  zone_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SignerConfiguration::~SignerConfiguration() {
  SharedDtor();
}

void SignerConfiguration::SharedDtor() {
  if (this != default_instance_) {
    delete zone_;
  }
}

const ::google::protobuf::Descriptor* SignerConfiguration::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SignerConfiguration_descriptor_;
}

const SignerConfiguration& SignerConfiguration::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_signconf_2eproto();  return *default_instance_;
}

SignerConfiguration* SignerConfiguration::default_instance_ = NULL;

SignerConfiguration* SignerConfiguration::New() const {
  return new SignerConfiguration;
}

void SignerConfiguration::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (_has_bit(0)) {
      if (zone_ != NULL) zone_->::signconf::pb::Zone::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SignerConfiguration::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .signconf.pb.Zone zone = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
        DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
             input, mutable_zone()));
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SignerConfiguration::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  ::google::protobuf::uint8* raw_buffer = output->GetDirectBufferForNBytesAndAdvance(_cached_size_);
  if (raw_buffer != NULL) {
    SignerConfiguration::SerializeWithCachedSizesToArray(raw_buffer);
    return;
  }
  
  // required .signconf.pb.Zone zone = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageNoVirtual(
      1, this->zone(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* SignerConfiguration::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .signconf.pb.Zone zone = 1;
  if (_has_bit(0)) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->zone(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int SignerConfiguration::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .signconf.pb.Zone zone = 1;
    if (has_zone()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->zone());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  _cached_size_ = total_size;
  return total_size;
}

void SignerConfiguration::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SignerConfiguration* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SignerConfiguration*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SignerConfiguration::MergeFrom(const SignerConfiguration& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      mutable_zone()->::signconf::pb::Zone::MergeFrom(from.zone());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SignerConfiguration::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SignerConfiguration::CopyFrom(const SignerConfiguration& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SignerConfiguration::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  if (has_zone()) {
    if (!this->zone().IsInitialized()) return false;
  }
  return true;
}

void SignerConfiguration::Swap(SignerConfiguration* other) {
  if (other != this) {
    std::swap(zone_, other->zone_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SignerConfiguration::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SignerConfiguration_descriptor_;
  metadata.reflection = SignerConfiguration_reflection_;
  return metadata;
}


// ===================================================================

const ::std::string Zone::_default_name_;
#ifndef _MSC_VER
const int Zone::kNameFieldNumber;
const int Zone::kSignaturesFieldNumber;
const int Zone::kDenialFieldNumber;
const int Zone::kKeysFieldNumber;
const int Zone::kTtlFieldNumber;
const int Zone::kMinFieldNumber;
const int Zone::kSerialFieldNumber;
const int Zone::kAuditFieldNumber;
#endif  // !_MSC_VER

Zone::Zone() {
  SharedCtor();
}

void Zone::InitAsDefaultInstance() {
  signatures_ = const_cast< ::signconf::pb::Signatures*>(&::signconf::pb::Signatures::default_instance());
  denial_ = const_cast< ::signconf::pb::Denial*>(&::signconf::pb::Denial::default_instance());
  keys_ = const_cast< ::signconf::pb::Keys*>(&::signconf::pb::Keys::default_instance());
}

Zone::Zone(const Zone& from) {
  SharedCtor();
  MergeFrom(from);
}

void Zone::SharedCtor() {
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&_default_name_);
  signatures_ = NULL;
  denial_ = NULL;
  keys_ = NULL;
  ttl_ = 0;
  min_ = 0;
  serial_ = 1;
  audit_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Zone::~Zone() {
  SharedDtor();
}

void Zone::SharedDtor() {
  if (name_ != &_default_name_) {
    delete name_;
  }
  if (this != default_instance_) {
    delete signatures_;
    delete denial_;
    delete keys_;
  }
}

const ::google::protobuf::Descriptor* Zone::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Zone_descriptor_;
}

const Zone& Zone::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_signconf_2eproto();  return *default_instance_;
}

Zone* Zone::default_instance_ = NULL;

Zone* Zone::New() const {
  return new Zone;
}

void Zone::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (_has_bit(0)) {
      if (name_ != &_default_name_) {
        name_->clear();
      }
    }
    if (_has_bit(1)) {
      if (signatures_ != NULL) signatures_->::signconf::pb::Signatures::Clear();
    }
    if (_has_bit(2)) {
      if (denial_ != NULL) denial_->::signconf::pb::Denial::Clear();
    }
    if (_has_bit(3)) {
      if (keys_ != NULL) keys_->::signconf::pb::Keys::Clear();
    }
    ttl_ = 0;
    min_ = 0;
    serial_ = 1;
    audit_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Zone::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
        DO_(::google::protobuf::internal::WireFormatLite::ReadString(
              input, this->mutable_name()));
        ::google::protobuf::internal::WireFormat::VerifyUTF8String(
          this->name().data(), this->name().length(),
          ::google::protobuf::internal::WireFormat::PARSE);
        if (input->ExpectTag(18)) goto parse_signatures;
        break;
      }
      
      // required .signconf.pb.Signatures signatures = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_signatures:
        DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
             input, mutable_signatures()));
        if (input->ExpectTag(26)) goto parse_denial;
        break;
      }
      
      // required .signconf.pb.Denial denial = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_denial:
        DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
             input, mutable_denial()));
        if (input->ExpectTag(34)) goto parse_keys;
        break;
      }
      
      // required .signconf.pb.Keys keys = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_keys:
        DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
             input, mutable_keys()));
        if (input->ExpectTag(40)) goto parse_ttl;
        break;
      }
      
      // required int32 ttl = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
       parse_ttl:
        DO_(::google::protobuf::internal::WireFormatLite::ReadInt32(
              input, &ttl_));
        _set_bit(4);
        if (input->ExpectTag(48)) goto parse_min;
        break;
      }
      
      // required int32 min = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
       parse_min:
        DO_(::google::protobuf::internal::WireFormatLite::ReadInt32(
              input, &min_));
        _set_bit(5);
        if (input->ExpectTag(56)) goto parse_serial;
        break;
      }
      
      // required .signconf.pb.serial serial = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
       parse_serial:
        int value;
        DO_(::google::protobuf::internal::WireFormatLite::ReadEnum(input, &value));
        if (signconf::pb::serial_IsValid(value)) {
          set_serial(static_cast< signconf::pb::serial >(value));
        } else {
          mutable_unknown_fields()->AddVarint(7, value);
        }
        if (input->ExpectTag(64)) goto parse_audit;
        break;
      }
      
      // optional bool audit = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
       parse_audit:
        DO_(::google::protobuf::internal::WireFormatLite::ReadBool(
              input, &audit_));
        _set_bit(7);
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Zone::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  ::google::protobuf::uint8* raw_buffer = output->GetDirectBufferForNBytesAndAdvance(_cached_size_);
  if (raw_buffer != NULL) {
    Zone::SerializeWithCachedSizesToArray(raw_buffer);
    return;
  }
  
  // required string name = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->name(), output);
  }
  
  // required .signconf.pb.Signatures signatures = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageNoVirtual(
      2, this->signatures(), output);
  }
  
  // required .signconf.pb.Denial denial = 3;
  if (_has_bit(2)) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageNoVirtual(
      3, this->denial(), output);
  }
  
  // required .signconf.pb.Keys keys = 4;
  if (_has_bit(3)) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageNoVirtual(
      4, this->keys(), output);
  }
  
  // required int32 ttl = 5;
  if (_has_bit(4)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->ttl(), output);
  }
  
  // required int32 min = 6;
  if (_has_bit(5)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->min(), output);
  }
  
  // required .signconf.pb.serial serial = 7;
  if (_has_bit(6)) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      7, this->serial(), output);
  }
  
  // optional bool audit = 8;
  if (_has_bit(7)) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(8, this->audit(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Zone::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string name = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }
  
  // required .signconf.pb.Signatures signatures = 2;
  if (_has_bit(1)) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->signatures(), target);
  }
  
  // required .signconf.pb.Denial denial = 3;
  if (_has_bit(2)) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->denial(), target);
  }
  
  // required .signconf.pb.Keys keys = 4;
  if (_has_bit(3)) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->keys(), target);
  }
  
  // required int32 ttl = 5;
  if (_has_bit(4)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->ttl(), target);
  }
  
  // required int32 min = 6;
  if (_has_bit(5)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(6, this->min(), target);
  }
  
  // required .signconf.pb.serial serial = 7;
  if (_has_bit(6)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      7, this->serial(), target);
  }
  
  // optional bool audit = 8;
  if (_has_bit(7)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(8, this->audit(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Zone::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }
    
    // required .signconf.pb.Signatures signatures = 2;
    if (has_signatures()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->signatures());
    }
    
    // required .signconf.pb.Denial denial = 3;
    if (has_denial()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->denial());
    }
    
    // required .signconf.pb.Keys keys = 4;
    if (has_keys()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->keys());
    }
    
    // required int32 ttl = 5;
    if (has_ttl()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->ttl());
    }
    
    // required int32 min = 6;
    if (has_min()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->min());
    }
    
    // required .signconf.pb.serial serial = 7;
    if (has_serial()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->serial());
    }
    
    // optional bool audit = 8;
    if (has_audit()) {
      total_size += 1 + 1;
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  _cached_size_ = total_size;
  return total_size;
}

void Zone::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Zone* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Zone*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Zone::MergeFrom(const Zone& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_name(from.name());
    }
    if (from._has_bit(1)) {
      mutable_signatures()->::signconf::pb::Signatures::MergeFrom(from.signatures());
    }
    if (from._has_bit(2)) {
      mutable_denial()->::signconf::pb::Denial::MergeFrom(from.denial());
    }
    if (from._has_bit(3)) {
      mutable_keys()->::signconf::pb::Keys::MergeFrom(from.keys());
    }
    if (from._has_bit(4)) {
      set_ttl(from.ttl());
    }
    if (from._has_bit(5)) {
      set_min(from.min());
    }
    if (from._has_bit(6)) {
      set_serial(from.serial());
    }
    if (from._has_bit(7)) {
      set_audit(from.audit());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Zone::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Zone::CopyFrom(const Zone& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Zone::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000007f) != 0x0000007f) return false;
  
  if (has_signatures()) {
    if (!this->signatures().IsInitialized()) return false;
  }
  if (has_denial()) {
    if (!this->denial().IsInitialized()) return false;
  }
  if (has_keys()) {
    if (!this->keys().IsInitialized()) return false;
  }
  return true;
}

void Zone::Swap(Zone* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    std::swap(signatures_, other->signatures_);
    std::swap(denial_, other->denial_);
    std::swap(keys_, other->keys_);
    std::swap(ttl_, other->ttl_);
    std::swap(min_, other->min_);
    std::swap(serial_, other->serial_);
    std::swap(audit_, other->audit_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Zone::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Zone_descriptor_;
  metadata.reflection = Zone_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Signatures::kResignFieldNumber;
const int Signatures::kRefreshFieldNumber;
const int Signatures::kValdefaultFieldNumber;
const int Signatures::kValdenialFieldNumber;
const int Signatures::kJitterFieldNumber;
const int Signatures::kInceptionOffsetFieldNumber;
#endif  // !_MSC_VER

Signatures::Signatures() {
  SharedCtor();
}

void Signatures::InitAsDefaultInstance() {
}

Signatures::Signatures(const Signatures& from) {
  SharedCtor();
  MergeFrom(from);
}

void Signatures::SharedCtor() {
  _cached_size_ = 0;
  resign_ = 0;
  refresh_ = 0;
  valdefault_ = 0;
  valdenial_ = 0;
  jitter_ = 0;
  inceptionoffset_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Signatures::~Signatures() {
  SharedDtor();
}

void Signatures::SharedDtor() {
  if (this != default_instance_) {
  }
}

const ::google::protobuf::Descriptor* Signatures::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Signatures_descriptor_;
}

const Signatures& Signatures::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_signconf_2eproto();  return *default_instance_;
}

Signatures* Signatures::default_instance_ = NULL;

Signatures* Signatures::New() const {
  return new Signatures;
}

void Signatures::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    resign_ = 0;
    refresh_ = 0;
    valdefault_ = 0;
    valdenial_ = 0;
    jitter_ = 0;
    inceptionoffset_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Signatures::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 resign = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
        DO_(::google::protobuf::internal::WireFormatLite::ReadInt32(
              input, &resign_));
        _set_bit(0);
        if (input->ExpectTag(16)) goto parse_refresh;
        break;
      }
      
      // required int32 refresh = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
       parse_refresh:
        DO_(::google::protobuf::internal::WireFormatLite::ReadInt32(
              input, &refresh_));
        _set_bit(1);
        if (input->ExpectTag(24)) goto parse_valdefault;
        break;
      }
      
      // required int32 valdefault = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
       parse_valdefault:
        DO_(::google::protobuf::internal::WireFormatLite::ReadInt32(
              input, &valdefault_));
        _set_bit(2);
        if (input->ExpectTag(32)) goto parse_valdenial;
        break;
      }
      
      // required int32 valdenial = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
       parse_valdenial:
        DO_(::google::protobuf::internal::WireFormatLite::ReadInt32(
              input, &valdenial_));
        _set_bit(3);
        if (input->ExpectTag(40)) goto parse_jitter;
        break;
      }
      
      // required int32 jitter = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
       parse_jitter:
        DO_(::google::protobuf::internal::WireFormatLite::ReadInt32(
              input, &jitter_));
        _set_bit(4);
        if (input->ExpectTag(48)) goto parse_inceptionOffset;
        break;
      }
      
      // required int32 inceptionOffset = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
       parse_inceptionOffset:
        DO_(::google::protobuf::internal::WireFormatLite::ReadInt32(
              input, &inceptionoffset_));
        _set_bit(5);
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Signatures::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  ::google::protobuf::uint8* raw_buffer = output->GetDirectBufferForNBytesAndAdvance(_cached_size_);
  if (raw_buffer != NULL) {
    Signatures::SerializeWithCachedSizesToArray(raw_buffer);
    return;
  }
  
  // required int32 resign = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->resign(), output);
  }
  
  // required int32 refresh = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->refresh(), output);
  }
  
  // required int32 valdefault = 3;
  if (_has_bit(2)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->valdefault(), output);
  }
  
  // required int32 valdenial = 4;
  if (_has_bit(3)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->valdenial(), output);
  }
  
  // required int32 jitter = 5;
  if (_has_bit(4)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->jitter(), output);
  }
  
  // required int32 inceptionOffset = 6;
  if (_has_bit(5)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->inceptionoffset(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Signatures::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 resign = 1;
  if (_has_bit(0)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->resign(), target);
  }
  
  // required int32 refresh = 2;
  if (_has_bit(1)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->refresh(), target);
  }
  
  // required int32 valdefault = 3;
  if (_has_bit(2)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->valdefault(), target);
  }
  
  // required int32 valdenial = 4;
  if (_has_bit(3)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->valdenial(), target);
  }
  
  // required int32 jitter = 5;
  if (_has_bit(4)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->jitter(), target);
  }
  
  // required int32 inceptionOffset = 6;
  if (_has_bit(5)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(6, this->inceptionoffset(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Signatures::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 resign = 1;
    if (has_resign()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->resign());
    }
    
    // required int32 refresh = 2;
    if (has_refresh()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->refresh());
    }
    
    // required int32 valdefault = 3;
    if (has_valdefault()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->valdefault());
    }
    
    // required int32 valdenial = 4;
    if (has_valdenial()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->valdenial());
    }
    
    // required int32 jitter = 5;
    if (has_jitter()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->jitter());
    }
    
    // required int32 inceptionOffset = 6;
    if (has_inceptionoffset()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->inceptionoffset());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  _cached_size_ = total_size;
  return total_size;
}

void Signatures::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Signatures* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Signatures*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Signatures::MergeFrom(const Signatures& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_resign(from.resign());
    }
    if (from._has_bit(1)) {
      set_refresh(from.refresh());
    }
    if (from._has_bit(2)) {
      set_valdefault(from.valdefault());
    }
    if (from._has_bit(3)) {
      set_valdenial(from.valdenial());
    }
    if (from._has_bit(4)) {
      set_jitter(from.jitter());
    }
    if (from._has_bit(5)) {
      set_inceptionoffset(from.inceptionoffset());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Signatures::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Signatures::CopyFrom(const Signatures& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Signatures::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000003f) != 0x0000003f) return false;
  
  return true;
}

void Signatures::Swap(Signatures* other) {
  if (other != this) {
    std::swap(resign_, other->resign_);
    std::swap(refresh_, other->refresh_);
    std::swap(valdefault_, other->valdefault_);
    std::swap(valdenial_, other->valdenial_);
    std::swap(jitter_, other->jitter_);
    std::swap(inceptionoffset_, other->inceptionoffset_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Signatures::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Signatures_descriptor_;
  metadata.reflection = Signatures_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Denial::kNsecFieldNumber;
const int Denial::kNsec3FieldNumber;
#endif  // !_MSC_VER

Denial::Denial() {
  SharedCtor();
}

void Denial::InitAsDefaultInstance() {
  nsec_ = const_cast< ::signconf::pb::NSEC*>(&::signconf::pb::NSEC::default_instance());
  nsec3_ = const_cast< ::signconf::pb::NSEC3*>(&::signconf::pb::NSEC3::default_instance());
}

Denial::Denial(const Denial& from) {
  SharedCtor();
  MergeFrom(from);
}

void Denial::SharedCtor() {
  _cached_size_ = 0;
  nsec_ = NULL;
  nsec3_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Denial::~Denial() {
  SharedDtor();
}

void Denial::SharedDtor() {
  if (this != default_instance_) {
    delete nsec_;
    delete nsec3_;
  }
}

const ::google::protobuf::Descriptor* Denial::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Denial_descriptor_;
}

const Denial& Denial::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_signconf_2eproto();  return *default_instance_;
}

Denial* Denial::default_instance_ = NULL;

Denial* Denial::New() const {
  return new Denial;
}

void Denial::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (_has_bit(0)) {
      if (nsec_ != NULL) nsec_->::signconf::pb::NSEC::Clear();
    }
    if (_has_bit(1)) {
      if (nsec3_ != NULL) nsec3_->::signconf::pb::NSEC3::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Denial::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .signconf.pb.NSEC nsec = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
        DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
             input, mutable_nsec()));
        if (input->ExpectTag(18)) goto parse_nsec3;
        break;
      }
      
      // optional .signconf.pb.NSEC3 nsec3 = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_nsec3:
        DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
             input, mutable_nsec3()));
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Denial::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  ::google::protobuf::uint8* raw_buffer = output->GetDirectBufferForNBytesAndAdvance(_cached_size_);
  if (raw_buffer != NULL) {
    Denial::SerializeWithCachedSizesToArray(raw_buffer);
    return;
  }
  
  // optional .signconf.pb.NSEC nsec = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageNoVirtual(
      1, this->nsec(), output);
  }
  
  // optional .signconf.pb.NSEC3 nsec3 = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageNoVirtual(
      2, this->nsec3(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Denial::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional .signconf.pb.NSEC nsec = 1;
  if (_has_bit(0)) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->nsec(), target);
  }
  
  // optional .signconf.pb.NSEC3 nsec3 = 2;
  if (_has_bit(1)) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->nsec3(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Denial::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .signconf.pb.NSEC nsec = 1;
    if (has_nsec()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->nsec());
    }
    
    // optional .signconf.pb.NSEC3 nsec3 = 2;
    if (has_nsec3()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->nsec3());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  _cached_size_ = total_size;
  return total_size;
}

void Denial::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Denial* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Denial*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Denial::MergeFrom(const Denial& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      mutable_nsec()->::signconf::pb::NSEC::MergeFrom(from.nsec());
    }
    if (from._has_bit(1)) {
      mutable_nsec3()->::signconf::pb::NSEC3::MergeFrom(from.nsec3());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Denial::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Denial::CopyFrom(const Denial& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Denial::IsInitialized() const {
  
  if (has_nsec3()) {
    if (!this->nsec3().IsInitialized()) return false;
  }
  return true;
}

void Denial::Swap(Denial* other) {
  if (other != this) {
    std::swap(nsec_, other->nsec_);
    std::swap(nsec3_, other->nsec3_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Denial::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Denial_descriptor_;
  metadata.reflection = Denial_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

NSEC::NSEC() {
  SharedCtor();
}

void NSEC::InitAsDefaultInstance() {
}

NSEC::NSEC(const NSEC& from) {
  SharedCtor();
  MergeFrom(from);
}

void NSEC::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NSEC::~NSEC() {
  SharedDtor();
}

void NSEC::SharedDtor() {
  if (this != default_instance_) {
  }
}

const ::google::protobuf::Descriptor* NSEC::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return NSEC_descriptor_;
}

const NSEC& NSEC::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_signconf_2eproto();  return *default_instance_;
}

NSEC* NSEC::default_instance_ = NULL;

NSEC* NSEC::New() const {
  return new NSEC;
}

void NSEC::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool NSEC::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      return true;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, mutable_unknown_fields()));
  }
  return true;
#undef DO_
}

void NSEC::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  ::google::protobuf::uint8* raw_buffer = output->GetDirectBufferForNBytesAndAdvance(_cached_size_);
  if (raw_buffer != NULL) {
    NSEC::SerializeWithCachedSizesToArray(raw_buffer);
    return;
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* NSEC::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int NSEC::ByteSize() const {
  int total_size = 0;
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  _cached_size_ = total_size;
  return total_size;
}

void NSEC::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const NSEC* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const NSEC*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void NSEC::MergeFrom(const NSEC& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void NSEC::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void NSEC::CopyFrom(const NSEC& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NSEC::IsInitialized() const {
  
  return true;
}

void NSEC::Swap(NSEC* other) {
  if (other != this) {
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata NSEC::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = NSEC_descriptor_;
  metadata.reflection = NSEC_reflection_;
  return metadata;
}


// ===================================================================

const ::std::string NSEC3::_default_salt_;
#ifndef _MSC_VER
const int NSEC3::kOptoutFieldNumber;
const int NSEC3::kAlgorithmFieldNumber;
const int NSEC3::kIterationsFieldNumber;
const int NSEC3::kSaltFieldNumber;
#endif  // !_MSC_VER

NSEC3::NSEC3() {
  SharedCtor();
}

void NSEC3::InitAsDefaultInstance() {
}

NSEC3::NSEC3(const NSEC3& from) {
  SharedCtor();
  MergeFrom(from);
}

void NSEC3::SharedCtor() {
  _cached_size_ = 0;
  optout_ = false;
  algorithm_ = 0;
  iterations_ = 0;
  salt_ = const_cast< ::std::string*>(&_default_salt_);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NSEC3::~NSEC3() {
  SharedDtor();
}

void NSEC3::SharedDtor() {
  if (salt_ != &_default_salt_) {
    delete salt_;
  }
  if (this != default_instance_) {
  }
}

const ::google::protobuf::Descriptor* NSEC3::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return NSEC3_descriptor_;
}

const NSEC3& NSEC3::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_signconf_2eproto();  return *default_instance_;
}

NSEC3* NSEC3::default_instance_ = NULL;

NSEC3* NSEC3::New() const {
  return new NSEC3;
}

void NSEC3::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    optout_ = false;
    algorithm_ = 0;
    iterations_ = 0;
    if (_has_bit(3)) {
      if (salt_ != &_default_salt_) {
        salt_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool NSEC3::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bool optout = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
        DO_(::google::protobuf::internal::WireFormatLite::ReadBool(
              input, &optout_));
        _set_bit(0);
        if (input->ExpectTag(16)) goto parse_algorithm;
        break;
      }
      
      // required int32 algorithm = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
       parse_algorithm:
        DO_(::google::protobuf::internal::WireFormatLite::ReadInt32(
              input, &algorithm_));
        _set_bit(1);
        if (input->ExpectTag(24)) goto parse_iterations;
        break;
      }
      
      // required int32 iterations = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
       parse_iterations:
        DO_(::google::protobuf::internal::WireFormatLite::ReadInt32(
              input, &iterations_));
        _set_bit(2);
        if (input->ExpectTag(34)) goto parse_salt;
        break;
      }
      
      // required string salt = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_salt:
        DO_(::google::protobuf::internal::WireFormatLite::ReadString(
              input, this->mutable_salt()));
        ::google::protobuf::internal::WireFormat::VerifyUTF8String(
          this->salt().data(), this->salt().length(),
          ::google::protobuf::internal::WireFormat::PARSE);
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void NSEC3::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  ::google::protobuf::uint8* raw_buffer = output->GetDirectBufferForNBytesAndAdvance(_cached_size_);
  if (raw_buffer != NULL) {
    NSEC3::SerializeWithCachedSizesToArray(raw_buffer);
    return;
  }
  
  // optional bool optout = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->optout(), output);
  }
  
  // required int32 algorithm = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->algorithm(), output);
  }
  
  // required int32 iterations = 3;
  if (_has_bit(2)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->iterations(), output);
  }
  
  // required string salt = 4;
  if (_has_bit(3)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->salt().data(), this->salt().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->salt(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* NSEC3::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional bool optout = 1;
  if (_has_bit(0)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(1, this->optout(), target);
  }
  
  // required int32 algorithm = 2;
  if (_has_bit(1)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->algorithm(), target);
  }
  
  // required int32 iterations = 3;
  if (_has_bit(2)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->iterations(), target);
  }
  
  // required string salt = 4;
  if (_has_bit(3)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->salt().data(), this->salt().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->salt(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int NSEC3::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bool optout = 1;
    if (has_optout()) {
      total_size += 1 + 1;
    }
    
    // required int32 algorithm = 2;
    if (has_algorithm()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->algorithm());
    }
    
    // required int32 iterations = 3;
    if (has_iterations()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->iterations());
    }
    
    // required string salt = 4;
    if (has_salt()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->salt());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  _cached_size_ = total_size;
  return total_size;
}

void NSEC3::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const NSEC3* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const NSEC3*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void NSEC3::MergeFrom(const NSEC3& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_optout(from.optout());
    }
    if (from._has_bit(1)) {
      set_algorithm(from.algorithm());
    }
    if (from._has_bit(2)) {
      set_iterations(from.iterations());
    }
    if (from._has_bit(3)) {
      set_salt(from.salt());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void NSEC3::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void NSEC3::CopyFrom(const NSEC3& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NSEC3::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000e) != 0x0000000e) return false;
  
  return true;
}

void NSEC3::Swap(NSEC3* other) {
  if (other != this) {
    std::swap(optout_, other->optout_);
    std::swap(algorithm_, other->algorithm_);
    std::swap(iterations_, other->iterations_);
    std::swap(salt_, other->salt_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata NSEC3::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = NSEC3_descriptor_;
  metadata.reflection = NSEC3_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Keys::kTtlFieldNumber;
const int Keys::kKeysFieldNumber;
#endif  // !_MSC_VER

Keys::Keys() {
  SharedCtor();
}

void Keys::InitAsDefaultInstance() {
}

Keys::Keys(const Keys& from) {
  SharedCtor();
  MergeFrom(from);
}

void Keys::SharedCtor() {
  _cached_size_ = 0;
  ttl_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Keys::~Keys() {
  SharedDtor();
}

void Keys::SharedDtor() {
  if (this != default_instance_) {
  }
}

const ::google::protobuf::Descriptor* Keys::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Keys_descriptor_;
}

const Keys& Keys::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_signconf_2eproto();  return *default_instance_;
}

Keys* Keys::default_instance_ = NULL;

Keys* Keys::New() const {
  return new Keys;
}

void Keys::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    ttl_ = 0;
  }
  keys_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Keys::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 ttl = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
        DO_(::google::protobuf::internal::WireFormatLite::ReadInt32(
              input, &ttl_));
        _set_bit(0);
        if (input->ExpectTag(18)) goto parse_keys;
        break;
      }
      
      // repeated .signconf.pb.Key keys = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_keys:
        DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
              input, add_keys()));
        if (input->ExpectTag(18)) goto parse_keys;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Keys::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  ::google::protobuf::uint8* raw_buffer = output->GetDirectBufferForNBytesAndAdvance(_cached_size_);
  if (raw_buffer != NULL) {
    Keys::SerializeWithCachedSizesToArray(raw_buffer);
    return;
  }
  
  // required int32 ttl = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->ttl(), output);
  }
  
  // repeated .signconf.pb.Key keys = 2;
  for (int i = 0; i < this->keys_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageNoVirtual(
      2, this->keys(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Keys::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 ttl = 1;
  if (_has_bit(0)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->ttl(), target);
  }
  
  // repeated .signconf.pb.Key keys = 2;
  for (int i = 0; i < this->keys_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->keys(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Keys::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 ttl = 1;
    if (has_ttl()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->ttl());
    }
    
  }
  // repeated .signconf.pb.Key keys = 2;
  total_size += 1 * this->keys_size();
  for (int i = 0; i < this->keys_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->keys(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  _cached_size_ = total_size;
  return total_size;
}

void Keys::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Keys* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Keys*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Keys::MergeFrom(const Keys& from) {
  GOOGLE_CHECK_NE(&from, this);
  keys_.MergeFrom(from.keys_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_ttl(from.ttl());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Keys::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Keys::CopyFrom(const Keys& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Keys::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  for (int i = 0; i < keys_size(); i++) {
    if (!this->keys(i).IsInitialized()) return false;
  }
  return true;
}

void Keys::Swap(Keys* other) {
  if (other != this) {
    std::swap(ttl_, other->ttl_);
    keys_.Swap(&other->keys_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Keys::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Keys_descriptor_;
  metadata.reflection = Keys_reflection_;
  return metadata;
}


// ===================================================================

const ::std::string Key::_default_locator_;
#ifndef _MSC_VER
const int Key::kFlagsFieldNumber;
const int Key::kAlgorithmFieldNumber;
const int Key::kLocatorFieldNumber;
const int Key::kKskFieldNumber;
const int Key::kZskFieldNumber;
const int Key::kPublishFieldNumber;
const int Key::kDeactivateFieldNumber;
#endif  // !_MSC_VER

Key::Key() {
  SharedCtor();
}

void Key::InitAsDefaultInstance() {
}

Key::Key(const Key& from) {
  SharedCtor();
  MergeFrom(from);
}

void Key::SharedCtor() {
  _cached_size_ = 0;
  flags_ = 0u;
  algorithm_ = 0u;
  locator_ = const_cast< ::std::string*>(&_default_locator_);
  ksk_ = false;
  zsk_ = false;
  publish_ = false;
  deactivate_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Key::~Key() {
  SharedDtor();
}

void Key::SharedDtor() {
  if (locator_ != &_default_locator_) {
    delete locator_;
  }
  if (this != default_instance_) {
  }
}

const ::google::protobuf::Descriptor* Key::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Key_descriptor_;
}

const Key& Key::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_signconf_2eproto();  return *default_instance_;
}

Key* Key::default_instance_ = NULL;

Key* Key::New() const {
  return new Key;
}

void Key::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    flags_ = 0u;
    algorithm_ = 0u;
    if (_has_bit(2)) {
      if (locator_ != &_default_locator_) {
        locator_->clear();
      }
    }
    ksk_ = false;
    zsk_ = false;
    publish_ = false;
    deactivate_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Key::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 flags = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
        DO_(::google::protobuf::internal::WireFormatLite::ReadUInt32(
              input, &flags_));
        _set_bit(0);
        if (input->ExpectTag(16)) goto parse_algorithm;
        break;
      }
      
      // required uint32 algorithm = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
       parse_algorithm:
        DO_(::google::protobuf::internal::WireFormatLite::ReadUInt32(
              input, &algorithm_));
        _set_bit(1);
        if (input->ExpectTag(26)) goto parse_locator;
        break;
      }
      
      // required string locator = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_locator:
        DO_(::google::protobuf::internal::WireFormatLite::ReadString(
              input, this->mutable_locator()));
        ::google::protobuf::internal::WireFormat::VerifyUTF8String(
          this->locator().data(), this->locator().length(),
          ::google::protobuf::internal::WireFormat::PARSE);
        if (input->ExpectTag(32)) goto parse_ksk;
        break;
      }
      
      // optional bool ksk = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
       parse_ksk:
        DO_(::google::protobuf::internal::WireFormatLite::ReadBool(
              input, &ksk_));
        _set_bit(3);
        if (input->ExpectTag(40)) goto parse_zsk;
        break;
      }
      
      // optional bool zsk = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
       parse_zsk:
        DO_(::google::protobuf::internal::WireFormatLite::ReadBool(
              input, &zsk_));
        _set_bit(4);
        if (input->ExpectTag(48)) goto parse_publish;
        break;
      }
      
      // optional bool publish = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
       parse_publish:
        DO_(::google::protobuf::internal::WireFormatLite::ReadBool(
              input, &publish_));
        _set_bit(5);
        if (input->ExpectTag(56)) goto parse_deactivate;
        break;
      }
      
      // optional bool deactivate = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
       parse_deactivate:
        DO_(::google::protobuf::internal::WireFormatLite::ReadBool(
              input, &deactivate_));
        _set_bit(6);
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Key::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  ::google::protobuf::uint8* raw_buffer = output->GetDirectBufferForNBytesAndAdvance(_cached_size_);
  if (raw_buffer != NULL) {
    Key::SerializeWithCachedSizesToArray(raw_buffer);
    return;
  }
  
  // required uint32 flags = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->flags(), output);
  }
  
  // required uint32 algorithm = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->algorithm(), output);
  }
  
  // required string locator = 3;
  if (_has_bit(2)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->locator().data(), this->locator().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->locator(), output);
  }
  
  // optional bool ksk = 4;
  if (_has_bit(3)) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->ksk(), output);
  }
  
  // optional bool zsk = 5;
  if (_has_bit(4)) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(5, this->zsk(), output);
  }
  
  // optional bool publish = 6;
  if (_has_bit(5)) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(6, this->publish(), output);
  }
  
  // optional bool deactivate = 7;
  if (_has_bit(6)) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(7, this->deactivate(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Key::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint32 flags = 1;
  if (_has_bit(0)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->flags(), target);
  }
  
  // required uint32 algorithm = 2;
  if (_has_bit(1)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->algorithm(), target);
  }
  
  // required string locator = 3;
  if (_has_bit(2)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->locator().data(), this->locator().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->locator(), target);
  }
  
  // optional bool ksk = 4;
  if (_has_bit(3)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(4, this->ksk(), target);
  }
  
  // optional bool zsk = 5;
  if (_has_bit(4)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(5, this->zsk(), target);
  }
  
  // optional bool publish = 6;
  if (_has_bit(5)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(6, this->publish(), target);
  }
  
  // optional bool deactivate = 7;
  if (_has_bit(6)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(7, this->deactivate(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Key::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 flags = 1;
    if (has_flags()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->flags());
    }
    
    // required uint32 algorithm = 2;
    if (has_algorithm()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->algorithm());
    }
    
    // required string locator = 3;
    if (has_locator()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->locator());
    }
    
    // optional bool ksk = 4;
    if (has_ksk()) {
      total_size += 1 + 1;
    }
    
    // optional bool zsk = 5;
    if (has_zsk()) {
      total_size += 1 + 1;
    }
    
    // optional bool publish = 6;
    if (has_publish()) {
      total_size += 1 + 1;
    }
    
    // optional bool deactivate = 7;
    if (has_deactivate()) {
      total_size += 1 + 1;
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  _cached_size_ = total_size;
  return total_size;
}

void Key::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Key* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Key*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Key::MergeFrom(const Key& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_flags(from.flags());
    }
    if (from._has_bit(1)) {
      set_algorithm(from.algorithm());
    }
    if (from._has_bit(2)) {
      set_locator(from.locator());
    }
    if (from._has_bit(3)) {
      set_ksk(from.ksk());
    }
    if (from._has_bit(4)) {
      set_zsk(from.zsk());
    }
    if (from._has_bit(5)) {
      set_publish(from.publish());
    }
    if (from._has_bit(6)) {
      set_deactivate(from.deactivate());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Key::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Key::CopyFrom(const Key& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Key::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;
  
  return true;
}

void Key::Swap(Key* other) {
  if (other != this) {
    std::swap(flags_, other->flags_);
    std::swap(algorithm_, other->algorithm_);
    std::swap(locator_, other->locator_);
    std::swap(ksk_, other->ksk_);
    std::swap(zsk_, other->zsk_);
    std::swap(publish_, other->publish_);
    std::swap(deactivate_, other->deactivate_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Key::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Key_descriptor_;
  metadata.reflection = Key_reflection_;
  return metadata;
}


}  // namespace pb
}  // namespace signconf
