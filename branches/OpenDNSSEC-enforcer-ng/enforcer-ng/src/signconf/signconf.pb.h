// Generated by the protocol buffer compiler.  DO NOT EDIT!

#ifndef PROTOBUF_signconf_2eproto__INCLUDED
#define PROTOBUF_signconf_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2002000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2002000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
#include "xmlext.pb.h"

namespace signconf {
namespace pb {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_signconf_2eproto();
void protobuf_AssignDesc_signconf_2eproto();
void protobuf_ShutdownFile_signconf_2eproto();

class SignerConfigurationDocument;
class SignerConfiguration;
class Zone;
class Signatures;
class Denial;
class NSEC;
class NSEC3;
class Keys;
class Key;

enum serial {
  counter = 1,
  datecounter = 2,
  unixtime = 3,
  keep = 4
};
bool serial_IsValid(int value);
const serial serial_MIN = counter;
const serial serial_MAX = keep;

const ::google::protobuf::EnumDescriptor* serial_descriptor();
inline const ::std::string& serial_Name(serial value) {
  return ::google::protobuf::internal::NameOfEnum(
    serial_descriptor(), value);
}
inline bool serial_Parse(
    const ::std::string& name, serial* value) {
  return ::google::protobuf::internal::ParseNamedEnum<serial>(
    serial_descriptor(), name, value);
}
// ===================================================================

class SignerConfigurationDocument : public ::google::protobuf::Message {
 public:
  SignerConfigurationDocument();
  virtual ~SignerConfigurationDocument();
  
  SignerConfigurationDocument(const SignerConfigurationDocument& from);
  
  inline SignerConfigurationDocument& operator=(const SignerConfigurationDocument& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SignerConfigurationDocument& default_instance();
  void Swap(SignerConfigurationDocument* other);
  
  // implements Message ----------------------------------------------
  
  SignerConfigurationDocument* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SignerConfigurationDocument& from);
  void MergeFrom(const SignerConfigurationDocument& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .signconf.pb.SignerConfiguration signerconfiguration = 1;
  inline bool has_signerconfiguration() const;
  inline void clear_signerconfiguration();
  static const int kSignerconfigurationFieldNumber = 1;
  inline const ::signconf::pb::SignerConfiguration& signerconfiguration() const;
  inline ::signconf::pb::SignerConfiguration* mutable_signerconfiguration();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::signconf::pb::SignerConfiguration* signerconfiguration_;
  friend void  protobuf_AddDesc_signconf_2eproto();
  friend void protobuf_AssignDesc_signconf_2eproto();
  friend void protobuf_ShutdownFile_signconf_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static SignerConfigurationDocument* default_instance_;
};
// -------------------------------------------------------------------

class SignerConfiguration : public ::google::protobuf::Message {
 public:
  SignerConfiguration();
  virtual ~SignerConfiguration();
  
  SignerConfiguration(const SignerConfiguration& from);
  
  inline SignerConfiguration& operator=(const SignerConfiguration& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SignerConfiguration& default_instance();
  void Swap(SignerConfiguration* other);
  
  // implements Message ----------------------------------------------
  
  SignerConfiguration* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SignerConfiguration& from);
  void MergeFrom(const SignerConfiguration& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .signconf.pb.Zone zone = 1;
  inline bool has_zone() const;
  inline void clear_zone();
  static const int kZoneFieldNumber = 1;
  inline const ::signconf::pb::Zone& zone() const;
  inline ::signconf::pb::Zone* mutable_zone();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::signconf::pb::Zone* zone_;
  friend void  protobuf_AddDesc_signconf_2eproto();
  friend void protobuf_AssignDesc_signconf_2eproto();
  friend void protobuf_ShutdownFile_signconf_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static SignerConfiguration* default_instance_;
};
// -------------------------------------------------------------------

class Zone : public ::google::protobuf::Message {
 public:
  Zone();
  virtual ~Zone();
  
  Zone(const Zone& from);
  
  inline Zone& operator=(const Zone& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Zone& default_instance();
  void Swap(Zone* other);
  
  // implements Message ----------------------------------------------
  
  Zone* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Zone& from);
  void MergeFrom(const Zone& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  
  // required .signconf.pb.Signatures signatures = 2;
  inline bool has_signatures() const;
  inline void clear_signatures();
  static const int kSignaturesFieldNumber = 2;
  inline const ::signconf::pb::Signatures& signatures() const;
  inline ::signconf::pb::Signatures* mutable_signatures();
  
  // required .signconf.pb.Denial denial = 3;
  inline bool has_denial() const;
  inline void clear_denial();
  static const int kDenialFieldNumber = 3;
  inline const ::signconf::pb::Denial& denial() const;
  inline ::signconf::pb::Denial* mutable_denial();
  
  // required .signconf.pb.Keys keys = 4;
  inline bool has_keys() const;
  inline void clear_keys();
  static const int kKeysFieldNumber = 4;
  inline const ::signconf::pb::Keys& keys() const;
  inline ::signconf::pb::Keys* mutable_keys();
  
  // required int32 ttl = 5;
  inline bool has_ttl() const;
  inline void clear_ttl();
  static const int kTtlFieldNumber = 5;
  inline ::google::protobuf::int32 ttl() const;
  inline void set_ttl(::google::protobuf::int32 value);
  
  // required int32 min = 6;
  inline bool has_min() const;
  inline void clear_min();
  static const int kMinFieldNumber = 6;
  inline ::google::protobuf::int32 min() const;
  inline void set_min(::google::protobuf::int32 value);
  
  // required .signconf.pb.serial serial = 7;
  inline bool has_serial() const;
  inline void clear_serial();
  static const int kSerialFieldNumber = 7;
  inline signconf::pb::serial serial() const;
  inline void set_serial(signconf::pb::serial value);
  
  // optional bool audit = 8;
  inline bool has_audit() const;
  inline void clear_audit();
  static const int kAuditFieldNumber = 8;
  inline bool audit() const;
  inline void set_audit(bool value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* name_;
  static const ::std::string _default_name_;
  ::signconf::pb::Signatures* signatures_;
  ::signconf::pb::Denial* denial_;
  ::signconf::pb::Keys* keys_;
  ::google::protobuf::int32 ttl_;
  ::google::protobuf::int32 min_;
  int serial_;
  bool audit_;
  friend void  protobuf_AddDesc_signconf_2eproto();
  friend void protobuf_AssignDesc_signconf_2eproto();
  friend void protobuf_ShutdownFile_signconf_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Zone* default_instance_;
};
// -------------------------------------------------------------------

class Signatures : public ::google::protobuf::Message {
 public:
  Signatures();
  virtual ~Signatures();
  
  Signatures(const Signatures& from);
  
  inline Signatures& operator=(const Signatures& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Signatures& default_instance();
  void Swap(Signatures* other);
  
  // implements Message ----------------------------------------------
  
  Signatures* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Signatures& from);
  void MergeFrom(const Signatures& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 resign = 1;
  inline bool has_resign() const;
  inline void clear_resign();
  static const int kResignFieldNumber = 1;
  inline ::google::protobuf::int32 resign() const;
  inline void set_resign(::google::protobuf::int32 value);
  
  // required int32 refresh = 2;
  inline bool has_refresh() const;
  inline void clear_refresh();
  static const int kRefreshFieldNumber = 2;
  inline ::google::protobuf::int32 refresh() const;
  inline void set_refresh(::google::protobuf::int32 value);
  
  // required int32 valdefault = 3;
  inline bool has_valdefault() const;
  inline void clear_valdefault();
  static const int kValdefaultFieldNumber = 3;
  inline ::google::protobuf::int32 valdefault() const;
  inline void set_valdefault(::google::protobuf::int32 value);
  
  // required int32 valdenial = 4;
  inline bool has_valdenial() const;
  inline void clear_valdenial();
  static const int kValdenialFieldNumber = 4;
  inline ::google::protobuf::int32 valdenial() const;
  inline void set_valdenial(::google::protobuf::int32 value);
  
  // required int32 jitter = 5;
  inline bool has_jitter() const;
  inline void clear_jitter();
  static const int kJitterFieldNumber = 5;
  inline ::google::protobuf::int32 jitter() const;
  inline void set_jitter(::google::protobuf::int32 value);
  
  // required int32 inceptionOffset = 6;
  inline bool has_inceptionoffset() const;
  inline void clear_inceptionoffset();
  static const int kInceptionOffsetFieldNumber = 6;
  inline ::google::protobuf::int32 inceptionoffset() const;
  inline void set_inceptionoffset(::google::protobuf::int32 value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 resign_;
  ::google::protobuf::int32 refresh_;
  ::google::protobuf::int32 valdefault_;
  ::google::protobuf::int32 valdenial_;
  ::google::protobuf::int32 jitter_;
  ::google::protobuf::int32 inceptionoffset_;
  friend void  protobuf_AddDesc_signconf_2eproto();
  friend void protobuf_AssignDesc_signconf_2eproto();
  friend void protobuf_ShutdownFile_signconf_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Signatures* default_instance_;
};
// -------------------------------------------------------------------

class Denial : public ::google::protobuf::Message {
 public:
  Denial();
  virtual ~Denial();
  
  Denial(const Denial& from);
  
  inline Denial& operator=(const Denial& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Denial& default_instance();
  void Swap(Denial* other);
  
  // implements Message ----------------------------------------------
  
  Denial* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Denial& from);
  void MergeFrom(const Denial& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .signconf.pb.NSEC nsec = 1;
  inline bool has_nsec() const;
  inline void clear_nsec();
  static const int kNsecFieldNumber = 1;
  inline const ::signconf::pb::NSEC& nsec() const;
  inline ::signconf::pb::NSEC* mutable_nsec();
  
  // optional .signconf.pb.NSEC3 nsec3 = 2;
  inline bool has_nsec3() const;
  inline void clear_nsec3();
  static const int kNsec3FieldNumber = 2;
  inline const ::signconf::pb::NSEC3& nsec3() const;
  inline ::signconf::pb::NSEC3* mutable_nsec3();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::signconf::pb::NSEC* nsec_;
  ::signconf::pb::NSEC3* nsec3_;
  friend void  protobuf_AddDesc_signconf_2eproto();
  friend void protobuf_AssignDesc_signconf_2eproto();
  friend void protobuf_ShutdownFile_signconf_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Denial* default_instance_;
};
// -------------------------------------------------------------------

class NSEC : public ::google::protobuf::Message {
 public:
  NSEC();
  virtual ~NSEC();
  
  NSEC(const NSEC& from);
  
  inline NSEC& operator=(const NSEC& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const NSEC& default_instance();
  void Swap(NSEC* other);
  
  // implements Message ----------------------------------------------
  
  NSEC* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NSEC& from);
  void MergeFrom(const NSEC& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  friend void  protobuf_AddDesc_signconf_2eproto();
  friend void protobuf_AssignDesc_signconf_2eproto();
  friend void protobuf_ShutdownFile_signconf_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[1];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static NSEC* default_instance_;
};
// -------------------------------------------------------------------

class NSEC3 : public ::google::protobuf::Message {
 public:
  NSEC3();
  virtual ~NSEC3();
  
  NSEC3(const NSEC3& from);
  
  inline NSEC3& operator=(const NSEC3& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const NSEC3& default_instance();
  void Swap(NSEC3* other);
  
  // implements Message ----------------------------------------------
  
  NSEC3* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NSEC3& from);
  void MergeFrom(const NSEC3& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional bool optout = 1;
  inline bool has_optout() const;
  inline void clear_optout();
  static const int kOptoutFieldNumber = 1;
  inline bool optout() const;
  inline void set_optout(bool value);
  
  // required int32 algorithm = 2;
  inline bool has_algorithm() const;
  inline void clear_algorithm();
  static const int kAlgorithmFieldNumber = 2;
  inline ::google::protobuf::int32 algorithm() const;
  inline void set_algorithm(::google::protobuf::int32 value);
  
  // required int32 iterations = 3;
  inline bool has_iterations() const;
  inline void clear_iterations();
  static const int kIterationsFieldNumber = 3;
  inline ::google::protobuf::int32 iterations() const;
  inline void set_iterations(::google::protobuf::int32 value);
  
  // required string salt = 4;
  inline bool has_salt() const;
  inline void clear_salt();
  static const int kSaltFieldNumber = 4;
  inline const ::std::string& salt() const;
  inline void set_salt(const ::std::string& value);
  inline void set_salt(const char* value);
  inline void set_salt(const char* value, size_t size);
  inline ::std::string* mutable_salt();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  bool optout_;
  ::google::protobuf::int32 algorithm_;
  ::google::protobuf::int32 iterations_;
  ::std::string* salt_;
  static const ::std::string _default_salt_;
  friend void  protobuf_AddDesc_signconf_2eproto();
  friend void protobuf_AssignDesc_signconf_2eproto();
  friend void protobuf_ShutdownFile_signconf_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static NSEC3* default_instance_;
};
// -------------------------------------------------------------------

class Keys : public ::google::protobuf::Message {
 public:
  Keys();
  virtual ~Keys();
  
  Keys(const Keys& from);
  
  inline Keys& operator=(const Keys& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Keys& default_instance();
  void Swap(Keys* other);
  
  // implements Message ----------------------------------------------
  
  Keys* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Keys& from);
  void MergeFrom(const Keys& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 ttl = 1;
  inline bool has_ttl() const;
  inline void clear_ttl();
  static const int kTtlFieldNumber = 1;
  inline ::google::protobuf::int32 ttl() const;
  inline void set_ttl(::google::protobuf::int32 value);
  
  // repeated .signconf.pb.Key keys = 2;
  inline int keys_size() const;
  inline void clear_keys();
  static const int kKeysFieldNumber = 2;
  inline const ::google::protobuf::RepeatedPtrField< ::signconf::pb::Key >& keys() const;
  inline ::google::protobuf::RepeatedPtrField< ::signconf::pb::Key >* mutable_keys();
  inline const ::signconf::pb::Key& keys(int index) const;
  inline ::signconf::pb::Key* mutable_keys(int index);
  inline ::signconf::pb::Key* add_keys();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 ttl_;
  ::google::protobuf::RepeatedPtrField< ::signconf::pb::Key > keys_;
  friend void  protobuf_AddDesc_signconf_2eproto();
  friend void protobuf_AssignDesc_signconf_2eproto();
  friend void protobuf_ShutdownFile_signconf_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Keys* default_instance_;
};
// -------------------------------------------------------------------

class Key : public ::google::protobuf::Message {
 public:
  Key();
  virtual ~Key();
  
  Key(const Key& from);
  
  inline Key& operator=(const Key& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Key& default_instance();
  void Swap(Key* other);
  
  // implements Message ----------------------------------------------
  
  Key* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Key& from);
  void MergeFrom(const Key& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 flags = 1;
  inline bool has_flags() const;
  inline void clear_flags();
  static const int kFlagsFieldNumber = 1;
  inline ::google::protobuf::uint32 flags() const;
  inline void set_flags(::google::protobuf::uint32 value);
  
  // required uint32 algorithm = 2;
  inline bool has_algorithm() const;
  inline void clear_algorithm();
  static const int kAlgorithmFieldNumber = 2;
  inline ::google::protobuf::uint32 algorithm() const;
  inline void set_algorithm(::google::protobuf::uint32 value);
  
  // required string locator = 3;
  inline bool has_locator() const;
  inline void clear_locator();
  static const int kLocatorFieldNumber = 3;
  inline const ::std::string& locator() const;
  inline void set_locator(const ::std::string& value);
  inline void set_locator(const char* value);
  inline void set_locator(const char* value, size_t size);
  inline ::std::string* mutable_locator();
  
  // optional bool ksk = 4;
  inline bool has_ksk() const;
  inline void clear_ksk();
  static const int kKskFieldNumber = 4;
  inline bool ksk() const;
  inline void set_ksk(bool value);
  
  // optional bool zsk = 5;
  inline bool has_zsk() const;
  inline void clear_zsk();
  static const int kZskFieldNumber = 5;
  inline bool zsk() const;
  inline void set_zsk(bool value);
  
  // optional bool publish = 6;
  inline bool has_publish() const;
  inline void clear_publish();
  static const int kPublishFieldNumber = 6;
  inline bool publish() const;
  inline void set_publish(bool value);
  
  // optional bool deactivate = 7;
  inline bool has_deactivate() const;
  inline void clear_deactivate();
  static const int kDeactivateFieldNumber = 7;
  inline bool deactivate() const;
  inline void set_deactivate(bool value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 flags_;
  ::google::protobuf::uint32 algorithm_;
  ::std::string* locator_;
  static const ::std::string _default_locator_;
  bool ksk_;
  bool zsk_;
  bool publish_;
  bool deactivate_;
  friend void  protobuf_AddDesc_signconf_2eproto();
  friend void protobuf_AssignDesc_signconf_2eproto();
  friend void protobuf_ShutdownFile_signconf_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Key* default_instance_;
};
// ===================================================================


// ===================================================================


// ===================================================================

// SignerConfigurationDocument

// required .signconf.pb.SignerConfiguration signerconfiguration = 1;
inline bool SignerConfigurationDocument::has_signerconfiguration() const {
  return _has_bit(0);
}
inline void SignerConfigurationDocument::clear_signerconfiguration() {
  if (signerconfiguration_ != NULL) signerconfiguration_->::signconf::pb::SignerConfiguration::Clear();
  _clear_bit(0);
}
inline const ::signconf::pb::SignerConfiguration& SignerConfigurationDocument::signerconfiguration() const {
  return signerconfiguration_ != NULL ? *signerconfiguration_ : *default_instance_->signerconfiguration_;
}
inline ::signconf::pb::SignerConfiguration* SignerConfigurationDocument::mutable_signerconfiguration() {
  _set_bit(0);
  if (signerconfiguration_ == NULL) signerconfiguration_ = new ::signconf::pb::SignerConfiguration;
  return signerconfiguration_;
}

// -------------------------------------------------------------------

// SignerConfiguration

// required .signconf.pb.Zone zone = 1;
inline bool SignerConfiguration::has_zone() const {
  return _has_bit(0);
}
inline void SignerConfiguration::clear_zone() {
  if (zone_ != NULL) zone_->::signconf::pb::Zone::Clear();
  _clear_bit(0);
}
inline const ::signconf::pb::Zone& SignerConfiguration::zone() const {
  return zone_ != NULL ? *zone_ : *default_instance_->zone_;
}
inline ::signconf::pb::Zone* SignerConfiguration::mutable_zone() {
  _set_bit(0);
  if (zone_ == NULL) zone_ = new ::signconf::pb::Zone;
  return zone_;
}

// -------------------------------------------------------------------

// Zone

// required string name = 1;
inline bool Zone::has_name() const {
  return _has_bit(0);
}
inline void Zone::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& Zone::name() const {
  return *name_;
}
inline void Zone::set_name(const ::std::string& value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Zone::set_name(const char* value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Zone::set_name(const char* value, size_t size) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Zone::mutable_name() {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// required .signconf.pb.Signatures signatures = 2;
inline bool Zone::has_signatures() const {
  return _has_bit(1);
}
inline void Zone::clear_signatures() {
  if (signatures_ != NULL) signatures_->::signconf::pb::Signatures::Clear();
  _clear_bit(1);
}
inline const ::signconf::pb::Signatures& Zone::signatures() const {
  return signatures_ != NULL ? *signatures_ : *default_instance_->signatures_;
}
inline ::signconf::pb::Signatures* Zone::mutable_signatures() {
  _set_bit(1);
  if (signatures_ == NULL) signatures_ = new ::signconf::pb::Signatures;
  return signatures_;
}

// required .signconf.pb.Denial denial = 3;
inline bool Zone::has_denial() const {
  return _has_bit(2);
}
inline void Zone::clear_denial() {
  if (denial_ != NULL) denial_->::signconf::pb::Denial::Clear();
  _clear_bit(2);
}
inline const ::signconf::pb::Denial& Zone::denial() const {
  return denial_ != NULL ? *denial_ : *default_instance_->denial_;
}
inline ::signconf::pb::Denial* Zone::mutable_denial() {
  _set_bit(2);
  if (denial_ == NULL) denial_ = new ::signconf::pb::Denial;
  return denial_;
}

// required .signconf.pb.Keys keys = 4;
inline bool Zone::has_keys() const {
  return _has_bit(3);
}
inline void Zone::clear_keys() {
  if (keys_ != NULL) keys_->::signconf::pb::Keys::Clear();
  _clear_bit(3);
}
inline const ::signconf::pb::Keys& Zone::keys() const {
  return keys_ != NULL ? *keys_ : *default_instance_->keys_;
}
inline ::signconf::pb::Keys* Zone::mutable_keys() {
  _set_bit(3);
  if (keys_ == NULL) keys_ = new ::signconf::pb::Keys;
  return keys_;
}

// required int32 ttl = 5;
inline bool Zone::has_ttl() const {
  return _has_bit(4);
}
inline void Zone::clear_ttl() {
  ttl_ = 0;
  _clear_bit(4);
}
inline ::google::protobuf::int32 Zone::ttl() const {
  return ttl_;
}
inline void Zone::set_ttl(::google::protobuf::int32 value) {
  _set_bit(4);
  ttl_ = value;
}

// required int32 min = 6;
inline bool Zone::has_min() const {
  return _has_bit(5);
}
inline void Zone::clear_min() {
  min_ = 0;
  _clear_bit(5);
}
inline ::google::protobuf::int32 Zone::min() const {
  return min_;
}
inline void Zone::set_min(::google::protobuf::int32 value) {
  _set_bit(5);
  min_ = value;
}

// required .signconf.pb.serial serial = 7;
inline bool Zone::has_serial() const {
  return _has_bit(6);
}
inline void Zone::clear_serial() {
  serial_ = 1;
  _clear_bit(6);
}
inline signconf::pb::serial Zone::serial() const {
  return static_cast< signconf::pb::serial >(serial_);
}
inline void Zone::set_serial(signconf::pb::serial value) {
  GOOGLE_DCHECK(signconf::pb::serial_IsValid(value));
  _set_bit(6);
  serial_ = value;
}

// optional bool audit = 8;
inline bool Zone::has_audit() const {
  return _has_bit(7);
}
inline void Zone::clear_audit() {
  audit_ = false;
  _clear_bit(7);
}
inline bool Zone::audit() const {
  return audit_;
}
inline void Zone::set_audit(bool value) {
  _set_bit(7);
  audit_ = value;
}

// -------------------------------------------------------------------

// Signatures

// required int32 resign = 1;
inline bool Signatures::has_resign() const {
  return _has_bit(0);
}
inline void Signatures::clear_resign() {
  resign_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 Signatures::resign() const {
  return resign_;
}
inline void Signatures::set_resign(::google::protobuf::int32 value) {
  _set_bit(0);
  resign_ = value;
}

// required int32 refresh = 2;
inline bool Signatures::has_refresh() const {
  return _has_bit(1);
}
inline void Signatures::clear_refresh() {
  refresh_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 Signatures::refresh() const {
  return refresh_;
}
inline void Signatures::set_refresh(::google::protobuf::int32 value) {
  _set_bit(1);
  refresh_ = value;
}

// required int32 valdefault = 3;
inline bool Signatures::has_valdefault() const {
  return _has_bit(2);
}
inline void Signatures::clear_valdefault() {
  valdefault_ = 0;
  _clear_bit(2);
}
inline ::google::protobuf::int32 Signatures::valdefault() const {
  return valdefault_;
}
inline void Signatures::set_valdefault(::google::protobuf::int32 value) {
  _set_bit(2);
  valdefault_ = value;
}

// required int32 valdenial = 4;
inline bool Signatures::has_valdenial() const {
  return _has_bit(3);
}
inline void Signatures::clear_valdenial() {
  valdenial_ = 0;
  _clear_bit(3);
}
inline ::google::protobuf::int32 Signatures::valdenial() const {
  return valdenial_;
}
inline void Signatures::set_valdenial(::google::protobuf::int32 value) {
  _set_bit(3);
  valdenial_ = value;
}

// required int32 jitter = 5;
inline bool Signatures::has_jitter() const {
  return _has_bit(4);
}
inline void Signatures::clear_jitter() {
  jitter_ = 0;
  _clear_bit(4);
}
inline ::google::protobuf::int32 Signatures::jitter() const {
  return jitter_;
}
inline void Signatures::set_jitter(::google::protobuf::int32 value) {
  _set_bit(4);
  jitter_ = value;
}

// required int32 inceptionOffset = 6;
inline bool Signatures::has_inceptionoffset() const {
  return _has_bit(5);
}
inline void Signatures::clear_inceptionoffset() {
  inceptionoffset_ = 0;
  _clear_bit(5);
}
inline ::google::protobuf::int32 Signatures::inceptionoffset() const {
  return inceptionoffset_;
}
inline void Signatures::set_inceptionoffset(::google::protobuf::int32 value) {
  _set_bit(5);
  inceptionoffset_ = value;
}

// -------------------------------------------------------------------

// Denial

// optional .signconf.pb.NSEC nsec = 1;
inline bool Denial::has_nsec() const {
  return _has_bit(0);
}
inline void Denial::clear_nsec() {
  if (nsec_ != NULL) nsec_->::signconf::pb::NSEC::Clear();
  _clear_bit(0);
}
inline const ::signconf::pb::NSEC& Denial::nsec() const {
  return nsec_ != NULL ? *nsec_ : *default_instance_->nsec_;
}
inline ::signconf::pb::NSEC* Denial::mutable_nsec() {
  _set_bit(0);
  if (nsec_ == NULL) nsec_ = new ::signconf::pb::NSEC;
  return nsec_;
}

// optional .signconf.pb.NSEC3 nsec3 = 2;
inline bool Denial::has_nsec3() const {
  return _has_bit(1);
}
inline void Denial::clear_nsec3() {
  if (nsec3_ != NULL) nsec3_->::signconf::pb::NSEC3::Clear();
  _clear_bit(1);
}
inline const ::signconf::pb::NSEC3& Denial::nsec3() const {
  return nsec3_ != NULL ? *nsec3_ : *default_instance_->nsec3_;
}
inline ::signconf::pb::NSEC3* Denial::mutable_nsec3() {
  _set_bit(1);
  if (nsec3_ == NULL) nsec3_ = new ::signconf::pb::NSEC3;
  return nsec3_;
}

// -------------------------------------------------------------------

// NSEC

// -------------------------------------------------------------------

// NSEC3

// optional bool optout = 1;
inline bool NSEC3::has_optout() const {
  return _has_bit(0);
}
inline void NSEC3::clear_optout() {
  optout_ = false;
  _clear_bit(0);
}
inline bool NSEC3::optout() const {
  return optout_;
}
inline void NSEC3::set_optout(bool value) {
  _set_bit(0);
  optout_ = value;
}

// required int32 algorithm = 2;
inline bool NSEC3::has_algorithm() const {
  return _has_bit(1);
}
inline void NSEC3::clear_algorithm() {
  algorithm_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 NSEC3::algorithm() const {
  return algorithm_;
}
inline void NSEC3::set_algorithm(::google::protobuf::int32 value) {
  _set_bit(1);
  algorithm_ = value;
}

// required int32 iterations = 3;
inline bool NSEC3::has_iterations() const {
  return _has_bit(2);
}
inline void NSEC3::clear_iterations() {
  iterations_ = 0;
  _clear_bit(2);
}
inline ::google::protobuf::int32 NSEC3::iterations() const {
  return iterations_;
}
inline void NSEC3::set_iterations(::google::protobuf::int32 value) {
  _set_bit(2);
  iterations_ = value;
}

// required string salt = 4;
inline bool NSEC3::has_salt() const {
  return _has_bit(3);
}
inline void NSEC3::clear_salt() {
  if (salt_ != &_default_salt_) {
    salt_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& NSEC3::salt() const {
  return *salt_;
}
inline void NSEC3::set_salt(const ::std::string& value) {
  _set_bit(3);
  if (salt_ == &_default_salt_) {
    salt_ = new ::std::string;
  }
  salt_->assign(value);
}
inline void NSEC3::set_salt(const char* value) {
  _set_bit(3);
  if (salt_ == &_default_salt_) {
    salt_ = new ::std::string;
  }
  salt_->assign(value);
}
inline void NSEC3::set_salt(const char* value, size_t size) {
  _set_bit(3);
  if (salt_ == &_default_salt_) {
    salt_ = new ::std::string;
  }
  salt_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NSEC3::mutable_salt() {
  _set_bit(3);
  if (salt_ == &_default_salt_) {
    salt_ = new ::std::string;
  }
  return salt_;
}

// -------------------------------------------------------------------

// Keys

// required int32 ttl = 1;
inline bool Keys::has_ttl() const {
  return _has_bit(0);
}
inline void Keys::clear_ttl() {
  ttl_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 Keys::ttl() const {
  return ttl_;
}
inline void Keys::set_ttl(::google::protobuf::int32 value) {
  _set_bit(0);
  ttl_ = value;
}

// repeated .signconf.pb.Key keys = 2;
inline int Keys::keys_size() const {
  return keys_.size();
}
inline void Keys::clear_keys() {
  keys_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::signconf::pb::Key >&
Keys::keys() const {
  return keys_;
}
inline ::google::protobuf::RepeatedPtrField< ::signconf::pb::Key >*
Keys::mutable_keys() {
  return &keys_;
}
inline const ::signconf::pb::Key& Keys::keys(int index) const {
  return keys_.Get(index);
}
inline ::signconf::pb::Key* Keys::mutable_keys(int index) {
  return keys_.Mutable(index);
}
inline ::signconf::pb::Key* Keys::add_keys() {
  return keys_.Add();
}

// -------------------------------------------------------------------

// Key

// required uint32 flags = 1;
inline bool Key::has_flags() const {
  return _has_bit(0);
}
inline void Key::clear_flags() {
  flags_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 Key::flags() const {
  return flags_;
}
inline void Key::set_flags(::google::protobuf::uint32 value) {
  _set_bit(0);
  flags_ = value;
}

// required uint32 algorithm = 2;
inline bool Key::has_algorithm() const {
  return _has_bit(1);
}
inline void Key::clear_algorithm() {
  algorithm_ = 0u;
  _clear_bit(1);
}
inline ::google::protobuf::uint32 Key::algorithm() const {
  return algorithm_;
}
inline void Key::set_algorithm(::google::protobuf::uint32 value) {
  _set_bit(1);
  algorithm_ = value;
}

// required string locator = 3;
inline bool Key::has_locator() const {
  return _has_bit(2);
}
inline void Key::clear_locator() {
  if (locator_ != &_default_locator_) {
    locator_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& Key::locator() const {
  return *locator_;
}
inline void Key::set_locator(const ::std::string& value) {
  _set_bit(2);
  if (locator_ == &_default_locator_) {
    locator_ = new ::std::string;
  }
  locator_->assign(value);
}
inline void Key::set_locator(const char* value) {
  _set_bit(2);
  if (locator_ == &_default_locator_) {
    locator_ = new ::std::string;
  }
  locator_->assign(value);
}
inline void Key::set_locator(const char* value, size_t size) {
  _set_bit(2);
  if (locator_ == &_default_locator_) {
    locator_ = new ::std::string;
  }
  locator_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Key::mutable_locator() {
  _set_bit(2);
  if (locator_ == &_default_locator_) {
    locator_ = new ::std::string;
  }
  return locator_;
}

// optional bool ksk = 4;
inline bool Key::has_ksk() const {
  return _has_bit(3);
}
inline void Key::clear_ksk() {
  ksk_ = false;
  _clear_bit(3);
}
inline bool Key::ksk() const {
  return ksk_;
}
inline void Key::set_ksk(bool value) {
  _set_bit(3);
  ksk_ = value;
}

// optional bool zsk = 5;
inline bool Key::has_zsk() const {
  return _has_bit(4);
}
inline void Key::clear_zsk() {
  zsk_ = false;
  _clear_bit(4);
}
inline bool Key::zsk() const {
  return zsk_;
}
inline void Key::set_zsk(bool value) {
  _set_bit(4);
  zsk_ = value;
}

// optional bool publish = 6;
inline bool Key::has_publish() const {
  return _has_bit(5);
}
inline void Key::clear_publish() {
  publish_ = false;
  _clear_bit(5);
}
inline bool Key::publish() const {
  return publish_;
}
inline void Key::set_publish(bool value) {
  _set_bit(5);
  publish_ = value;
}

// optional bool deactivate = 7;
inline bool Key::has_deactivate() const {
  return _has_bit(6);
}
inline void Key::clear_deactivate() {
  deactivate_ = false;
  _clear_bit(6);
}
inline bool Key::deactivate() const {
  return deactivate_;
}
inline void Key::set_deactivate(bool value) {
  _set_bit(6);
  deactivate_ = value;
}


}  // namespace pb
}  // namespace signconf

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< signconf::pb::serial>() {
  return signconf::pb::serial_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

#endif  // PROTOBUF_signconf_2eproto__INCLUDED
