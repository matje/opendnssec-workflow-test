extern "C" {
#include "keystate/keystate_export_task.h"
#include "shared/file.h"
#include "shared/duration.h"
#include "libhsm.h"
#include "libhsmdns.h"
}

#include <google/protobuf/descriptor.h>
#include <google/protobuf/message.h>

#include "keystate/keystate.pb.h"
#include "xmlext-pb/xmlext-rd.h"


#include <fcntl.h>

static const char *module_str = "keystate_export_task";

static bool 
dnskey_from_id(std::string &dnskey,
               const char *id,
               ::ods::keystate::keyrole role,
               const char *zone,
               int algorithm,
               int bDS)
{
    hsm_key_t *key;
    hsm_sign_params_t *sign_params;
    ldns_rr *dnskey_rr;
    ldns_algorithm algo = (ldns_algorithm)algorithm;
    
    /* Code to output the DNSKEY record  (stolen from hsmutil) */
    key = hsm_find_key_by_id(NULL, id);
    
    if (!key) {
        // printf("Key %s in DB but not repository\n", id);
        return false;
    }
    
    /*TODO: find out whether sign params only need to be kept around 
     for the hsm_get_dnskey() call or whether they are then referenced 
     in the dnskey_rr generated by the  hsm_get_dnskey() call. */
    sign_params = hsm_sign_params_new();
    sign_params->owner = ldns_rdf_new_frm_str(LDNS_RDF_TYPE_DNAME, zone);
    sign_params->algorithm = algo;
    sign_params->flags = LDNS_KEY_ZONE_KEY;
    if (role == ::ods::keystate::KSK)
        sign_params->flags += LDNS_KEY_SEP_KEY; /*KSK=>SEP*/

    char *rrstr;
    /* DNSKEY record */
    dnskey_rr = hsm_get_dnskey(NULL, key, sign_params);
    /*TODO: find out what's the point of calculating the keytag here ?
     is this keytag used somehow in the ldns_key_rr2ds calls that may 
     be performed on the dnskey_rr ?
     */
    sign_params->keytag = ldns_calc_keytag(dnskey_rr);
    
    if (!bDS) {
#if 0
        ldns_rr_print(stdout, dnskey_rr);
#endif
        rrstr = ldns_rr2str(dnskey_rr);
        dnskey = rrstr;
        LDNS_FREE(rrstr);
    } else {
    
        switch (algo) {
            case LDNS_RSASHA1: // 5
            {
                /* DS record (SHA1) */
                ldns_rr *ds_sha1_rr = ldns_key_rr2ds(dnskey_rr, LDNS_SHA1);
#if 0
                ldns_rr_print(stdout, ds_sha1_rr);
#endif
                rrstr = ldns_rr2str(ds_sha1_rr);
                dnskey = rrstr;
                LDNS_FREE(rrstr);

                ldns_rr_free(ds_sha1_rr);
                break;
            }
            case LDNS_RSASHA256: // 8 - RFC 5702
            {
        
                /* DS record (SHA256) */
                ldns_rr *ds_sha256_rr = ldns_key_rr2ds(dnskey_rr, LDNS_SHA256);
#if 0
                ldns_rr_print(stdout, ds_sha256_rr);
#endif
                rrstr = ldns_rr2str(ds_sha256_rr);
                dnskey = rrstr;
                LDNS_FREE(rrstr);

                ldns_rr_free(ds_sha256_rr);
            }
            default:
                return false;
        }
    }
    hsm_sign_params_free(sign_params);
    ldns_rr_free(dnskey_rr);
    hsm_key_free(key);
    
    return true;
}

void 
perform_keystate_export(int sockfd, engineconfig_type *config, const char *zone,
                        int bds)
{
    char buf[ODS_SE_MAXLINE];
    const char *datastore = config->datastore;

	GOOGLE_PROTOBUF_VERIFY_VERSION;
    
    ::ods::keystate::KeyStateDocument *keystateDoc =
    new ::ods::keystate::KeyStateDocument;
    {
        std::string datapath(datastore);
        datapath += ".keystate.pb";
        int fd = open(datapath.c_str(),O_RDONLY);
        if (keystateDoc->ParseFromFileDescriptor(fd)) {
            ods_log_debug("[%s] keys have been loaded",
                          module_str);
        } else {
            ods_log_error("[%s] keys could not be loaded from \"%s\"",
                          module_str,datapath.c_str());
        }
        close(fd);
    }
    
    std::string zname(zone);
    for (int z=0; z<keystateDoc->zones_size(); ++z) {

        const ::ods::keystate::EnforcerZone &enfzone  = keystateDoc->zones(z);
        if (enfzone.name() != zname) 
            continue;
        
        for (int k=0; k<enfzone.keys_size(); ++k) {
            const ::ods::keystate::KeyData &key = enfzone.keys(k);
            if (key.role()== ::ods::keystate::KSK
                || key.role()== ::ods::keystate::CSK)
            {
                std::string dnskey;
                dnskey_from_id(dnskey,key.locator().c_str(),
                               key.role(),
                               enfzone.name().c_str(),
                               key.algorithm(),bds);
                ods_writen(sockfd, dnskey.c_str(), dnskey.size());
            }
        }
    }
}
