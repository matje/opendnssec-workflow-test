// Generated by the protocol buffer compiler.  DO NOT EDIT!

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "kasp.pb.h"
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>

namespace ods {
namespace kasp {

namespace {

const ::google::protobuf::Descriptor* KaspDocument_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  KaspDocument_reflection_ = NULL;
const ::google::protobuf::Descriptor* KASP_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  KASP_reflection_ = NULL;
const ::google::protobuf::Descriptor* Policy_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Policy_reflection_ = NULL;
const ::google::protobuf::Descriptor* Signatures_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Signatures_reflection_ = NULL;
const ::google::protobuf::Descriptor* Denial_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Denial_reflection_ = NULL;
const ::google::protobuf::Descriptor* NSEC_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  NSEC_reflection_ = NULL;
const ::google::protobuf::Descriptor* NSEC3_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  NSEC3_reflection_ = NULL;
const ::google::protobuf::Descriptor* Keys_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Keys_reflection_ = NULL;
const ::google::protobuf::Descriptor* Ksk_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Ksk_reflection_ = NULL;
const ::google::protobuf::Descriptor* Zsk_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Zsk_reflection_ = NULL;
const ::google::protobuf::Descriptor* Csk_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Csk_reflection_ = NULL;
const ::google::protobuf::Descriptor* Zone_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Zone_reflection_ = NULL;
const ::google::protobuf::Descriptor* Parent_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Parent_reflection_ = NULL;
const ::google::protobuf::Descriptor* Audit_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Audit_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* serial_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_kasp_2eproto() {
  protobuf_AddDesc_kasp_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "kasp.proto");
  GOOGLE_CHECK(file != NULL);
  KaspDocument_descriptor_ = file->message_type(0);
  static const int KaspDocument_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KaspDocument, kasp_),
  };
  KaspDocument_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      KaspDocument_descriptor_,
      KaspDocument::default_instance_,
      KaspDocument_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KaspDocument, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KaspDocument, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(KaspDocument));
  KASP_descriptor_ = file->message_type(1);
  static const int KASP_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KASP, policies_),
  };
  KASP_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      KASP_descriptor_,
      KASP::default_instance_,
      KASP_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KASP, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KASP, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(KASP));
  Policy_descriptor_ = file->message_type(2);
  static const int Policy_offsets_[8] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Policy, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Policy, description_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Policy, signatures_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Policy, denial_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Policy, keys_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Policy, zone_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Policy, parent_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Policy, audit_),
  };
  Policy_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Policy_descriptor_,
      Policy::default_instance_,
      Policy_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Policy, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Policy, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Policy));
  Signatures_descriptor_ = file->message_type(3);
  static const int Signatures_offsets_[7] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Signatures, resign_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Signatures, refresh_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Signatures, jitter_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Signatures, inceptionoffset_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Signatures, ttl_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Signatures, valdefault_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Signatures, valdenial_),
  };
  Signatures_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Signatures_descriptor_,
      Signatures::default_instance_,
      Signatures_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Signatures, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Signatures, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Signatures));
  Denial_descriptor_ = file->message_type(4);
  static const int Denial_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Denial, nsec_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Denial, nsec3_),
  };
  Denial_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Denial_descriptor_,
      Denial::default_instance_,
      Denial_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Denial, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Denial, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Denial));
  NSEC_descriptor_ = file->message_type(5);
  static const int NSEC_offsets_[1] = {
  };
  NSEC_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      NSEC_descriptor_,
      NSEC::default_instance_,
      NSEC_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NSEC, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NSEC, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(NSEC));
  NSEC3_descriptor_ = file->message_type(6);
  static const int NSEC3_offsets_[7] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NSEC3, optout_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NSEC3, ttl_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NSEC3, resalt_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NSEC3, algorithm_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NSEC3, iterations_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NSEC3, saltlength_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NSEC3, salt_),
  };
  NSEC3_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      NSEC3_descriptor_,
      NSEC3::default_instance_,
      NSEC3_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NSEC3, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NSEC3, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(NSEC3));
  Keys_descriptor_ = file->message_type(7);
  static const int Keys_offsets_[8] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Keys, ttl_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Keys, retiresafety_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Keys, publishsafety_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Keys, zones_share_keys_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Keys, purge_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Keys, ksk_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Keys, zsk_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Keys, csk_),
  };
  Keys_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Keys_descriptor_,
      Keys::default_instance_,
      Keys_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Keys, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Keys, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Keys));
  Ksk_descriptor_ = file->message_type(8);
  static const int Ksk_offsets_[7] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Ksk, algorithm_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Ksk, bits_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Ksk, lifetime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Ksk, repository_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Ksk, standby_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Ksk, manual_rollover_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Ksk, rfc5011_),
  };
  Ksk_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Ksk_descriptor_,
      Ksk::default_instance_,
      Ksk_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Ksk, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Ksk, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Ksk));
  Zsk_descriptor_ = file->message_type(9);
  static const int Zsk_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Zsk, algorithm_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Zsk, bits_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Zsk, lifetime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Zsk, repository_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Zsk, standby_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Zsk, manual_rollover_),
  };
  Zsk_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Zsk_descriptor_,
      Zsk::default_instance_,
      Zsk_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Zsk, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Zsk, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Zsk));
  Csk_descriptor_ = file->message_type(10);
  static const int Csk_offsets_[7] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Csk, algorithm_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Csk, bits_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Csk, lifetime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Csk, repository_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Csk, standby_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Csk, manual_rollover_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Csk, rfc5011_),
  };
  Csk_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Csk_descriptor_,
      Csk::default_instance_,
      Csk_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Csk, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Csk, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Csk));
  Zone_descriptor_ = file->message_type(11);
  static const int Zone_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Zone, propagationdelay_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Zone, ttl_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Zone, min_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Zone, serial_),
  };
  Zone_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Zone_descriptor_,
      Zone::default_instance_,
      Zone_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Zone, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Zone, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Zone));
  Parent_descriptor_ = file->message_type(12);
  static const int Parent_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Parent, ttlds_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Parent, registrationdelay_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Parent, propagationdelay_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Parent, ttl_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Parent, min_),
  };
  Parent_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Parent_descriptor_,
      Parent::default_instance_,
      Parent_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Parent, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Parent, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Parent));
  Audit_descriptor_ = file->message_type(13);
  static const int Audit_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Audit, partial_),
  };
  Audit_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Audit_descriptor_,
      Audit::default_instance_,
      Audit_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Audit, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Audit, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Audit));
  serial_descriptor_ = file->enum_type(0);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_kasp_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    KaspDocument_descriptor_, &KaspDocument::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    KASP_descriptor_, &KASP::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Policy_descriptor_, &Policy::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Signatures_descriptor_, &Signatures::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Denial_descriptor_, &Denial::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    NSEC_descriptor_, &NSEC::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    NSEC3_descriptor_, &NSEC3::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Keys_descriptor_, &Keys::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Ksk_descriptor_, &Ksk::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Zsk_descriptor_, &Zsk::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Csk_descriptor_, &Csk::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Zone_descriptor_, &Zone::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Parent_descriptor_, &Parent::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Audit_descriptor_, &Audit::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_kasp_2eproto() {
  delete KaspDocument::default_instance_;
  delete KaspDocument_reflection_;
  delete KASP::default_instance_;
  delete KASP_reflection_;
  delete Policy::default_instance_;
  delete Policy_reflection_;
  delete Signatures::default_instance_;
  delete Signatures_reflection_;
  delete Denial::default_instance_;
  delete Denial_reflection_;
  delete NSEC::default_instance_;
  delete NSEC_reflection_;
  delete NSEC3::default_instance_;
  delete NSEC3_reflection_;
  delete Keys::default_instance_;
  delete Keys_reflection_;
  delete Ksk::default_instance_;
  delete Ksk_reflection_;
  delete Zsk::default_instance_;
  delete Zsk_reflection_;
  delete Csk::default_instance_;
  delete Csk_reflection_;
  delete Zone::default_instance_;
  delete Zone_reflection_;
  delete Parent::default_instance_;
  delete Parent_reflection_;
  delete Audit::default_instance_;
  delete Audit_reflection_;
}

void protobuf_AddDesc_kasp_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::protobuf_AddDesc_xmlext_2eproto();
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\nkasp.proto\022\010ods.kasp\032\014xmlext.proto\"8\n\014"
    "KaspDocument\022(\n\004kasp\030\002 \002(\0132\016.ods.kasp.KA"
    "SPB\n\202\265\030\006\n\004KASP\"8\n\004KASP\0220\n\010policies\030\001 \003(\013"
    "2\020.ods.kasp.PolicyB\014\202\265\030\010\n\006Policy\"\350\002\n\006Pol"
    "icy\022\031\n\004name\030\001 \002(\tB\013\202\265\030\007\n\005@name\022&\n\013descri"
    "ption\030\002 \002(\tB\021\202\265\030\r\n\013Description\022:\n\nsignat"
    "ures\030\003 \002(\0132\024.ods.kasp.SignaturesB\020\202\265\030\014\n\n"
    "Signatures\022.\n\006denial\030\004 \002(\0132\020.ods.kasp.De"
    "nialB\014\202\265\030\010\n\006Denial\022(\n\004keys\030\005 \002(\0132\016.ods.k"
    "asp.KeysB\n\202\265\030\006\n\004Keys\022(\n\004zone\030\006 \002(\0132\016.ods"
    ".kasp.ZoneB\n\202\265\030\006\n\004Zone\022.\n\006parent\030\007 \002(\0132\020"
    ".ods.kasp.ParentB\014\202\265\030\010\n\006Parent\022+\n\005audit\030"
    "\010 \003(\0132\017.ods.kasp.AuditB\013\202\265\030\007\n\005Audit\"\260\002\n\n"
    "Signatures\022\"\n\006resign\030\001 \001(\005B\022\202\265\030\010\n\006Resign"
    "\202\265\030\002\020\002\022$\n\007refresh\030\002 \001(\005B\023\202\265\030\t\n\007Refresh\202\265"
    "\030\002\020\002\022\"\n\006jitter\030\003 \001(\005B\022\202\265\030\010\n\006Jitter\202\265\030\002\020\002"
    "\0224\n\017inceptionOffset\030\004 \001(\005B\033\202\265\030\021\n\017Incepti"
    "onOffset\202\265\030\002\020\002\022\034\n\003ttl\030\005 \001(\005B\017\202\265\030\005\n\003TTL\202\265"
    "\030\002\020\002\0220\n\nvaldefault\030\006 \001(\005B\034\202\265\030\022\n\020Validity"
    "/Default\202\265\030\002\020\002\022.\n\tvaldenial\030\007 \001(\005B\033\202\265\030\021\n"
    "\017Validity/Denial\202\265\030\002\020\002\"_\n\006Denial\022(\n\004nsec"
    "\030\001 \001(\0132\016.ods.kasp.NSECB\n\202\265\030\006\n\004NSEC\022+\n\005ns"
    "ec3\030\002 \001(\0132\017.ods.kasp.NSEC3B\013\202\265\030\007\n\005NSEC3\""
    "\006\n\004NSEC\"\207\002\n\005NSEC3\022\034\n\006optout\030\001 \001(\010B\014\202\265\030\010\n"
    "\006OptOut\022\034\n\003ttl\030\002 \001(\005B\017\202\265\030\005\n\003TTL\202\265\030\002\020\002\022\"\n"
    "\006resalt\030\003 \002(\005B\022\202\265\030\010\n\006Resalt\202\265\030\002\020\002\022\'\n\talg"
    "orithm\030\004 \002(\005B\024\202\265\030\020\n\016Hash/Algorithm\022)\n\nit"
    "erations\030\005 \002(\005B\025\202\265\030\021\n\017Hash/Iterations\022+\n"
    "\nsaltlength\030\006 \002(\005B\027\202\265\030\023\n\021Hash/Salt/@leng"
    "th\022\035\n\004salt\030\007 \001(\tB\017\202\265\030\013\n\tHash/Salt\"\310\002\n\004Ke"
    "ys\022\034\n\003ttl\030\001 \002(\005B\017\202\265\030\005\n\003TTL\202\265\030\002\020\002\022.\n\014reti"
    "resafety\030\002 \002(\005B\030\202\265\030\016\n\014RetireSafety\202\265\030\002\020\002"
    "\0220\n\rpublishsafety\030\003 \002(\005B\031\202\265\030\017\n\rPublishSa"
    "fety\202\265\030\002\020\002\022)\n\020zones_share_keys\030\004 \001(\010B\017\202\265"
    "\030\013\n\tShareKeys\022 \n\005purge\030\005 \001(\005B\021\202\265\030\007\n\005Purg"
    "e\202\265\030\002\020\002\022%\n\003ksk\030\006 \003(\0132\r.ods.kasp.KskB\t\202\265\030"
    "\005\n\003KSK\022%\n\003zsk\030\007 \003(\0132\r.ods.kasp.ZskB\t\202\265\030\005"
    "\n\003ZSK\022%\n\003csk\030\010 \003(\0132\r.ods.kasp.CskB\t\202\265\030\005\n"
    "\003CSK\"\223\002\n\003Ksk\022\"\n\talgorithm\030\001 \002(\rB\017\202\265\030\013\n\tA"
    "lgorithm\022%\n\004bits\030\002 \001(\rB\027\202\265\030\023\n\021Algorithm/"
    "@length\022&\n\010lifetime\030\003 \002(\005B\024\202\265\030\n\n\010Lifetim"
    "e\202\265\030\002\020\002\022*\n\nrepository\030\004 \002(\tB\026\202\265\030\014\n\nRepos"
    "itory\202\265\030\002\020\001\022\036\n\007standby\030\005 \001(\rB\r\202\265\030\t\n\007Stan"
    "dby\022-\n\017manual_rollover\030\006 \001(\010B\024\202\265\030\020\n\016Manu"
    "alRollover\022\036\n\007rfc5011\030\007 \001(\010B\r\202\265\030\t\n\007RFC50"
    "11\"\363\001\n\003Zsk\022\"\n\talgorithm\030\001 \002(\rB\017\202\265\030\013\n\tAlg"
    "orithm\022%\n\004bits\030\002 \001(\rB\027\202\265\030\023\n\021Algorithm/@l"
    "ength\022&\n\010lifetime\030\003 \002(\005B\024\202\265\030\n\n\010Lifetime\202"
    "\265\030\002\020\002\022*\n\nrepository\030\004 \002(\tB\026\202\265\030\014\n\nReposit"
    "ory\202\265\030\002\020\001\022\036\n\007standby\030\005 \001(\rB\r\202\265\030\t\n\007Standb"
    "y\022-\n\017manual_rollover\030\006 \001(\010B\024\202\265\030\020\n\016Manual"
    "Rollover\"\223\002\n\003Csk\022\"\n\talgorithm\030\001 \002(\rB\017\202\265\030"
    "\013\n\tAlgorithm\022%\n\004bits\030\002 \001(\rB\027\202\265\030\023\n\021Algori"
    "thm/@length\022&\n\010lifetime\030\003 \002(\005B\024\202\265\030\n\n\010Lif"
    "etime\202\265\030\002\020\002\022*\n\nrepository\030\004 \002(\tB\026\202\265\030\014\n\nR"
    "epository\202\265\030\002\020\001\022\036\n\007standby\030\005 \001(\rB\r\202\265\030\t\n\007"
    "Standby\022-\n\017manual_rollover\030\006 \001(\010B\024\202\265\030\020\n\016"
    "ManualRollover\022\036\n\007rfc5011\030\007 \001(\010B\r\202\265\030\t\n\007R"
    "FC5011\"\272\001\n\004Zone\0226\n\020propagationdelay\030\001 \002("
    "\005B\034\202\265\030\022\n\020PropagationDelay\202\265\030\002\020\002\022 \n\003ttl\030\002"
    " \001(\005B\023\202\265\030\t\n\007SOA/TTL\202\265\030\002\020\002\022$\n\003min\030\003 \001(\005B\027"
    "\202\265\030\r\n\013SOA/Minimum\202\265\030\002\020\002\0222\n\006serial\030\004 \001(\0162"
    "\020.ods.kasp.serialB\020\202\265\030\014\n\nSOA/Serial\"\345\001\n\006"
    "Parent\022!\n\005ttlds\030\001 \001(\005B\022\202\265\030\010\n\006DS/TTL\202\265\030\002\020"
    "\002\0228\n\021registrationdelay\030\002 \001(\005B\035\202\265\030\023\n\021Regi"
    "strationDelay\202\265\030\002\020\002\0226\n\020propagationdelay\030"
    "\003 \001(\005B\034\202\265\030\022\n\020PropagationDelay\202\265\030\002\020\002\022 \n\003t"
    "tl\030\004 \001(\005B\023\202\265\030\t\n\007SOA/TTL\202\265\030\002\020\002\022$\n\003min\030\005 \001"
    "(\005B\027\202\265\030\r\n\013SOA/Minimum\202\265\030\002\020\002\"\'\n\005Audit\022\036\n\007"
    "partial\030\001 \001(\010B\r\202\265\030\t\n\007Partial*>\n\006serial\022\013"
    "\n\007counter\020\001\022\017\n\013datecounter\020\002\022\014\n\010unixtime"
    "\020\003\022\010\n\004keep\020\004", 2852);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "kasp.proto", &protobuf_RegisterTypes);
  KaspDocument::default_instance_ = new KaspDocument();
  KASP::default_instance_ = new KASP();
  Policy::default_instance_ = new Policy();
  Signatures::default_instance_ = new Signatures();
  Denial::default_instance_ = new Denial();
  NSEC::default_instance_ = new NSEC();
  NSEC3::default_instance_ = new NSEC3();
  Keys::default_instance_ = new Keys();
  Ksk::default_instance_ = new Ksk();
  Zsk::default_instance_ = new Zsk();
  Csk::default_instance_ = new Csk();
  Zone::default_instance_ = new Zone();
  Parent::default_instance_ = new Parent();
  Audit::default_instance_ = new Audit();
  KaspDocument::default_instance_->InitAsDefaultInstance();
  KASP::default_instance_->InitAsDefaultInstance();
  Policy::default_instance_->InitAsDefaultInstance();
  Signatures::default_instance_->InitAsDefaultInstance();
  Denial::default_instance_->InitAsDefaultInstance();
  NSEC::default_instance_->InitAsDefaultInstance();
  NSEC3::default_instance_->InitAsDefaultInstance();
  Keys::default_instance_->InitAsDefaultInstance();
  Ksk::default_instance_->InitAsDefaultInstance();
  Zsk::default_instance_->InitAsDefaultInstance();
  Csk::default_instance_->InitAsDefaultInstance();
  Zone::default_instance_->InitAsDefaultInstance();
  Parent::default_instance_->InitAsDefaultInstance();
  Audit::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_kasp_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_kasp_2eproto {
  StaticDescriptorInitializer_kasp_2eproto() {
    protobuf_AddDesc_kasp_2eproto();
  }
} static_descriptor_initializer_kasp_2eproto_;

const ::google::protobuf::EnumDescriptor* serial_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return serial_descriptor_;
}
bool serial_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}


// ===================================================================

#ifndef _MSC_VER
const int KaspDocument::kKaspFieldNumber;
#endif  // !_MSC_VER

KaspDocument::KaspDocument() {
  SharedCtor();
}

void KaspDocument::InitAsDefaultInstance() {
  kasp_ = const_cast< ::ods::kasp::KASP*>(&::ods::kasp::KASP::default_instance());
}

KaspDocument::KaspDocument(const KaspDocument& from) {
  SharedCtor();
  MergeFrom(from);
}

void KaspDocument::SharedCtor() {
  _cached_size_ = 0;
  kasp_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

KaspDocument::~KaspDocument() {
  SharedDtor();
}

void KaspDocument::SharedDtor() {
  if (this != default_instance_) {
    delete kasp_;
  }
}

const ::google::protobuf::Descriptor* KaspDocument::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return KaspDocument_descriptor_;
}

const KaspDocument& KaspDocument::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_kasp_2eproto();  return *default_instance_;
}

KaspDocument* KaspDocument::default_instance_ = NULL;

KaspDocument* KaspDocument::New() const {
  return new KaspDocument;
}

void KaspDocument::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (_has_bit(0)) {
      if (kasp_ != NULL) kasp_->::ods::kasp::KASP::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool KaspDocument::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .ods.kasp.KASP kasp = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
        DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
             input, mutable_kasp()));
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void KaspDocument::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  ::google::protobuf::uint8* raw_buffer = output->GetDirectBufferForNBytesAndAdvance(_cached_size_);
  if (raw_buffer != NULL) {
    KaspDocument::SerializeWithCachedSizesToArray(raw_buffer);
    return;
  }
  
  // required .ods.kasp.KASP kasp = 2;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageNoVirtual(
      2, this->kasp(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* KaspDocument::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .ods.kasp.KASP kasp = 2;
  if (_has_bit(0)) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->kasp(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int KaspDocument::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .ods.kasp.KASP kasp = 2;
    if (has_kasp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->kasp());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  _cached_size_ = total_size;
  return total_size;
}

void KaspDocument::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const KaspDocument* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const KaspDocument*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void KaspDocument::MergeFrom(const KaspDocument& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      mutable_kasp()->::ods::kasp::KASP::MergeFrom(from.kasp());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void KaspDocument::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void KaspDocument::CopyFrom(const KaspDocument& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KaspDocument::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  if (has_kasp()) {
    if (!this->kasp().IsInitialized()) return false;
  }
  return true;
}

void KaspDocument::Swap(KaspDocument* other) {
  if (other != this) {
    std::swap(kasp_, other->kasp_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata KaspDocument::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = KaspDocument_descriptor_;
  metadata.reflection = KaspDocument_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int KASP::kPoliciesFieldNumber;
#endif  // !_MSC_VER

KASP::KASP() {
  SharedCtor();
}

void KASP::InitAsDefaultInstance() {
}

KASP::KASP(const KASP& from) {
  SharedCtor();
  MergeFrom(from);
}

void KASP::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

KASP::~KASP() {
  SharedDtor();
}

void KASP::SharedDtor() {
  if (this != default_instance_) {
  }
}

const ::google::protobuf::Descriptor* KASP::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return KASP_descriptor_;
}

const KASP& KASP::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_kasp_2eproto();  return *default_instance_;
}

KASP* KASP::default_instance_ = NULL;

KASP* KASP::New() const {
  return new KASP;
}

void KASP::Clear() {
  policies_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool KASP::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .ods.kasp.Policy policies = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_policies:
        DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
              input, add_policies()));
        if (input->ExpectTag(10)) goto parse_policies;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void KASP::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  ::google::protobuf::uint8* raw_buffer = output->GetDirectBufferForNBytesAndAdvance(_cached_size_);
  if (raw_buffer != NULL) {
    KASP::SerializeWithCachedSizesToArray(raw_buffer);
    return;
  }
  
  // repeated .ods.kasp.Policy policies = 1;
  for (int i = 0; i < this->policies_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageNoVirtual(
      1, this->policies(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* KASP::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .ods.kasp.Policy policies = 1;
  for (int i = 0; i < this->policies_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->policies(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int KASP::ByteSize() const {
  int total_size = 0;
  
  // repeated .ods.kasp.Policy policies = 1;
  total_size += 1 * this->policies_size();
  for (int i = 0; i < this->policies_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->policies(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  _cached_size_ = total_size;
  return total_size;
}

void KASP::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const KASP* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const KASP*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void KASP::MergeFrom(const KASP& from) {
  GOOGLE_CHECK_NE(&from, this);
  policies_.MergeFrom(from.policies_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void KASP::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void KASP::CopyFrom(const KASP& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KASP::IsInitialized() const {
  
  for (int i = 0; i < policies_size(); i++) {
    if (!this->policies(i).IsInitialized()) return false;
  }
  return true;
}

void KASP::Swap(KASP* other) {
  if (other != this) {
    policies_.Swap(&other->policies_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata KASP::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = KASP_descriptor_;
  metadata.reflection = KASP_reflection_;
  return metadata;
}


// ===================================================================

const ::std::string Policy::_default_name_;
const ::std::string Policy::_default_description_;
#ifndef _MSC_VER
const int Policy::kNameFieldNumber;
const int Policy::kDescriptionFieldNumber;
const int Policy::kSignaturesFieldNumber;
const int Policy::kDenialFieldNumber;
const int Policy::kKeysFieldNumber;
const int Policy::kZoneFieldNumber;
const int Policy::kParentFieldNumber;
const int Policy::kAuditFieldNumber;
#endif  // !_MSC_VER

Policy::Policy() {
  SharedCtor();
}

void Policy::InitAsDefaultInstance() {
  signatures_ = const_cast< ::ods::kasp::Signatures*>(&::ods::kasp::Signatures::default_instance());
  denial_ = const_cast< ::ods::kasp::Denial*>(&::ods::kasp::Denial::default_instance());
  keys_ = const_cast< ::ods::kasp::Keys*>(&::ods::kasp::Keys::default_instance());
  zone_ = const_cast< ::ods::kasp::Zone*>(&::ods::kasp::Zone::default_instance());
  parent_ = const_cast< ::ods::kasp::Parent*>(&::ods::kasp::Parent::default_instance());
}

Policy::Policy(const Policy& from) {
  SharedCtor();
  MergeFrom(from);
}

void Policy::SharedCtor() {
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&_default_name_);
  description_ = const_cast< ::std::string*>(&_default_description_);
  signatures_ = NULL;
  denial_ = NULL;
  keys_ = NULL;
  zone_ = NULL;
  parent_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Policy::~Policy() {
  SharedDtor();
}

void Policy::SharedDtor() {
  if (name_ != &_default_name_) {
    delete name_;
  }
  if (description_ != &_default_description_) {
    delete description_;
  }
  if (this != default_instance_) {
    delete signatures_;
    delete denial_;
    delete keys_;
    delete zone_;
    delete parent_;
  }
}

const ::google::protobuf::Descriptor* Policy::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Policy_descriptor_;
}

const Policy& Policy::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_kasp_2eproto();  return *default_instance_;
}

Policy* Policy::default_instance_ = NULL;

Policy* Policy::New() const {
  return new Policy;
}

void Policy::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (_has_bit(0)) {
      if (name_ != &_default_name_) {
        name_->clear();
      }
    }
    if (_has_bit(1)) {
      if (description_ != &_default_description_) {
        description_->clear();
      }
    }
    if (_has_bit(2)) {
      if (signatures_ != NULL) signatures_->::ods::kasp::Signatures::Clear();
    }
    if (_has_bit(3)) {
      if (denial_ != NULL) denial_->::ods::kasp::Denial::Clear();
    }
    if (_has_bit(4)) {
      if (keys_ != NULL) keys_->::ods::kasp::Keys::Clear();
    }
    if (_has_bit(5)) {
      if (zone_ != NULL) zone_->::ods::kasp::Zone::Clear();
    }
    if (_has_bit(6)) {
      if (parent_ != NULL) parent_->::ods::kasp::Parent::Clear();
    }
  }
  audit_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Policy::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
        DO_(::google::protobuf::internal::WireFormatLite::ReadString(
              input, this->mutable_name()));
        ::google::protobuf::internal::WireFormat::VerifyUTF8String(
          this->name().data(), this->name().length(),
          ::google::protobuf::internal::WireFormat::PARSE);
        if (input->ExpectTag(18)) goto parse_description;
        break;
      }
      
      // required string description = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_description:
        DO_(::google::protobuf::internal::WireFormatLite::ReadString(
              input, this->mutable_description()));
        ::google::protobuf::internal::WireFormat::VerifyUTF8String(
          this->description().data(), this->description().length(),
          ::google::protobuf::internal::WireFormat::PARSE);
        if (input->ExpectTag(26)) goto parse_signatures;
        break;
      }
      
      // required .ods.kasp.Signatures signatures = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_signatures:
        DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
             input, mutable_signatures()));
        if (input->ExpectTag(34)) goto parse_denial;
        break;
      }
      
      // required .ods.kasp.Denial denial = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_denial:
        DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
             input, mutable_denial()));
        if (input->ExpectTag(42)) goto parse_keys;
        break;
      }
      
      // required .ods.kasp.Keys keys = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_keys:
        DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
             input, mutable_keys()));
        if (input->ExpectTag(50)) goto parse_zone;
        break;
      }
      
      // required .ods.kasp.Zone zone = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_zone:
        DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
             input, mutable_zone()));
        if (input->ExpectTag(58)) goto parse_parent;
        break;
      }
      
      // required .ods.kasp.Parent parent = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_parent:
        DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
             input, mutable_parent()));
        if (input->ExpectTag(66)) goto parse_audit;
        break;
      }
      
      // repeated .ods.kasp.Audit audit = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_audit:
        DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
              input, add_audit()));
        if (input->ExpectTag(66)) goto parse_audit;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Policy::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  ::google::protobuf::uint8* raw_buffer = output->GetDirectBufferForNBytesAndAdvance(_cached_size_);
  if (raw_buffer != NULL) {
    Policy::SerializeWithCachedSizesToArray(raw_buffer);
    return;
  }
  
  // required string name = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->name(), output);
  }
  
  // required string description = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->description().data(), this->description().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->description(), output);
  }
  
  // required .ods.kasp.Signatures signatures = 3;
  if (_has_bit(2)) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageNoVirtual(
      3, this->signatures(), output);
  }
  
  // required .ods.kasp.Denial denial = 4;
  if (_has_bit(3)) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageNoVirtual(
      4, this->denial(), output);
  }
  
  // required .ods.kasp.Keys keys = 5;
  if (_has_bit(4)) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageNoVirtual(
      5, this->keys(), output);
  }
  
  // required .ods.kasp.Zone zone = 6;
  if (_has_bit(5)) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageNoVirtual(
      6, this->zone(), output);
  }
  
  // required .ods.kasp.Parent parent = 7;
  if (_has_bit(6)) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageNoVirtual(
      7, this->parent(), output);
  }
  
  // repeated .ods.kasp.Audit audit = 8;
  for (int i = 0; i < this->audit_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageNoVirtual(
      8, this->audit(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Policy::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string name = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }
  
  // required string description = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->description().data(), this->description().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->description(), target);
  }
  
  // required .ods.kasp.Signatures signatures = 3;
  if (_has_bit(2)) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->signatures(), target);
  }
  
  // required .ods.kasp.Denial denial = 4;
  if (_has_bit(3)) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->denial(), target);
  }
  
  // required .ods.kasp.Keys keys = 5;
  if (_has_bit(4)) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->keys(), target);
  }
  
  // required .ods.kasp.Zone zone = 6;
  if (_has_bit(5)) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        6, this->zone(), target);
  }
  
  // required .ods.kasp.Parent parent = 7;
  if (_has_bit(6)) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        7, this->parent(), target);
  }
  
  // repeated .ods.kasp.Audit audit = 8;
  for (int i = 0; i < this->audit_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        8, this->audit(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Policy::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }
    
    // required string description = 2;
    if (has_description()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->description());
    }
    
    // required .ods.kasp.Signatures signatures = 3;
    if (has_signatures()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->signatures());
    }
    
    // required .ods.kasp.Denial denial = 4;
    if (has_denial()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->denial());
    }
    
    // required .ods.kasp.Keys keys = 5;
    if (has_keys()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->keys());
    }
    
    // required .ods.kasp.Zone zone = 6;
    if (has_zone()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->zone());
    }
    
    // required .ods.kasp.Parent parent = 7;
    if (has_parent()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->parent());
    }
    
  }
  // repeated .ods.kasp.Audit audit = 8;
  total_size += 1 * this->audit_size();
  for (int i = 0; i < this->audit_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->audit(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  _cached_size_ = total_size;
  return total_size;
}

void Policy::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Policy* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Policy*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Policy::MergeFrom(const Policy& from) {
  GOOGLE_CHECK_NE(&from, this);
  audit_.MergeFrom(from.audit_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_name(from.name());
    }
    if (from._has_bit(1)) {
      set_description(from.description());
    }
    if (from._has_bit(2)) {
      mutable_signatures()->::ods::kasp::Signatures::MergeFrom(from.signatures());
    }
    if (from._has_bit(3)) {
      mutable_denial()->::ods::kasp::Denial::MergeFrom(from.denial());
    }
    if (from._has_bit(4)) {
      mutable_keys()->::ods::kasp::Keys::MergeFrom(from.keys());
    }
    if (from._has_bit(5)) {
      mutable_zone()->::ods::kasp::Zone::MergeFrom(from.zone());
    }
    if (from._has_bit(6)) {
      mutable_parent()->::ods::kasp::Parent::MergeFrom(from.parent());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Policy::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Policy::CopyFrom(const Policy& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Policy::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000007f) != 0x0000007f) return false;
  
  if (has_denial()) {
    if (!this->denial().IsInitialized()) return false;
  }
  if (has_keys()) {
    if (!this->keys().IsInitialized()) return false;
  }
  if (has_zone()) {
    if (!this->zone().IsInitialized()) return false;
  }
  return true;
}

void Policy::Swap(Policy* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    std::swap(description_, other->description_);
    std::swap(signatures_, other->signatures_);
    std::swap(denial_, other->denial_);
    std::swap(keys_, other->keys_);
    std::swap(zone_, other->zone_);
    std::swap(parent_, other->parent_);
    audit_.Swap(&other->audit_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Policy::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Policy_descriptor_;
  metadata.reflection = Policy_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Signatures::kResignFieldNumber;
const int Signatures::kRefreshFieldNumber;
const int Signatures::kJitterFieldNumber;
const int Signatures::kInceptionOffsetFieldNumber;
const int Signatures::kTtlFieldNumber;
const int Signatures::kValdefaultFieldNumber;
const int Signatures::kValdenialFieldNumber;
#endif  // !_MSC_VER

Signatures::Signatures() {
  SharedCtor();
}

void Signatures::InitAsDefaultInstance() {
}

Signatures::Signatures(const Signatures& from) {
  SharedCtor();
  MergeFrom(from);
}

void Signatures::SharedCtor() {
  _cached_size_ = 0;
  resign_ = 0;
  refresh_ = 0;
  jitter_ = 0;
  inceptionoffset_ = 0;
  ttl_ = 0;
  valdefault_ = 0;
  valdenial_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Signatures::~Signatures() {
  SharedDtor();
}

void Signatures::SharedDtor() {
  if (this != default_instance_) {
  }
}

const ::google::protobuf::Descriptor* Signatures::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Signatures_descriptor_;
}

const Signatures& Signatures::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_kasp_2eproto();  return *default_instance_;
}

Signatures* Signatures::default_instance_ = NULL;

Signatures* Signatures::New() const {
  return new Signatures;
}

void Signatures::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    resign_ = 0;
    refresh_ = 0;
    jitter_ = 0;
    inceptionoffset_ = 0;
    ttl_ = 0;
    valdefault_ = 0;
    valdenial_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Signatures::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 resign = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
        DO_(::google::protobuf::internal::WireFormatLite::ReadInt32(
              input, &resign_));
        _set_bit(0);
        if (input->ExpectTag(16)) goto parse_refresh;
        break;
      }
      
      // optional int32 refresh = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
       parse_refresh:
        DO_(::google::protobuf::internal::WireFormatLite::ReadInt32(
              input, &refresh_));
        _set_bit(1);
        if (input->ExpectTag(24)) goto parse_jitter;
        break;
      }
      
      // optional int32 jitter = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
       parse_jitter:
        DO_(::google::protobuf::internal::WireFormatLite::ReadInt32(
              input, &jitter_));
        _set_bit(2);
        if (input->ExpectTag(32)) goto parse_inceptionOffset;
        break;
      }
      
      // optional int32 inceptionOffset = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
       parse_inceptionOffset:
        DO_(::google::protobuf::internal::WireFormatLite::ReadInt32(
              input, &inceptionoffset_));
        _set_bit(3);
        if (input->ExpectTag(40)) goto parse_ttl;
        break;
      }
      
      // optional int32 ttl = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
       parse_ttl:
        DO_(::google::protobuf::internal::WireFormatLite::ReadInt32(
              input, &ttl_));
        _set_bit(4);
        if (input->ExpectTag(48)) goto parse_valdefault;
        break;
      }
      
      // optional int32 valdefault = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
       parse_valdefault:
        DO_(::google::protobuf::internal::WireFormatLite::ReadInt32(
              input, &valdefault_));
        _set_bit(5);
        if (input->ExpectTag(56)) goto parse_valdenial;
        break;
      }
      
      // optional int32 valdenial = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
       parse_valdenial:
        DO_(::google::protobuf::internal::WireFormatLite::ReadInt32(
              input, &valdenial_));
        _set_bit(6);
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Signatures::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  ::google::protobuf::uint8* raw_buffer = output->GetDirectBufferForNBytesAndAdvance(_cached_size_);
  if (raw_buffer != NULL) {
    Signatures::SerializeWithCachedSizesToArray(raw_buffer);
    return;
  }
  
  // optional int32 resign = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->resign(), output);
  }
  
  // optional int32 refresh = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->refresh(), output);
  }
  
  // optional int32 jitter = 3;
  if (_has_bit(2)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->jitter(), output);
  }
  
  // optional int32 inceptionOffset = 4;
  if (_has_bit(3)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->inceptionoffset(), output);
  }
  
  // optional int32 ttl = 5;
  if (_has_bit(4)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->ttl(), output);
  }
  
  // optional int32 valdefault = 6;
  if (_has_bit(5)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->valdefault(), output);
  }
  
  // optional int32 valdenial = 7;
  if (_has_bit(6)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(7, this->valdenial(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Signatures::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional int32 resign = 1;
  if (_has_bit(0)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->resign(), target);
  }
  
  // optional int32 refresh = 2;
  if (_has_bit(1)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->refresh(), target);
  }
  
  // optional int32 jitter = 3;
  if (_has_bit(2)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->jitter(), target);
  }
  
  // optional int32 inceptionOffset = 4;
  if (_has_bit(3)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->inceptionoffset(), target);
  }
  
  // optional int32 ttl = 5;
  if (_has_bit(4)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->ttl(), target);
  }
  
  // optional int32 valdefault = 6;
  if (_has_bit(5)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(6, this->valdefault(), target);
  }
  
  // optional int32 valdenial = 7;
  if (_has_bit(6)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(7, this->valdenial(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Signatures::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 resign = 1;
    if (has_resign()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->resign());
    }
    
    // optional int32 refresh = 2;
    if (has_refresh()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->refresh());
    }
    
    // optional int32 jitter = 3;
    if (has_jitter()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->jitter());
    }
    
    // optional int32 inceptionOffset = 4;
    if (has_inceptionoffset()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->inceptionoffset());
    }
    
    // optional int32 ttl = 5;
    if (has_ttl()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->ttl());
    }
    
    // optional int32 valdefault = 6;
    if (has_valdefault()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->valdefault());
    }
    
    // optional int32 valdenial = 7;
    if (has_valdenial()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->valdenial());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  _cached_size_ = total_size;
  return total_size;
}

void Signatures::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Signatures* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Signatures*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Signatures::MergeFrom(const Signatures& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_resign(from.resign());
    }
    if (from._has_bit(1)) {
      set_refresh(from.refresh());
    }
    if (from._has_bit(2)) {
      set_jitter(from.jitter());
    }
    if (from._has_bit(3)) {
      set_inceptionoffset(from.inceptionoffset());
    }
    if (from._has_bit(4)) {
      set_ttl(from.ttl());
    }
    if (from._has_bit(5)) {
      set_valdefault(from.valdefault());
    }
    if (from._has_bit(6)) {
      set_valdenial(from.valdenial());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Signatures::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Signatures::CopyFrom(const Signatures& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Signatures::IsInitialized() const {
  
  return true;
}

void Signatures::Swap(Signatures* other) {
  if (other != this) {
    std::swap(resign_, other->resign_);
    std::swap(refresh_, other->refresh_);
    std::swap(jitter_, other->jitter_);
    std::swap(inceptionoffset_, other->inceptionoffset_);
    std::swap(ttl_, other->ttl_);
    std::swap(valdefault_, other->valdefault_);
    std::swap(valdenial_, other->valdenial_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Signatures::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Signatures_descriptor_;
  metadata.reflection = Signatures_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Denial::kNsecFieldNumber;
const int Denial::kNsec3FieldNumber;
#endif  // !_MSC_VER

Denial::Denial() {
  SharedCtor();
}

void Denial::InitAsDefaultInstance() {
  nsec_ = const_cast< ::ods::kasp::NSEC*>(&::ods::kasp::NSEC::default_instance());
  nsec3_ = const_cast< ::ods::kasp::NSEC3*>(&::ods::kasp::NSEC3::default_instance());
}

Denial::Denial(const Denial& from) {
  SharedCtor();
  MergeFrom(from);
}

void Denial::SharedCtor() {
  _cached_size_ = 0;
  nsec_ = NULL;
  nsec3_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Denial::~Denial() {
  SharedDtor();
}

void Denial::SharedDtor() {
  if (this != default_instance_) {
    delete nsec_;
    delete nsec3_;
  }
}

const ::google::protobuf::Descriptor* Denial::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Denial_descriptor_;
}

const Denial& Denial::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_kasp_2eproto();  return *default_instance_;
}

Denial* Denial::default_instance_ = NULL;

Denial* Denial::New() const {
  return new Denial;
}

void Denial::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (_has_bit(0)) {
      if (nsec_ != NULL) nsec_->::ods::kasp::NSEC::Clear();
    }
    if (_has_bit(1)) {
      if (nsec3_ != NULL) nsec3_->::ods::kasp::NSEC3::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Denial::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .ods.kasp.NSEC nsec = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
        DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
             input, mutable_nsec()));
        if (input->ExpectTag(18)) goto parse_nsec3;
        break;
      }
      
      // optional .ods.kasp.NSEC3 nsec3 = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_nsec3:
        DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
             input, mutable_nsec3()));
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Denial::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  ::google::protobuf::uint8* raw_buffer = output->GetDirectBufferForNBytesAndAdvance(_cached_size_);
  if (raw_buffer != NULL) {
    Denial::SerializeWithCachedSizesToArray(raw_buffer);
    return;
  }
  
  // optional .ods.kasp.NSEC nsec = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageNoVirtual(
      1, this->nsec(), output);
  }
  
  // optional .ods.kasp.NSEC3 nsec3 = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageNoVirtual(
      2, this->nsec3(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Denial::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional .ods.kasp.NSEC nsec = 1;
  if (_has_bit(0)) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->nsec(), target);
  }
  
  // optional .ods.kasp.NSEC3 nsec3 = 2;
  if (_has_bit(1)) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->nsec3(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Denial::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .ods.kasp.NSEC nsec = 1;
    if (has_nsec()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->nsec());
    }
    
    // optional .ods.kasp.NSEC3 nsec3 = 2;
    if (has_nsec3()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->nsec3());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  _cached_size_ = total_size;
  return total_size;
}

void Denial::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Denial* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Denial*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Denial::MergeFrom(const Denial& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      mutable_nsec()->::ods::kasp::NSEC::MergeFrom(from.nsec());
    }
    if (from._has_bit(1)) {
      mutable_nsec3()->::ods::kasp::NSEC3::MergeFrom(from.nsec3());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Denial::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Denial::CopyFrom(const Denial& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Denial::IsInitialized() const {
  
  if (has_nsec3()) {
    if (!this->nsec3().IsInitialized()) return false;
  }
  return true;
}

void Denial::Swap(Denial* other) {
  if (other != this) {
    std::swap(nsec_, other->nsec_);
    std::swap(nsec3_, other->nsec3_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Denial::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Denial_descriptor_;
  metadata.reflection = Denial_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

NSEC::NSEC() {
  SharedCtor();
}

void NSEC::InitAsDefaultInstance() {
}

NSEC::NSEC(const NSEC& from) {
  SharedCtor();
  MergeFrom(from);
}

void NSEC::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NSEC::~NSEC() {
  SharedDtor();
}

void NSEC::SharedDtor() {
  if (this != default_instance_) {
  }
}

const ::google::protobuf::Descriptor* NSEC::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return NSEC_descriptor_;
}

const NSEC& NSEC::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_kasp_2eproto();  return *default_instance_;
}

NSEC* NSEC::default_instance_ = NULL;

NSEC* NSEC::New() const {
  return new NSEC;
}

void NSEC::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool NSEC::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      return true;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, mutable_unknown_fields()));
  }
  return true;
#undef DO_
}

void NSEC::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  ::google::protobuf::uint8* raw_buffer = output->GetDirectBufferForNBytesAndAdvance(_cached_size_);
  if (raw_buffer != NULL) {
    NSEC::SerializeWithCachedSizesToArray(raw_buffer);
    return;
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* NSEC::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int NSEC::ByteSize() const {
  int total_size = 0;
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  _cached_size_ = total_size;
  return total_size;
}

void NSEC::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const NSEC* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const NSEC*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void NSEC::MergeFrom(const NSEC& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void NSEC::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void NSEC::CopyFrom(const NSEC& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NSEC::IsInitialized() const {
  
  return true;
}

void NSEC::Swap(NSEC* other) {
  if (other != this) {
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata NSEC::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = NSEC_descriptor_;
  metadata.reflection = NSEC_reflection_;
  return metadata;
}


// ===================================================================

const ::std::string NSEC3::_default_salt_;
#ifndef _MSC_VER
const int NSEC3::kOptoutFieldNumber;
const int NSEC3::kTtlFieldNumber;
const int NSEC3::kResaltFieldNumber;
const int NSEC3::kAlgorithmFieldNumber;
const int NSEC3::kIterationsFieldNumber;
const int NSEC3::kSaltlengthFieldNumber;
const int NSEC3::kSaltFieldNumber;
#endif  // !_MSC_VER

NSEC3::NSEC3() {
  SharedCtor();
}

void NSEC3::InitAsDefaultInstance() {
}

NSEC3::NSEC3(const NSEC3& from) {
  SharedCtor();
  MergeFrom(from);
}

void NSEC3::SharedCtor() {
  _cached_size_ = 0;
  optout_ = false;
  ttl_ = 0;
  resalt_ = 0;
  algorithm_ = 0;
  iterations_ = 0;
  saltlength_ = 0;
  salt_ = const_cast< ::std::string*>(&_default_salt_);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NSEC3::~NSEC3() {
  SharedDtor();
}

void NSEC3::SharedDtor() {
  if (salt_ != &_default_salt_) {
    delete salt_;
  }
  if (this != default_instance_) {
  }
}

const ::google::protobuf::Descriptor* NSEC3::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return NSEC3_descriptor_;
}

const NSEC3& NSEC3::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_kasp_2eproto();  return *default_instance_;
}

NSEC3* NSEC3::default_instance_ = NULL;

NSEC3* NSEC3::New() const {
  return new NSEC3;
}

void NSEC3::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    optout_ = false;
    ttl_ = 0;
    resalt_ = 0;
    algorithm_ = 0;
    iterations_ = 0;
    saltlength_ = 0;
    if (_has_bit(6)) {
      if (salt_ != &_default_salt_) {
        salt_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool NSEC3::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bool optout = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
        DO_(::google::protobuf::internal::WireFormatLite::ReadBool(
              input, &optout_));
        _set_bit(0);
        if (input->ExpectTag(16)) goto parse_ttl;
        break;
      }
      
      // optional int32 ttl = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
       parse_ttl:
        DO_(::google::protobuf::internal::WireFormatLite::ReadInt32(
              input, &ttl_));
        _set_bit(1);
        if (input->ExpectTag(24)) goto parse_resalt;
        break;
      }
      
      // required int32 resalt = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
       parse_resalt:
        DO_(::google::protobuf::internal::WireFormatLite::ReadInt32(
              input, &resalt_));
        _set_bit(2);
        if (input->ExpectTag(32)) goto parse_algorithm;
        break;
      }
      
      // required int32 algorithm = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
       parse_algorithm:
        DO_(::google::protobuf::internal::WireFormatLite::ReadInt32(
              input, &algorithm_));
        _set_bit(3);
        if (input->ExpectTag(40)) goto parse_iterations;
        break;
      }
      
      // required int32 iterations = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
       parse_iterations:
        DO_(::google::protobuf::internal::WireFormatLite::ReadInt32(
              input, &iterations_));
        _set_bit(4);
        if (input->ExpectTag(48)) goto parse_saltlength;
        break;
      }
      
      // required int32 saltlength = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
       parse_saltlength:
        DO_(::google::protobuf::internal::WireFormatLite::ReadInt32(
              input, &saltlength_));
        _set_bit(5);
        if (input->ExpectTag(58)) goto parse_salt;
        break;
      }
      
      // optional string salt = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_salt:
        DO_(::google::protobuf::internal::WireFormatLite::ReadString(
              input, this->mutable_salt()));
        ::google::protobuf::internal::WireFormat::VerifyUTF8String(
          this->salt().data(), this->salt().length(),
          ::google::protobuf::internal::WireFormat::PARSE);
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void NSEC3::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  ::google::protobuf::uint8* raw_buffer = output->GetDirectBufferForNBytesAndAdvance(_cached_size_);
  if (raw_buffer != NULL) {
    NSEC3::SerializeWithCachedSizesToArray(raw_buffer);
    return;
  }
  
  // optional bool optout = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->optout(), output);
  }
  
  // optional int32 ttl = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->ttl(), output);
  }
  
  // required int32 resalt = 3;
  if (_has_bit(2)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->resalt(), output);
  }
  
  // required int32 algorithm = 4;
  if (_has_bit(3)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->algorithm(), output);
  }
  
  // required int32 iterations = 5;
  if (_has_bit(4)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->iterations(), output);
  }
  
  // required int32 saltlength = 6;
  if (_has_bit(5)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->saltlength(), output);
  }
  
  // optional string salt = 7;
  if (_has_bit(6)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->salt().data(), this->salt().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      7, this->salt(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* NSEC3::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional bool optout = 1;
  if (_has_bit(0)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(1, this->optout(), target);
  }
  
  // optional int32 ttl = 2;
  if (_has_bit(1)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->ttl(), target);
  }
  
  // required int32 resalt = 3;
  if (_has_bit(2)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->resalt(), target);
  }
  
  // required int32 algorithm = 4;
  if (_has_bit(3)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->algorithm(), target);
  }
  
  // required int32 iterations = 5;
  if (_has_bit(4)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->iterations(), target);
  }
  
  // required int32 saltlength = 6;
  if (_has_bit(5)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(6, this->saltlength(), target);
  }
  
  // optional string salt = 7;
  if (_has_bit(6)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->salt().data(), this->salt().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        7, this->salt(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int NSEC3::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bool optout = 1;
    if (has_optout()) {
      total_size += 1 + 1;
    }
    
    // optional int32 ttl = 2;
    if (has_ttl()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->ttl());
    }
    
    // required int32 resalt = 3;
    if (has_resalt()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->resalt());
    }
    
    // required int32 algorithm = 4;
    if (has_algorithm()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->algorithm());
    }
    
    // required int32 iterations = 5;
    if (has_iterations()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->iterations());
    }
    
    // required int32 saltlength = 6;
    if (has_saltlength()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->saltlength());
    }
    
    // optional string salt = 7;
    if (has_salt()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->salt());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  _cached_size_ = total_size;
  return total_size;
}

void NSEC3::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const NSEC3* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const NSEC3*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void NSEC3::MergeFrom(const NSEC3& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_optout(from.optout());
    }
    if (from._has_bit(1)) {
      set_ttl(from.ttl());
    }
    if (from._has_bit(2)) {
      set_resalt(from.resalt());
    }
    if (from._has_bit(3)) {
      set_algorithm(from.algorithm());
    }
    if (from._has_bit(4)) {
      set_iterations(from.iterations());
    }
    if (from._has_bit(5)) {
      set_saltlength(from.saltlength());
    }
    if (from._has_bit(6)) {
      set_salt(from.salt());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void NSEC3::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void NSEC3::CopyFrom(const NSEC3& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NSEC3::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000003c) != 0x0000003c) return false;
  
  return true;
}

void NSEC3::Swap(NSEC3* other) {
  if (other != this) {
    std::swap(optout_, other->optout_);
    std::swap(ttl_, other->ttl_);
    std::swap(resalt_, other->resalt_);
    std::swap(algorithm_, other->algorithm_);
    std::swap(iterations_, other->iterations_);
    std::swap(saltlength_, other->saltlength_);
    std::swap(salt_, other->salt_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata NSEC3::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = NSEC3_descriptor_;
  metadata.reflection = NSEC3_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Keys::kTtlFieldNumber;
const int Keys::kRetiresafetyFieldNumber;
const int Keys::kPublishsafetyFieldNumber;
const int Keys::kZonesShareKeysFieldNumber;
const int Keys::kPurgeFieldNumber;
const int Keys::kKskFieldNumber;
const int Keys::kZskFieldNumber;
const int Keys::kCskFieldNumber;
#endif  // !_MSC_VER

Keys::Keys() {
  SharedCtor();
}

void Keys::InitAsDefaultInstance() {
}

Keys::Keys(const Keys& from) {
  SharedCtor();
  MergeFrom(from);
}

void Keys::SharedCtor() {
  _cached_size_ = 0;
  ttl_ = 0;
  retiresafety_ = 0;
  publishsafety_ = 0;
  zones_share_keys_ = false;
  purge_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Keys::~Keys() {
  SharedDtor();
}

void Keys::SharedDtor() {
  if (this != default_instance_) {
  }
}

const ::google::protobuf::Descriptor* Keys::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Keys_descriptor_;
}

const Keys& Keys::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_kasp_2eproto();  return *default_instance_;
}

Keys* Keys::default_instance_ = NULL;

Keys* Keys::New() const {
  return new Keys;
}

void Keys::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    ttl_ = 0;
    retiresafety_ = 0;
    publishsafety_ = 0;
    zones_share_keys_ = false;
    purge_ = 0;
  }
  ksk_.Clear();
  zsk_.Clear();
  csk_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Keys::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 ttl = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
        DO_(::google::protobuf::internal::WireFormatLite::ReadInt32(
              input, &ttl_));
        _set_bit(0);
        if (input->ExpectTag(16)) goto parse_retiresafety;
        break;
      }
      
      // required int32 retiresafety = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
       parse_retiresafety:
        DO_(::google::protobuf::internal::WireFormatLite::ReadInt32(
              input, &retiresafety_));
        _set_bit(1);
        if (input->ExpectTag(24)) goto parse_publishsafety;
        break;
      }
      
      // required int32 publishsafety = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
       parse_publishsafety:
        DO_(::google::protobuf::internal::WireFormatLite::ReadInt32(
              input, &publishsafety_));
        _set_bit(2);
        if (input->ExpectTag(32)) goto parse_zones_share_keys;
        break;
      }
      
      // optional bool zones_share_keys = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
       parse_zones_share_keys:
        DO_(::google::protobuf::internal::WireFormatLite::ReadBool(
              input, &zones_share_keys_));
        _set_bit(3);
        if (input->ExpectTag(40)) goto parse_purge;
        break;
      }
      
      // optional int32 purge = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
       parse_purge:
        DO_(::google::protobuf::internal::WireFormatLite::ReadInt32(
              input, &purge_));
        _set_bit(4);
        if (input->ExpectTag(50)) goto parse_ksk;
        break;
      }
      
      // repeated .ods.kasp.Ksk ksk = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_ksk:
        DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
              input, add_ksk()));
        if (input->ExpectTag(50)) goto parse_ksk;
        if (input->ExpectTag(58)) goto parse_zsk;
        break;
      }
      
      // repeated .ods.kasp.Zsk zsk = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_zsk:
        DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
              input, add_zsk()));
        if (input->ExpectTag(58)) goto parse_zsk;
        if (input->ExpectTag(66)) goto parse_csk;
        break;
      }
      
      // repeated .ods.kasp.Csk csk = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_csk:
        DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
              input, add_csk()));
        if (input->ExpectTag(66)) goto parse_csk;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Keys::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  ::google::protobuf::uint8* raw_buffer = output->GetDirectBufferForNBytesAndAdvance(_cached_size_);
  if (raw_buffer != NULL) {
    Keys::SerializeWithCachedSizesToArray(raw_buffer);
    return;
  }
  
  // required int32 ttl = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->ttl(), output);
  }
  
  // required int32 retiresafety = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->retiresafety(), output);
  }
  
  // required int32 publishsafety = 3;
  if (_has_bit(2)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->publishsafety(), output);
  }
  
  // optional bool zones_share_keys = 4;
  if (_has_bit(3)) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->zones_share_keys(), output);
  }
  
  // optional int32 purge = 5;
  if (_has_bit(4)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->purge(), output);
  }
  
  // repeated .ods.kasp.Ksk ksk = 6;
  for (int i = 0; i < this->ksk_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageNoVirtual(
      6, this->ksk(i), output);
  }
  
  // repeated .ods.kasp.Zsk zsk = 7;
  for (int i = 0; i < this->zsk_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageNoVirtual(
      7, this->zsk(i), output);
  }
  
  // repeated .ods.kasp.Csk csk = 8;
  for (int i = 0; i < this->csk_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageNoVirtual(
      8, this->csk(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Keys::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 ttl = 1;
  if (_has_bit(0)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->ttl(), target);
  }
  
  // required int32 retiresafety = 2;
  if (_has_bit(1)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->retiresafety(), target);
  }
  
  // required int32 publishsafety = 3;
  if (_has_bit(2)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->publishsafety(), target);
  }
  
  // optional bool zones_share_keys = 4;
  if (_has_bit(3)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(4, this->zones_share_keys(), target);
  }
  
  // optional int32 purge = 5;
  if (_has_bit(4)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->purge(), target);
  }
  
  // repeated .ods.kasp.Ksk ksk = 6;
  for (int i = 0; i < this->ksk_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        6, this->ksk(i), target);
  }
  
  // repeated .ods.kasp.Zsk zsk = 7;
  for (int i = 0; i < this->zsk_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        7, this->zsk(i), target);
  }
  
  // repeated .ods.kasp.Csk csk = 8;
  for (int i = 0; i < this->csk_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        8, this->csk(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Keys::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 ttl = 1;
    if (has_ttl()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->ttl());
    }
    
    // required int32 retiresafety = 2;
    if (has_retiresafety()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->retiresafety());
    }
    
    // required int32 publishsafety = 3;
    if (has_publishsafety()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->publishsafety());
    }
    
    // optional bool zones_share_keys = 4;
    if (has_zones_share_keys()) {
      total_size += 1 + 1;
    }
    
    // optional int32 purge = 5;
    if (has_purge()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->purge());
    }
    
  }
  // repeated .ods.kasp.Ksk ksk = 6;
  total_size += 1 * this->ksk_size();
  for (int i = 0; i < this->ksk_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->ksk(i));
  }
  
  // repeated .ods.kasp.Zsk zsk = 7;
  total_size += 1 * this->zsk_size();
  for (int i = 0; i < this->zsk_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->zsk(i));
  }
  
  // repeated .ods.kasp.Csk csk = 8;
  total_size += 1 * this->csk_size();
  for (int i = 0; i < this->csk_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->csk(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  _cached_size_ = total_size;
  return total_size;
}

void Keys::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Keys* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Keys*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Keys::MergeFrom(const Keys& from) {
  GOOGLE_CHECK_NE(&from, this);
  ksk_.MergeFrom(from.ksk_);
  zsk_.MergeFrom(from.zsk_);
  csk_.MergeFrom(from.csk_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_ttl(from.ttl());
    }
    if (from._has_bit(1)) {
      set_retiresafety(from.retiresafety());
    }
    if (from._has_bit(2)) {
      set_publishsafety(from.publishsafety());
    }
    if (from._has_bit(3)) {
      set_zones_share_keys(from.zones_share_keys());
    }
    if (from._has_bit(4)) {
      set_purge(from.purge());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Keys::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Keys::CopyFrom(const Keys& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Keys::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;
  
  for (int i = 0; i < ksk_size(); i++) {
    if (!this->ksk(i).IsInitialized()) return false;
  }
  for (int i = 0; i < zsk_size(); i++) {
    if (!this->zsk(i).IsInitialized()) return false;
  }
  for (int i = 0; i < csk_size(); i++) {
    if (!this->csk(i).IsInitialized()) return false;
  }
  return true;
}

void Keys::Swap(Keys* other) {
  if (other != this) {
    std::swap(ttl_, other->ttl_);
    std::swap(retiresafety_, other->retiresafety_);
    std::swap(publishsafety_, other->publishsafety_);
    std::swap(zones_share_keys_, other->zones_share_keys_);
    std::swap(purge_, other->purge_);
    ksk_.Swap(&other->ksk_);
    zsk_.Swap(&other->zsk_);
    csk_.Swap(&other->csk_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Keys::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Keys_descriptor_;
  metadata.reflection = Keys_reflection_;
  return metadata;
}


// ===================================================================

const ::std::string Ksk::_default_repository_;
#ifndef _MSC_VER
const int Ksk::kAlgorithmFieldNumber;
const int Ksk::kBitsFieldNumber;
const int Ksk::kLifetimeFieldNumber;
const int Ksk::kRepositoryFieldNumber;
const int Ksk::kStandbyFieldNumber;
const int Ksk::kManualRolloverFieldNumber;
const int Ksk::kRfc5011FieldNumber;
#endif  // !_MSC_VER

Ksk::Ksk() {
  SharedCtor();
}

void Ksk::InitAsDefaultInstance() {
}

Ksk::Ksk(const Ksk& from) {
  SharedCtor();
  MergeFrom(from);
}

void Ksk::SharedCtor() {
  _cached_size_ = 0;
  algorithm_ = 0u;
  bits_ = 0u;
  lifetime_ = 0;
  repository_ = const_cast< ::std::string*>(&_default_repository_);
  standby_ = 0u;
  manual_rollover_ = false;
  rfc5011_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Ksk::~Ksk() {
  SharedDtor();
}

void Ksk::SharedDtor() {
  if (repository_ != &_default_repository_) {
    delete repository_;
  }
  if (this != default_instance_) {
  }
}

const ::google::protobuf::Descriptor* Ksk::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Ksk_descriptor_;
}

const Ksk& Ksk::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_kasp_2eproto();  return *default_instance_;
}

Ksk* Ksk::default_instance_ = NULL;

Ksk* Ksk::New() const {
  return new Ksk;
}

void Ksk::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    algorithm_ = 0u;
    bits_ = 0u;
    lifetime_ = 0;
    if (_has_bit(3)) {
      if (repository_ != &_default_repository_) {
        repository_->clear();
      }
    }
    standby_ = 0u;
    manual_rollover_ = false;
    rfc5011_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Ksk::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 algorithm = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
        DO_(::google::protobuf::internal::WireFormatLite::ReadUInt32(
              input, &algorithm_));
        _set_bit(0);
        if (input->ExpectTag(16)) goto parse_bits;
        break;
      }
      
      // optional uint32 bits = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
       parse_bits:
        DO_(::google::protobuf::internal::WireFormatLite::ReadUInt32(
              input, &bits_));
        _set_bit(1);
        if (input->ExpectTag(24)) goto parse_lifetime;
        break;
      }
      
      // required int32 lifetime = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
       parse_lifetime:
        DO_(::google::protobuf::internal::WireFormatLite::ReadInt32(
              input, &lifetime_));
        _set_bit(2);
        if (input->ExpectTag(34)) goto parse_repository;
        break;
      }
      
      // required string repository = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_repository:
        DO_(::google::protobuf::internal::WireFormatLite::ReadString(
              input, this->mutable_repository()));
        ::google::protobuf::internal::WireFormat::VerifyUTF8String(
          this->repository().data(), this->repository().length(),
          ::google::protobuf::internal::WireFormat::PARSE);
        if (input->ExpectTag(40)) goto parse_standby;
        break;
      }
      
      // optional uint32 standby = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
       parse_standby:
        DO_(::google::protobuf::internal::WireFormatLite::ReadUInt32(
              input, &standby_));
        _set_bit(4);
        if (input->ExpectTag(48)) goto parse_manual_rollover;
        break;
      }
      
      // optional bool manual_rollover = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
       parse_manual_rollover:
        DO_(::google::protobuf::internal::WireFormatLite::ReadBool(
              input, &manual_rollover_));
        _set_bit(5);
        if (input->ExpectTag(56)) goto parse_rfc5011;
        break;
      }
      
      // optional bool rfc5011 = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
       parse_rfc5011:
        DO_(::google::protobuf::internal::WireFormatLite::ReadBool(
              input, &rfc5011_));
        _set_bit(6);
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Ksk::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  ::google::protobuf::uint8* raw_buffer = output->GetDirectBufferForNBytesAndAdvance(_cached_size_);
  if (raw_buffer != NULL) {
    Ksk::SerializeWithCachedSizesToArray(raw_buffer);
    return;
  }
  
  // required uint32 algorithm = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->algorithm(), output);
  }
  
  // optional uint32 bits = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->bits(), output);
  }
  
  // required int32 lifetime = 3;
  if (_has_bit(2)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->lifetime(), output);
  }
  
  // required string repository = 4;
  if (_has_bit(3)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->repository().data(), this->repository().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->repository(), output);
  }
  
  // optional uint32 standby = 5;
  if (_has_bit(4)) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->standby(), output);
  }
  
  // optional bool manual_rollover = 6;
  if (_has_bit(5)) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(6, this->manual_rollover(), output);
  }
  
  // optional bool rfc5011 = 7;
  if (_has_bit(6)) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(7, this->rfc5011(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Ksk::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint32 algorithm = 1;
  if (_has_bit(0)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->algorithm(), target);
  }
  
  // optional uint32 bits = 2;
  if (_has_bit(1)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->bits(), target);
  }
  
  // required int32 lifetime = 3;
  if (_has_bit(2)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->lifetime(), target);
  }
  
  // required string repository = 4;
  if (_has_bit(3)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->repository().data(), this->repository().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->repository(), target);
  }
  
  // optional uint32 standby = 5;
  if (_has_bit(4)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->standby(), target);
  }
  
  // optional bool manual_rollover = 6;
  if (_has_bit(5)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(6, this->manual_rollover(), target);
  }
  
  // optional bool rfc5011 = 7;
  if (_has_bit(6)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(7, this->rfc5011(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Ksk::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 algorithm = 1;
    if (has_algorithm()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->algorithm());
    }
    
    // optional uint32 bits = 2;
    if (has_bits()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->bits());
    }
    
    // required int32 lifetime = 3;
    if (has_lifetime()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->lifetime());
    }
    
    // required string repository = 4;
    if (has_repository()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->repository());
    }
    
    // optional uint32 standby = 5;
    if (has_standby()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->standby());
    }
    
    // optional bool manual_rollover = 6;
    if (has_manual_rollover()) {
      total_size += 1 + 1;
    }
    
    // optional bool rfc5011 = 7;
    if (has_rfc5011()) {
      total_size += 1 + 1;
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  _cached_size_ = total_size;
  return total_size;
}

void Ksk::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Ksk* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Ksk*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Ksk::MergeFrom(const Ksk& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_algorithm(from.algorithm());
    }
    if (from._has_bit(1)) {
      set_bits(from.bits());
    }
    if (from._has_bit(2)) {
      set_lifetime(from.lifetime());
    }
    if (from._has_bit(3)) {
      set_repository(from.repository());
    }
    if (from._has_bit(4)) {
      set_standby(from.standby());
    }
    if (from._has_bit(5)) {
      set_manual_rollover(from.manual_rollover());
    }
    if (from._has_bit(6)) {
      set_rfc5011(from.rfc5011());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Ksk::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Ksk::CopyFrom(const Ksk& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ksk::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000d) != 0x0000000d) return false;
  
  return true;
}

void Ksk::Swap(Ksk* other) {
  if (other != this) {
    std::swap(algorithm_, other->algorithm_);
    std::swap(bits_, other->bits_);
    std::swap(lifetime_, other->lifetime_);
    std::swap(repository_, other->repository_);
    std::swap(standby_, other->standby_);
    std::swap(manual_rollover_, other->manual_rollover_);
    std::swap(rfc5011_, other->rfc5011_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Ksk::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Ksk_descriptor_;
  metadata.reflection = Ksk_reflection_;
  return metadata;
}


// ===================================================================

const ::std::string Zsk::_default_repository_;
#ifndef _MSC_VER
const int Zsk::kAlgorithmFieldNumber;
const int Zsk::kBitsFieldNumber;
const int Zsk::kLifetimeFieldNumber;
const int Zsk::kRepositoryFieldNumber;
const int Zsk::kStandbyFieldNumber;
const int Zsk::kManualRolloverFieldNumber;
#endif  // !_MSC_VER

Zsk::Zsk() {
  SharedCtor();
}

void Zsk::InitAsDefaultInstance() {
}

Zsk::Zsk(const Zsk& from) {
  SharedCtor();
  MergeFrom(from);
}

void Zsk::SharedCtor() {
  _cached_size_ = 0;
  algorithm_ = 0u;
  bits_ = 0u;
  lifetime_ = 0;
  repository_ = const_cast< ::std::string*>(&_default_repository_);
  standby_ = 0u;
  manual_rollover_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Zsk::~Zsk() {
  SharedDtor();
}

void Zsk::SharedDtor() {
  if (repository_ != &_default_repository_) {
    delete repository_;
  }
  if (this != default_instance_) {
  }
}

const ::google::protobuf::Descriptor* Zsk::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Zsk_descriptor_;
}

const Zsk& Zsk::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_kasp_2eproto();  return *default_instance_;
}

Zsk* Zsk::default_instance_ = NULL;

Zsk* Zsk::New() const {
  return new Zsk;
}

void Zsk::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    algorithm_ = 0u;
    bits_ = 0u;
    lifetime_ = 0;
    if (_has_bit(3)) {
      if (repository_ != &_default_repository_) {
        repository_->clear();
      }
    }
    standby_ = 0u;
    manual_rollover_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Zsk::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 algorithm = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
        DO_(::google::protobuf::internal::WireFormatLite::ReadUInt32(
              input, &algorithm_));
        _set_bit(0);
        if (input->ExpectTag(16)) goto parse_bits;
        break;
      }
      
      // optional uint32 bits = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
       parse_bits:
        DO_(::google::protobuf::internal::WireFormatLite::ReadUInt32(
              input, &bits_));
        _set_bit(1);
        if (input->ExpectTag(24)) goto parse_lifetime;
        break;
      }
      
      // required int32 lifetime = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
       parse_lifetime:
        DO_(::google::protobuf::internal::WireFormatLite::ReadInt32(
              input, &lifetime_));
        _set_bit(2);
        if (input->ExpectTag(34)) goto parse_repository;
        break;
      }
      
      // required string repository = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_repository:
        DO_(::google::protobuf::internal::WireFormatLite::ReadString(
              input, this->mutable_repository()));
        ::google::protobuf::internal::WireFormat::VerifyUTF8String(
          this->repository().data(), this->repository().length(),
          ::google::protobuf::internal::WireFormat::PARSE);
        if (input->ExpectTag(40)) goto parse_standby;
        break;
      }
      
      // optional uint32 standby = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
       parse_standby:
        DO_(::google::protobuf::internal::WireFormatLite::ReadUInt32(
              input, &standby_));
        _set_bit(4);
        if (input->ExpectTag(48)) goto parse_manual_rollover;
        break;
      }
      
      // optional bool manual_rollover = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
       parse_manual_rollover:
        DO_(::google::protobuf::internal::WireFormatLite::ReadBool(
              input, &manual_rollover_));
        _set_bit(5);
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Zsk::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  ::google::protobuf::uint8* raw_buffer = output->GetDirectBufferForNBytesAndAdvance(_cached_size_);
  if (raw_buffer != NULL) {
    Zsk::SerializeWithCachedSizesToArray(raw_buffer);
    return;
  }
  
  // required uint32 algorithm = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->algorithm(), output);
  }
  
  // optional uint32 bits = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->bits(), output);
  }
  
  // required int32 lifetime = 3;
  if (_has_bit(2)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->lifetime(), output);
  }
  
  // required string repository = 4;
  if (_has_bit(3)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->repository().data(), this->repository().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->repository(), output);
  }
  
  // optional uint32 standby = 5;
  if (_has_bit(4)) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->standby(), output);
  }
  
  // optional bool manual_rollover = 6;
  if (_has_bit(5)) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(6, this->manual_rollover(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Zsk::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint32 algorithm = 1;
  if (_has_bit(0)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->algorithm(), target);
  }
  
  // optional uint32 bits = 2;
  if (_has_bit(1)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->bits(), target);
  }
  
  // required int32 lifetime = 3;
  if (_has_bit(2)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->lifetime(), target);
  }
  
  // required string repository = 4;
  if (_has_bit(3)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->repository().data(), this->repository().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->repository(), target);
  }
  
  // optional uint32 standby = 5;
  if (_has_bit(4)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->standby(), target);
  }
  
  // optional bool manual_rollover = 6;
  if (_has_bit(5)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(6, this->manual_rollover(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Zsk::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 algorithm = 1;
    if (has_algorithm()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->algorithm());
    }
    
    // optional uint32 bits = 2;
    if (has_bits()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->bits());
    }
    
    // required int32 lifetime = 3;
    if (has_lifetime()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->lifetime());
    }
    
    // required string repository = 4;
    if (has_repository()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->repository());
    }
    
    // optional uint32 standby = 5;
    if (has_standby()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->standby());
    }
    
    // optional bool manual_rollover = 6;
    if (has_manual_rollover()) {
      total_size += 1 + 1;
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  _cached_size_ = total_size;
  return total_size;
}

void Zsk::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Zsk* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Zsk*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Zsk::MergeFrom(const Zsk& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_algorithm(from.algorithm());
    }
    if (from._has_bit(1)) {
      set_bits(from.bits());
    }
    if (from._has_bit(2)) {
      set_lifetime(from.lifetime());
    }
    if (from._has_bit(3)) {
      set_repository(from.repository());
    }
    if (from._has_bit(4)) {
      set_standby(from.standby());
    }
    if (from._has_bit(5)) {
      set_manual_rollover(from.manual_rollover());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Zsk::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Zsk::CopyFrom(const Zsk& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Zsk::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000d) != 0x0000000d) return false;
  
  return true;
}

void Zsk::Swap(Zsk* other) {
  if (other != this) {
    std::swap(algorithm_, other->algorithm_);
    std::swap(bits_, other->bits_);
    std::swap(lifetime_, other->lifetime_);
    std::swap(repository_, other->repository_);
    std::swap(standby_, other->standby_);
    std::swap(manual_rollover_, other->manual_rollover_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Zsk::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Zsk_descriptor_;
  metadata.reflection = Zsk_reflection_;
  return metadata;
}


// ===================================================================

const ::std::string Csk::_default_repository_;
#ifndef _MSC_VER
const int Csk::kAlgorithmFieldNumber;
const int Csk::kBitsFieldNumber;
const int Csk::kLifetimeFieldNumber;
const int Csk::kRepositoryFieldNumber;
const int Csk::kStandbyFieldNumber;
const int Csk::kManualRolloverFieldNumber;
const int Csk::kRfc5011FieldNumber;
#endif  // !_MSC_VER

Csk::Csk() {
  SharedCtor();
}

void Csk::InitAsDefaultInstance() {
}

Csk::Csk(const Csk& from) {
  SharedCtor();
  MergeFrom(from);
}

void Csk::SharedCtor() {
  _cached_size_ = 0;
  algorithm_ = 0u;
  bits_ = 0u;
  lifetime_ = 0;
  repository_ = const_cast< ::std::string*>(&_default_repository_);
  standby_ = 0u;
  manual_rollover_ = false;
  rfc5011_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Csk::~Csk() {
  SharedDtor();
}

void Csk::SharedDtor() {
  if (repository_ != &_default_repository_) {
    delete repository_;
  }
  if (this != default_instance_) {
  }
}

const ::google::protobuf::Descriptor* Csk::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Csk_descriptor_;
}

const Csk& Csk::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_kasp_2eproto();  return *default_instance_;
}

Csk* Csk::default_instance_ = NULL;

Csk* Csk::New() const {
  return new Csk;
}

void Csk::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    algorithm_ = 0u;
    bits_ = 0u;
    lifetime_ = 0;
    if (_has_bit(3)) {
      if (repository_ != &_default_repository_) {
        repository_->clear();
      }
    }
    standby_ = 0u;
    manual_rollover_ = false;
    rfc5011_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Csk::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 algorithm = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
        DO_(::google::protobuf::internal::WireFormatLite::ReadUInt32(
              input, &algorithm_));
        _set_bit(0);
        if (input->ExpectTag(16)) goto parse_bits;
        break;
      }
      
      // optional uint32 bits = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
       parse_bits:
        DO_(::google::protobuf::internal::WireFormatLite::ReadUInt32(
              input, &bits_));
        _set_bit(1);
        if (input->ExpectTag(24)) goto parse_lifetime;
        break;
      }
      
      // required int32 lifetime = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
       parse_lifetime:
        DO_(::google::protobuf::internal::WireFormatLite::ReadInt32(
              input, &lifetime_));
        _set_bit(2);
        if (input->ExpectTag(34)) goto parse_repository;
        break;
      }
      
      // required string repository = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_repository:
        DO_(::google::protobuf::internal::WireFormatLite::ReadString(
              input, this->mutable_repository()));
        ::google::protobuf::internal::WireFormat::VerifyUTF8String(
          this->repository().data(), this->repository().length(),
          ::google::protobuf::internal::WireFormat::PARSE);
        if (input->ExpectTag(40)) goto parse_standby;
        break;
      }
      
      // optional uint32 standby = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
       parse_standby:
        DO_(::google::protobuf::internal::WireFormatLite::ReadUInt32(
              input, &standby_));
        _set_bit(4);
        if (input->ExpectTag(48)) goto parse_manual_rollover;
        break;
      }
      
      // optional bool manual_rollover = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
       parse_manual_rollover:
        DO_(::google::protobuf::internal::WireFormatLite::ReadBool(
              input, &manual_rollover_));
        _set_bit(5);
        if (input->ExpectTag(56)) goto parse_rfc5011;
        break;
      }
      
      // optional bool rfc5011 = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
       parse_rfc5011:
        DO_(::google::protobuf::internal::WireFormatLite::ReadBool(
              input, &rfc5011_));
        _set_bit(6);
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Csk::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  ::google::protobuf::uint8* raw_buffer = output->GetDirectBufferForNBytesAndAdvance(_cached_size_);
  if (raw_buffer != NULL) {
    Csk::SerializeWithCachedSizesToArray(raw_buffer);
    return;
  }
  
  // required uint32 algorithm = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->algorithm(), output);
  }
  
  // optional uint32 bits = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->bits(), output);
  }
  
  // required int32 lifetime = 3;
  if (_has_bit(2)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->lifetime(), output);
  }
  
  // required string repository = 4;
  if (_has_bit(3)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->repository().data(), this->repository().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->repository(), output);
  }
  
  // optional uint32 standby = 5;
  if (_has_bit(4)) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->standby(), output);
  }
  
  // optional bool manual_rollover = 6;
  if (_has_bit(5)) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(6, this->manual_rollover(), output);
  }
  
  // optional bool rfc5011 = 7;
  if (_has_bit(6)) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(7, this->rfc5011(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Csk::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint32 algorithm = 1;
  if (_has_bit(0)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->algorithm(), target);
  }
  
  // optional uint32 bits = 2;
  if (_has_bit(1)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->bits(), target);
  }
  
  // required int32 lifetime = 3;
  if (_has_bit(2)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->lifetime(), target);
  }
  
  // required string repository = 4;
  if (_has_bit(3)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->repository().data(), this->repository().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->repository(), target);
  }
  
  // optional uint32 standby = 5;
  if (_has_bit(4)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->standby(), target);
  }
  
  // optional bool manual_rollover = 6;
  if (_has_bit(5)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(6, this->manual_rollover(), target);
  }
  
  // optional bool rfc5011 = 7;
  if (_has_bit(6)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(7, this->rfc5011(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Csk::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 algorithm = 1;
    if (has_algorithm()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->algorithm());
    }
    
    // optional uint32 bits = 2;
    if (has_bits()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->bits());
    }
    
    // required int32 lifetime = 3;
    if (has_lifetime()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->lifetime());
    }
    
    // required string repository = 4;
    if (has_repository()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->repository());
    }
    
    // optional uint32 standby = 5;
    if (has_standby()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->standby());
    }
    
    // optional bool manual_rollover = 6;
    if (has_manual_rollover()) {
      total_size += 1 + 1;
    }
    
    // optional bool rfc5011 = 7;
    if (has_rfc5011()) {
      total_size += 1 + 1;
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  _cached_size_ = total_size;
  return total_size;
}

void Csk::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Csk* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Csk*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Csk::MergeFrom(const Csk& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_algorithm(from.algorithm());
    }
    if (from._has_bit(1)) {
      set_bits(from.bits());
    }
    if (from._has_bit(2)) {
      set_lifetime(from.lifetime());
    }
    if (from._has_bit(3)) {
      set_repository(from.repository());
    }
    if (from._has_bit(4)) {
      set_standby(from.standby());
    }
    if (from._has_bit(5)) {
      set_manual_rollover(from.manual_rollover());
    }
    if (from._has_bit(6)) {
      set_rfc5011(from.rfc5011());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Csk::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Csk::CopyFrom(const Csk& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Csk::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000d) != 0x0000000d) return false;
  
  return true;
}

void Csk::Swap(Csk* other) {
  if (other != this) {
    std::swap(algorithm_, other->algorithm_);
    std::swap(bits_, other->bits_);
    std::swap(lifetime_, other->lifetime_);
    std::swap(repository_, other->repository_);
    std::swap(standby_, other->standby_);
    std::swap(manual_rollover_, other->manual_rollover_);
    std::swap(rfc5011_, other->rfc5011_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Csk::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Csk_descriptor_;
  metadata.reflection = Csk_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Zone::kPropagationdelayFieldNumber;
const int Zone::kTtlFieldNumber;
const int Zone::kMinFieldNumber;
const int Zone::kSerialFieldNumber;
#endif  // !_MSC_VER

Zone::Zone() {
  SharedCtor();
}

void Zone::InitAsDefaultInstance() {
}

Zone::Zone(const Zone& from) {
  SharedCtor();
  MergeFrom(from);
}

void Zone::SharedCtor() {
  _cached_size_ = 0;
  propagationdelay_ = 0;
  ttl_ = 0;
  min_ = 0;
  serial_ = 1;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Zone::~Zone() {
  SharedDtor();
}

void Zone::SharedDtor() {
  if (this != default_instance_) {
  }
}

const ::google::protobuf::Descriptor* Zone::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Zone_descriptor_;
}

const Zone& Zone::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_kasp_2eproto();  return *default_instance_;
}

Zone* Zone::default_instance_ = NULL;

Zone* Zone::New() const {
  return new Zone;
}

void Zone::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    propagationdelay_ = 0;
    ttl_ = 0;
    min_ = 0;
    serial_ = 1;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Zone::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 propagationdelay = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
        DO_(::google::protobuf::internal::WireFormatLite::ReadInt32(
              input, &propagationdelay_));
        _set_bit(0);
        if (input->ExpectTag(16)) goto parse_ttl;
        break;
      }
      
      // optional int32 ttl = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
       parse_ttl:
        DO_(::google::protobuf::internal::WireFormatLite::ReadInt32(
              input, &ttl_));
        _set_bit(1);
        if (input->ExpectTag(24)) goto parse_min;
        break;
      }
      
      // optional int32 min = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
       parse_min:
        DO_(::google::protobuf::internal::WireFormatLite::ReadInt32(
              input, &min_));
        _set_bit(2);
        if (input->ExpectTag(32)) goto parse_serial;
        break;
      }
      
      // optional .ods.kasp.serial serial = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
       parse_serial:
        int value;
        DO_(::google::protobuf::internal::WireFormatLite::ReadEnum(input, &value));
        if (ods::kasp::serial_IsValid(value)) {
          set_serial(static_cast< ods::kasp::serial >(value));
        } else {
          mutable_unknown_fields()->AddVarint(4, value);
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Zone::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  ::google::protobuf::uint8* raw_buffer = output->GetDirectBufferForNBytesAndAdvance(_cached_size_);
  if (raw_buffer != NULL) {
    Zone::SerializeWithCachedSizesToArray(raw_buffer);
    return;
  }
  
  // required int32 propagationdelay = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->propagationdelay(), output);
  }
  
  // optional int32 ttl = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->ttl(), output);
  }
  
  // optional int32 min = 3;
  if (_has_bit(2)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->min(), output);
  }
  
  // optional .ods.kasp.serial serial = 4;
  if (_has_bit(3)) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      4, this->serial(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Zone::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 propagationdelay = 1;
  if (_has_bit(0)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->propagationdelay(), target);
  }
  
  // optional int32 ttl = 2;
  if (_has_bit(1)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->ttl(), target);
  }
  
  // optional int32 min = 3;
  if (_has_bit(2)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->min(), target);
  }
  
  // optional .ods.kasp.serial serial = 4;
  if (_has_bit(3)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      4, this->serial(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Zone::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 propagationdelay = 1;
    if (has_propagationdelay()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->propagationdelay());
    }
    
    // optional int32 ttl = 2;
    if (has_ttl()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->ttl());
    }
    
    // optional int32 min = 3;
    if (has_min()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->min());
    }
    
    // optional .ods.kasp.serial serial = 4;
    if (has_serial()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->serial());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  _cached_size_ = total_size;
  return total_size;
}

void Zone::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Zone* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Zone*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Zone::MergeFrom(const Zone& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_propagationdelay(from.propagationdelay());
    }
    if (from._has_bit(1)) {
      set_ttl(from.ttl());
    }
    if (from._has_bit(2)) {
      set_min(from.min());
    }
    if (from._has_bit(3)) {
      set_serial(from.serial());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Zone::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Zone::CopyFrom(const Zone& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Zone::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  return true;
}

void Zone::Swap(Zone* other) {
  if (other != this) {
    std::swap(propagationdelay_, other->propagationdelay_);
    std::swap(ttl_, other->ttl_);
    std::swap(min_, other->min_);
    std::swap(serial_, other->serial_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Zone::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Zone_descriptor_;
  metadata.reflection = Zone_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Parent::kTtldsFieldNumber;
const int Parent::kRegistrationdelayFieldNumber;
const int Parent::kPropagationdelayFieldNumber;
const int Parent::kTtlFieldNumber;
const int Parent::kMinFieldNumber;
#endif  // !_MSC_VER

Parent::Parent() {
  SharedCtor();
}

void Parent::InitAsDefaultInstance() {
}

Parent::Parent(const Parent& from) {
  SharedCtor();
  MergeFrom(from);
}

void Parent::SharedCtor() {
  _cached_size_ = 0;
  ttlds_ = 0;
  registrationdelay_ = 0;
  propagationdelay_ = 0;
  ttl_ = 0;
  min_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Parent::~Parent() {
  SharedDtor();
}

void Parent::SharedDtor() {
  if (this != default_instance_) {
  }
}

const ::google::protobuf::Descriptor* Parent::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Parent_descriptor_;
}

const Parent& Parent::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_kasp_2eproto();  return *default_instance_;
}

Parent* Parent::default_instance_ = NULL;

Parent* Parent::New() const {
  return new Parent;
}

void Parent::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    ttlds_ = 0;
    registrationdelay_ = 0;
    propagationdelay_ = 0;
    ttl_ = 0;
    min_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Parent::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 ttlds = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
        DO_(::google::protobuf::internal::WireFormatLite::ReadInt32(
              input, &ttlds_));
        _set_bit(0);
        if (input->ExpectTag(16)) goto parse_registrationdelay;
        break;
      }
      
      // optional int32 registrationdelay = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
       parse_registrationdelay:
        DO_(::google::protobuf::internal::WireFormatLite::ReadInt32(
              input, &registrationdelay_));
        _set_bit(1);
        if (input->ExpectTag(24)) goto parse_propagationdelay;
        break;
      }
      
      // optional int32 propagationdelay = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
       parse_propagationdelay:
        DO_(::google::protobuf::internal::WireFormatLite::ReadInt32(
              input, &propagationdelay_));
        _set_bit(2);
        if (input->ExpectTag(32)) goto parse_ttl;
        break;
      }
      
      // optional int32 ttl = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
       parse_ttl:
        DO_(::google::protobuf::internal::WireFormatLite::ReadInt32(
              input, &ttl_));
        _set_bit(3);
        if (input->ExpectTag(40)) goto parse_min;
        break;
      }
      
      // optional int32 min = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
       parse_min:
        DO_(::google::protobuf::internal::WireFormatLite::ReadInt32(
              input, &min_));
        _set_bit(4);
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Parent::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  ::google::protobuf::uint8* raw_buffer = output->GetDirectBufferForNBytesAndAdvance(_cached_size_);
  if (raw_buffer != NULL) {
    Parent::SerializeWithCachedSizesToArray(raw_buffer);
    return;
  }
  
  // optional int32 ttlds = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->ttlds(), output);
  }
  
  // optional int32 registrationdelay = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->registrationdelay(), output);
  }
  
  // optional int32 propagationdelay = 3;
  if (_has_bit(2)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->propagationdelay(), output);
  }
  
  // optional int32 ttl = 4;
  if (_has_bit(3)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->ttl(), output);
  }
  
  // optional int32 min = 5;
  if (_has_bit(4)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->min(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Parent::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional int32 ttlds = 1;
  if (_has_bit(0)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->ttlds(), target);
  }
  
  // optional int32 registrationdelay = 2;
  if (_has_bit(1)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->registrationdelay(), target);
  }
  
  // optional int32 propagationdelay = 3;
  if (_has_bit(2)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->propagationdelay(), target);
  }
  
  // optional int32 ttl = 4;
  if (_has_bit(3)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->ttl(), target);
  }
  
  // optional int32 min = 5;
  if (_has_bit(4)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->min(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Parent::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 ttlds = 1;
    if (has_ttlds()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->ttlds());
    }
    
    // optional int32 registrationdelay = 2;
    if (has_registrationdelay()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->registrationdelay());
    }
    
    // optional int32 propagationdelay = 3;
    if (has_propagationdelay()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->propagationdelay());
    }
    
    // optional int32 ttl = 4;
    if (has_ttl()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->ttl());
    }
    
    // optional int32 min = 5;
    if (has_min()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->min());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  _cached_size_ = total_size;
  return total_size;
}

void Parent::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Parent* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Parent*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Parent::MergeFrom(const Parent& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_ttlds(from.ttlds());
    }
    if (from._has_bit(1)) {
      set_registrationdelay(from.registrationdelay());
    }
    if (from._has_bit(2)) {
      set_propagationdelay(from.propagationdelay());
    }
    if (from._has_bit(3)) {
      set_ttl(from.ttl());
    }
    if (from._has_bit(4)) {
      set_min(from.min());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Parent::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Parent::CopyFrom(const Parent& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Parent::IsInitialized() const {
  
  return true;
}

void Parent::Swap(Parent* other) {
  if (other != this) {
    std::swap(ttlds_, other->ttlds_);
    std::swap(registrationdelay_, other->registrationdelay_);
    std::swap(propagationdelay_, other->propagationdelay_);
    std::swap(ttl_, other->ttl_);
    std::swap(min_, other->min_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Parent::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Parent_descriptor_;
  metadata.reflection = Parent_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Audit::kPartialFieldNumber;
#endif  // !_MSC_VER

Audit::Audit() {
  SharedCtor();
}

void Audit::InitAsDefaultInstance() {
}

Audit::Audit(const Audit& from) {
  SharedCtor();
  MergeFrom(from);
}

void Audit::SharedCtor() {
  _cached_size_ = 0;
  partial_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Audit::~Audit() {
  SharedDtor();
}

void Audit::SharedDtor() {
  if (this != default_instance_) {
  }
}

const ::google::protobuf::Descriptor* Audit::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Audit_descriptor_;
}

const Audit& Audit::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_kasp_2eproto();  return *default_instance_;
}

Audit* Audit::default_instance_ = NULL;

Audit* Audit::New() const {
  return new Audit;
}

void Audit::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    partial_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Audit::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bool partial = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
        DO_(::google::protobuf::internal::WireFormatLite::ReadBool(
              input, &partial_));
        _set_bit(0);
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Audit::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  ::google::protobuf::uint8* raw_buffer = output->GetDirectBufferForNBytesAndAdvance(_cached_size_);
  if (raw_buffer != NULL) {
    Audit::SerializeWithCachedSizesToArray(raw_buffer);
    return;
  }
  
  // optional bool partial = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->partial(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Audit::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional bool partial = 1;
  if (_has_bit(0)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(1, this->partial(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Audit::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bool partial = 1;
    if (has_partial()) {
      total_size += 1 + 1;
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  _cached_size_ = total_size;
  return total_size;
}

void Audit::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Audit* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Audit*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Audit::MergeFrom(const Audit& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_partial(from.partial());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Audit::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Audit::CopyFrom(const Audit& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Audit::IsInitialized() const {
  
  return true;
}

void Audit::Swap(Audit* other) {
  if (other != this) {
    std::swap(partial_, other->partial_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Audit::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Audit_descriptor_;
  metadata.reflection = Audit_reflection_;
  return metadata;
}


}  // namespace kasp
}  // namespace ods
