// Generated by the protocol buffer compiler.  DO NOT EDIT!

#ifndef PROTOBUF_kasp_2eproto__INCLUDED
#define PROTOBUF_kasp_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2002000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2002000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
#include "xmlext.pb.h"

namespace kasp {
namespace pb {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_kasp_2eproto();
void protobuf_AssignDesc_kasp_2eproto();
void protobuf_ShutdownFile_kasp_2eproto();

class KaspDocument;
class KASP;
class Policy;
class Signatures;
class Denial;
class NSEC;
class NSEC3;
class Keys;
class Ksk;
class Zsk;
class Csk;
class Zone;
class Parent;
class Audit;

enum serial {
  counter = 1,
  datecounter = 2,
  unixtime = 3,
  keep = 4
};
bool serial_IsValid(int value);
const serial serial_MIN = counter;
const serial serial_MAX = keep;

const ::google::protobuf::EnumDescriptor* serial_descriptor();
inline const ::std::string& serial_Name(serial value) {
  return ::google::protobuf::internal::NameOfEnum(
    serial_descriptor(), value);
}
inline bool serial_Parse(
    const ::std::string& name, serial* value) {
  return ::google::protobuf::internal::ParseNamedEnum<serial>(
    serial_descriptor(), name, value);
}
// ===================================================================

class KaspDocument : public ::google::protobuf::Message {
 public:
  KaspDocument();
  virtual ~KaspDocument();
  
  KaspDocument(const KaspDocument& from);
  
  inline KaspDocument& operator=(const KaspDocument& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const KaspDocument& default_instance();
  void Swap(KaspDocument* other);
  
  // implements Message ----------------------------------------------
  
  KaspDocument* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const KaspDocument& from);
  void MergeFrom(const KaspDocument& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .kasp.pb.KASP kasp = 2;
  inline bool has_kasp() const;
  inline void clear_kasp();
  static const int kKaspFieldNumber = 2;
  inline const ::kasp::pb::KASP& kasp() const;
  inline ::kasp::pb::KASP* mutable_kasp();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::kasp::pb::KASP* kasp_;
  friend void  protobuf_AddDesc_kasp_2eproto();
  friend void protobuf_AssignDesc_kasp_2eproto();
  friend void protobuf_ShutdownFile_kasp_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static KaspDocument* default_instance_;
};
// -------------------------------------------------------------------

class KASP : public ::google::protobuf::Message {
 public:
  KASP();
  virtual ~KASP();
  
  KASP(const KASP& from);
  
  inline KASP& operator=(const KASP& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const KASP& default_instance();
  void Swap(KASP* other);
  
  // implements Message ----------------------------------------------
  
  KASP* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const KASP& from);
  void MergeFrom(const KASP& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .kasp.pb.Policy policies = 1;
  inline int policies_size() const;
  inline void clear_policies();
  static const int kPoliciesFieldNumber = 1;
  inline const ::google::protobuf::RepeatedPtrField< ::kasp::pb::Policy >& policies() const;
  inline ::google::protobuf::RepeatedPtrField< ::kasp::pb::Policy >* mutable_policies();
  inline const ::kasp::pb::Policy& policies(int index) const;
  inline ::kasp::pb::Policy* mutable_policies(int index);
  inline ::kasp::pb::Policy* add_policies();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::kasp::pb::Policy > policies_;
  friend void  protobuf_AddDesc_kasp_2eproto();
  friend void protobuf_AssignDesc_kasp_2eproto();
  friend void protobuf_ShutdownFile_kasp_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static KASP* default_instance_;
};
// -------------------------------------------------------------------

class Policy : public ::google::protobuf::Message {
 public:
  Policy();
  virtual ~Policy();
  
  Policy(const Policy& from);
  
  inline Policy& operator=(const Policy& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Policy& default_instance();
  void Swap(Policy* other);
  
  // implements Message ----------------------------------------------
  
  Policy* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Policy& from);
  void MergeFrom(const Policy& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  
  // required string description = 2;
  inline bool has_description() const;
  inline void clear_description();
  static const int kDescriptionFieldNumber = 2;
  inline const ::std::string& description() const;
  inline void set_description(const ::std::string& value);
  inline void set_description(const char* value);
  inline void set_description(const char* value, size_t size);
  inline ::std::string* mutable_description();
  
  // required .kasp.pb.Signatures signatures = 3;
  inline bool has_signatures() const;
  inline void clear_signatures();
  static const int kSignaturesFieldNumber = 3;
  inline const ::kasp::pb::Signatures& signatures() const;
  inline ::kasp::pb::Signatures* mutable_signatures();
  
  // required .kasp.pb.Denial denial = 4;
  inline bool has_denial() const;
  inline void clear_denial();
  static const int kDenialFieldNumber = 4;
  inline const ::kasp::pb::Denial& denial() const;
  inline ::kasp::pb::Denial* mutable_denial();
  
  // required .kasp.pb.Keys keys = 5;
  inline bool has_keys() const;
  inline void clear_keys();
  static const int kKeysFieldNumber = 5;
  inline const ::kasp::pb::Keys& keys() const;
  inline ::kasp::pb::Keys* mutable_keys();
  
  // required .kasp.pb.Zone zone = 6;
  inline bool has_zone() const;
  inline void clear_zone();
  static const int kZoneFieldNumber = 6;
  inline const ::kasp::pb::Zone& zone() const;
  inline ::kasp::pb::Zone* mutable_zone();
  
  // required .kasp.pb.Parent parent = 7;
  inline bool has_parent() const;
  inline void clear_parent();
  static const int kParentFieldNumber = 7;
  inline const ::kasp::pb::Parent& parent() const;
  inline ::kasp::pb::Parent* mutable_parent();
  
  // repeated .kasp.pb.Audit audit = 8;
  inline int audit_size() const;
  inline void clear_audit();
  static const int kAuditFieldNumber = 8;
  inline const ::google::protobuf::RepeatedPtrField< ::kasp::pb::Audit >& audit() const;
  inline ::google::protobuf::RepeatedPtrField< ::kasp::pb::Audit >* mutable_audit();
  inline const ::kasp::pb::Audit& audit(int index) const;
  inline ::kasp::pb::Audit* mutable_audit(int index);
  inline ::kasp::pb::Audit* add_audit();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* name_;
  static const ::std::string _default_name_;
  ::std::string* description_;
  static const ::std::string _default_description_;
  ::kasp::pb::Signatures* signatures_;
  ::kasp::pb::Denial* denial_;
  ::kasp::pb::Keys* keys_;
  ::kasp::pb::Zone* zone_;
  ::kasp::pb::Parent* parent_;
  ::google::protobuf::RepeatedPtrField< ::kasp::pb::Audit > audit_;
  friend void  protobuf_AddDesc_kasp_2eproto();
  friend void protobuf_AssignDesc_kasp_2eproto();
  friend void protobuf_ShutdownFile_kasp_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Policy* default_instance_;
};
// -------------------------------------------------------------------

class Signatures : public ::google::protobuf::Message {
 public:
  Signatures();
  virtual ~Signatures();
  
  Signatures(const Signatures& from);
  
  inline Signatures& operator=(const Signatures& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Signatures& default_instance();
  void Swap(Signatures* other);
  
  // implements Message ----------------------------------------------
  
  Signatures* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Signatures& from);
  void MergeFrom(const Signatures& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 resign = 1;
  inline bool has_resign() const;
  inline void clear_resign();
  static const int kResignFieldNumber = 1;
  inline ::google::protobuf::int32 resign() const;
  inline void set_resign(::google::protobuf::int32 value);
  
  // optional int32 refresh = 2;
  inline bool has_refresh() const;
  inline void clear_refresh();
  static const int kRefreshFieldNumber = 2;
  inline ::google::protobuf::int32 refresh() const;
  inline void set_refresh(::google::protobuf::int32 value);
  
  // optional int32 jitter = 3;
  inline bool has_jitter() const;
  inline void clear_jitter();
  static const int kJitterFieldNumber = 3;
  inline ::google::protobuf::int32 jitter() const;
  inline void set_jitter(::google::protobuf::int32 value);
  
  // optional int32 inceptionOffset = 4;
  inline bool has_inceptionoffset() const;
  inline void clear_inceptionoffset();
  static const int kInceptionOffsetFieldNumber = 4;
  inline ::google::protobuf::int32 inceptionoffset() const;
  inline void set_inceptionoffset(::google::protobuf::int32 value);
  
  // optional int32 ttl = 5;
  inline bool has_ttl() const;
  inline void clear_ttl();
  static const int kTtlFieldNumber = 5;
  inline ::google::protobuf::int32 ttl() const;
  inline void set_ttl(::google::protobuf::int32 value);
  
  // optional int32 valdefault = 6;
  inline bool has_valdefault() const;
  inline void clear_valdefault();
  static const int kValdefaultFieldNumber = 6;
  inline ::google::protobuf::int32 valdefault() const;
  inline void set_valdefault(::google::protobuf::int32 value);
  
  // optional int32 valdenial = 7;
  inline bool has_valdenial() const;
  inline void clear_valdenial();
  static const int kValdenialFieldNumber = 7;
  inline ::google::protobuf::int32 valdenial() const;
  inline void set_valdenial(::google::protobuf::int32 value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 resign_;
  ::google::protobuf::int32 refresh_;
  ::google::protobuf::int32 jitter_;
  ::google::protobuf::int32 inceptionoffset_;
  ::google::protobuf::int32 ttl_;
  ::google::protobuf::int32 valdefault_;
  ::google::protobuf::int32 valdenial_;
  friend void  protobuf_AddDesc_kasp_2eproto();
  friend void protobuf_AssignDesc_kasp_2eproto();
  friend void protobuf_ShutdownFile_kasp_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Signatures* default_instance_;
};
// -------------------------------------------------------------------

class Denial : public ::google::protobuf::Message {
 public:
  Denial();
  virtual ~Denial();
  
  Denial(const Denial& from);
  
  inline Denial& operator=(const Denial& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Denial& default_instance();
  void Swap(Denial* other);
  
  // implements Message ----------------------------------------------
  
  Denial* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Denial& from);
  void MergeFrom(const Denial& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .kasp.pb.NSEC nsec = 1;
  inline bool has_nsec() const;
  inline void clear_nsec();
  static const int kNsecFieldNumber = 1;
  inline const ::kasp::pb::NSEC& nsec() const;
  inline ::kasp::pb::NSEC* mutable_nsec();
  
  // optional .kasp.pb.NSEC3 nsec3 = 2;
  inline bool has_nsec3() const;
  inline void clear_nsec3();
  static const int kNsec3FieldNumber = 2;
  inline const ::kasp::pb::NSEC3& nsec3() const;
  inline ::kasp::pb::NSEC3* mutable_nsec3();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::kasp::pb::NSEC* nsec_;
  ::kasp::pb::NSEC3* nsec3_;
  friend void  protobuf_AddDesc_kasp_2eproto();
  friend void protobuf_AssignDesc_kasp_2eproto();
  friend void protobuf_ShutdownFile_kasp_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Denial* default_instance_;
};
// -------------------------------------------------------------------

class NSEC : public ::google::protobuf::Message {
 public:
  NSEC();
  virtual ~NSEC();
  
  NSEC(const NSEC& from);
  
  inline NSEC& operator=(const NSEC& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const NSEC& default_instance();
  void Swap(NSEC* other);
  
  // implements Message ----------------------------------------------
  
  NSEC* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NSEC& from);
  void MergeFrom(const NSEC& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  friend void  protobuf_AddDesc_kasp_2eproto();
  friend void protobuf_AssignDesc_kasp_2eproto();
  friend void protobuf_ShutdownFile_kasp_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[1];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static NSEC* default_instance_;
};
// -------------------------------------------------------------------

class NSEC3 : public ::google::protobuf::Message {
 public:
  NSEC3();
  virtual ~NSEC3();
  
  NSEC3(const NSEC3& from);
  
  inline NSEC3& operator=(const NSEC3& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const NSEC3& default_instance();
  void Swap(NSEC3* other);
  
  // implements Message ----------------------------------------------
  
  NSEC3* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NSEC3& from);
  void MergeFrom(const NSEC3& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional bool optout = 1;
  inline bool has_optout() const;
  inline void clear_optout();
  static const int kOptoutFieldNumber = 1;
  inline bool optout() const;
  inline void set_optout(bool value);
  
  // optional int32 ttl = 2;
  inline bool has_ttl() const;
  inline void clear_ttl();
  static const int kTtlFieldNumber = 2;
  inline ::google::protobuf::int32 ttl() const;
  inline void set_ttl(::google::protobuf::int32 value);
  
  // required int32 resalt = 3;
  inline bool has_resalt() const;
  inline void clear_resalt();
  static const int kResaltFieldNumber = 3;
  inline ::google::protobuf::int32 resalt() const;
  inline void set_resalt(::google::protobuf::int32 value);
  
  // required int32 algorithm = 4;
  inline bool has_algorithm() const;
  inline void clear_algorithm();
  static const int kAlgorithmFieldNumber = 4;
  inline ::google::protobuf::int32 algorithm() const;
  inline void set_algorithm(::google::protobuf::int32 value);
  
  // required int32 iterations = 5;
  inline bool has_iterations() const;
  inline void clear_iterations();
  static const int kIterationsFieldNumber = 5;
  inline ::google::protobuf::int32 iterations() const;
  inline void set_iterations(::google::protobuf::int32 value);
  
  // required int32 saltlength = 6;
  inline bool has_saltlength() const;
  inline void clear_saltlength();
  static const int kSaltlengthFieldNumber = 6;
  inline ::google::protobuf::int32 saltlength() const;
  inline void set_saltlength(::google::protobuf::int32 value);
  
  // optional string salt = 7;
  inline bool has_salt() const;
  inline void clear_salt();
  static const int kSaltFieldNumber = 7;
  inline const ::std::string& salt() const;
  inline void set_salt(const ::std::string& value);
  inline void set_salt(const char* value);
  inline void set_salt(const char* value, size_t size);
  inline ::std::string* mutable_salt();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  bool optout_;
  ::google::protobuf::int32 ttl_;
  ::google::protobuf::int32 resalt_;
  ::google::protobuf::int32 algorithm_;
  ::google::protobuf::int32 iterations_;
  ::google::protobuf::int32 saltlength_;
  ::std::string* salt_;
  static const ::std::string _default_salt_;
  friend void  protobuf_AddDesc_kasp_2eproto();
  friend void protobuf_AssignDesc_kasp_2eproto();
  friend void protobuf_ShutdownFile_kasp_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static NSEC3* default_instance_;
};
// -------------------------------------------------------------------

class Keys : public ::google::protobuf::Message {
 public:
  Keys();
  virtual ~Keys();
  
  Keys(const Keys& from);
  
  inline Keys& operator=(const Keys& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Keys& default_instance();
  void Swap(Keys* other);
  
  // implements Message ----------------------------------------------
  
  Keys* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Keys& from);
  void MergeFrom(const Keys& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 ttl = 1;
  inline bool has_ttl() const;
  inline void clear_ttl();
  static const int kTtlFieldNumber = 1;
  inline ::google::protobuf::int32 ttl() const;
  inline void set_ttl(::google::protobuf::int32 value);
  
  // required int32 retiresafety = 2;
  inline bool has_retiresafety() const;
  inline void clear_retiresafety();
  static const int kRetiresafetyFieldNumber = 2;
  inline ::google::protobuf::int32 retiresafety() const;
  inline void set_retiresafety(::google::protobuf::int32 value);
  
  // required int32 publishsafety = 3;
  inline bool has_publishsafety() const;
  inline void clear_publishsafety();
  static const int kPublishsafetyFieldNumber = 3;
  inline ::google::protobuf::int32 publishsafety() const;
  inline void set_publishsafety(::google::protobuf::int32 value);
  
  // optional bool zones_share_keys = 4;
  inline bool has_zones_share_keys() const;
  inline void clear_zones_share_keys();
  static const int kZonesShareKeysFieldNumber = 4;
  inline bool zones_share_keys() const;
  inline void set_zones_share_keys(bool value);
  
  // optional int32 purge = 5;
  inline bool has_purge() const;
  inline void clear_purge();
  static const int kPurgeFieldNumber = 5;
  inline ::google::protobuf::int32 purge() const;
  inline void set_purge(::google::protobuf::int32 value);
  
  // repeated .kasp.pb.Ksk ksk = 6;
  inline int ksk_size() const;
  inline void clear_ksk();
  static const int kKskFieldNumber = 6;
  inline const ::google::protobuf::RepeatedPtrField< ::kasp::pb::Ksk >& ksk() const;
  inline ::google::protobuf::RepeatedPtrField< ::kasp::pb::Ksk >* mutable_ksk();
  inline const ::kasp::pb::Ksk& ksk(int index) const;
  inline ::kasp::pb::Ksk* mutable_ksk(int index);
  inline ::kasp::pb::Ksk* add_ksk();
  
  // repeated .kasp.pb.Zsk zsk = 7;
  inline int zsk_size() const;
  inline void clear_zsk();
  static const int kZskFieldNumber = 7;
  inline const ::google::protobuf::RepeatedPtrField< ::kasp::pb::Zsk >& zsk() const;
  inline ::google::protobuf::RepeatedPtrField< ::kasp::pb::Zsk >* mutable_zsk();
  inline const ::kasp::pb::Zsk& zsk(int index) const;
  inline ::kasp::pb::Zsk* mutable_zsk(int index);
  inline ::kasp::pb::Zsk* add_zsk();
  
  // repeated .kasp.pb.Csk csk = 8;
  inline int csk_size() const;
  inline void clear_csk();
  static const int kCskFieldNumber = 8;
  inline const ::google::protobuf::RepeatedPtrField< ::kasp::pb::Csk >& csk() const;
  inline ::google::protobuf::RepeatedPtrField< ::kasp::pb::Csk >* mutable_csk();
  inline const ::kasp::pb::Csk& csk(int index) const;
  inline ::kasp::pb::Csk* mutable_csk(int index);
  inline ::kasp::pb::Csk* add_csk();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 ttl_;
  ::google::protobuf::int32 retiresafety_;
  ::google::protobuf::int32 publishsafety_;
  bool zones_share_keys_;
  ::google::protobuf::int32 purge_;
  ::google::protobuf::RepeatedPtrField< ::kasp::pb::Ksk > ksk_;
  ::google::protobuf::RepeatedPtrField< ::kasp::pb::Zsk > zsk_;
  ::google::protobuf::RepeatedPtrField< ::kasp::pb::Csk > csk_;
  friend void  protobuf_AddDesc_kasp_2eproto();
  friend void protobuf_AssignDesc_kasp_2eproto();
  friend void protobuf_ShutdownFile_kasp_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Keys* default_instance_;
};
// -------------------------------------------------------------------

class Ksk : public ::google::protobuf::Message {
 public:
  Ksk();
  virtual ~Ksk();
  
  Ksk(const Ksk& from);
  
  inline Ksk& operator=(const Ksk& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Ksk& default_instance();
  void Swap(Ksk* other);
  
  // implements Message ----------------------------------------------
  
  Ksk* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Ksk& from);
  void MergeFrom(const Ksk& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 algorithm = 1;
  inline bool has_algorithm() const;
  inline void clear_algorithm();
  static const int kAlgorithmFieldNumber = 1;
  inline ::google::protobuf::uint32 algorithm() const;
  inline void set_algorithm(::google::protobuf::uint32 value);
  
  // optional uint32 bits = 2;
  inline bool has_bits() const;
  inline void clear_bits();
  static const int kBitsFieldNumber = 2;
  inline ::google::protobuf::uint32 bits() const;
  inline void set_bits(::google::protobuf::uint32 value);
  
  // required int32 lifetime = 3;
  inline bool has_lifetime() const;
  inline void clear_lifetime();
  static const int kLifetimeFieldNumber = 3;
  inline ::google::protobuf::int32 lifetime() const;
  inline void set_lifetime(::google::protobuf::int32 value);
  
  // required string repository = 4;
  inline bool has_repository() const;
  inline void clear_repository();
  static const int kRepositoryFieldNumber = 4;
  inline const ::std::string& repository() const;
  inline void set_repository(const ::std::string& value);
  inline void set_repository(const char* value);
  inline void set_repository(const char* value, size_t size);
  inline ::std::string* mutable_repository();
  
  // optional uint32 standby = 5;
  inline bool has_standby() const;
  inline void clear_standby();
  static const int kStandbyFieldNumber = 5;
  inline ::google::protobuf::uint32 standby() const;
  inline void set_standby(::google::protobuf::uint32 value);
  
  // optional bool manual_rollover = 6;
  inline bool has_manual_rollover() const;
  inline void clear_manual_rollover();
  static const int kManualRolloverFieldNumber = 6;
  inline bool manual_rollover() const;
  inline void set_manual_rollover(bool value);
  
  // optional bool rfc5011 = 7;
  inline bool has_rfc5011() const;
  inline void clear_rfc5011();
  static const int kRfc5011FieldNumber = 7;
  inline bool rfc5011() const;
  inline void set_rfc5011(bool value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 algorithm_;
  ::google::protobuf::uint32 bits_;
  ::google::protobuf::int32 lifetime_;
  ::std::string* repository_;
  static const ::std::string _default_repository_;
  ::google::protobuf::uint32 standby_;
  bool manual_rollover_;
  bool rfc5011_;
  friend void  protobuf_AddDesc_kasp_2eproto();
  friend void protobuf_AssignDesc_kasp_2eproto();
  friend void protobuf_ShutdownFile_kasp_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Ksk* default_instance_;
};
// -------------------------------------------------------------------

class Zsk : public ::google::protobuf::Message {
 public:
  Zsk();
  virtual ~Zsk();
  
  Zsk(const Zsk& from);
  
  inline Zsk& operator=(const Zsk& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Zsk& default_instance();
  void Swap(Zsk* other);
  
  // implements Message ----------------------------------------------
  
  Zsk* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Zsk& from);
  void MergeFrom(const Zsk& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 algorithm = 1;
  inline bool has_algorithm() const;
  inline void clear_algorithm();
  static const int kAlgorithmFieldNumber = 1;
  inline ::google::protobuf::uint32 algorithm() const;
  inline void set_algorithm(::google::protobuf::uint32 value);
  
  // optional uint32 bits = 2;
  inline bool has_bits() const;
  inline void clear_bits();
  static const int kBitsFieldNumber = 2;
  inline ::google::protobuf::uint32 bits() const;
  inline void set_bits(::google::protobuf::uint32 value);
  
  // required int32 lifetime = 3;
  inline bool has_lifetime() const;
  inline void clear_lifetime();
  static const int kLifetimeFieldNumber = 3;
  inline ::google::protobuf::int32 lifetime() const;
  inline void set_lifetime(::google::protobuf::int32 value);
  
  // required string repository = 4;
  inline bool has_repository() const;
  inline void clear_repository();
  static const int kRepositoryFieldNumber = 4;
  inline const ::std::string& repository() const;
  inline void set_repository(const ::std::string& value);
  inline void set_repository(const char* value);
  inline void set_repository(const char* value, size_t size);
  inline ::std::string* mutable_repository();
  
  // optional uint32 standby = 5;
  inline bool has_standby() const;
  inline void clear_standby();
  static const int kStandbyFieldNumber = 5;
  inline ::google::protobuf::uint32 standby() const;
  inline void set_standby(::google::protobuf::uint32 value);
  
  // optional bool manual_rollover = 6;
  inline bool has_manual_rollover() const;
  inline void clear_manual_rollover();
  static const int kManualRolloverFieldNumber = 6;
  inline bool manual_rollover() const;
  inline void set_manual_rollover(bool value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 algorithm_;
  ::google::protobuf::uint32 bits_;
  ::google::protobuf::int32 lifetime_;
  ::std::string* repository_;
  static const ::std::string _default_repository_;
  ::google::protobuf::uint32 standby_;
  bool manual_rollover_;
  friend void  protobuf_AddDesc_kasp_2eproto();
  friend void protobuf_AssignDesc_kasp_2eproto();
  friend void protobuf_ShutdownFile_kasp_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Zsk* default_instance_;
};
// -------------------------------------------------------------------

class Csk : public ::google::protobuf::Message {
 public:
  Csk();
  virtual ~Csk();
  
  Csk(const Csk& from);
  
  inline Csk& operator=(const Csk& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Csk& default_instance();
  void Swap(Csk* other);
  
  // implements Message ----------------------------------------------
  
  Csk* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Csk& from);
  void MergeFrom(const Csk& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 algorithm = 1;
  inline bool has_algorithm() const;
  inline void clear_algorithm();
  static const int kAlgorithmFieldNumber = 1;
  inline ::google::protobuf::uint32 algorithm() const;
  inline void set_algorithm(::google::protobuf::uint32 value);
  
  // optional uint32 bits = 2;
  inline bool has_bits() const;
  inline void clear_bits();
  static const int kBitsFieldNumber = 2;
  inline ::google::protobuf::uint32 bits() const;
  inline void set_bits(::google::protobuf::uint32 value);
  
  // required int32 lifetime = 3;
  inline bool has_lifetime() const;
  inline void clear_lifetime();
  static const int kLifetimeFieldNumber = 3;
  inline ::google::protobuf::int32 lifetime() const;
  inline void set_lifetime(::google::protobuf::int32 value);
  
  // required string repository = 4;
  inline bool has_repository() const;
  inline void clear_repository();
  static const int kRepositoryFieldNumber = 4;
  inline const ::std::string& repository() const;
  inline void set_repository(const ::std::string& value);
  inline void set_repository(const char* value);
  inline void set_repository(const char* value, size_t size);
  inline ::std::string* mutable_repository();
  
  // optional uint32 standby = 5;
  inline bool has_standby() const;
  inline void clear_standby();
  static const int kStandbyFieldNumber = 5;
  inline ::google::protobuf::uint32 standby() const;
  inline void set_standby(::google::protobuf::uint32 value);
  
  // optional bool manual_rollover = 6;
  inline bool has_manual_rollover() const;
  inline void clear_manual_rollover();
  static const int kManualRolloverFieldNumber = 6;
  inline bool manual_rollover() const;
  inline void set_manual_rollover(bool value);
  
  // optional bool rfc5011 = 7;
  inline bool has_rfc5011() const;
  inline void clear_rfc5011();
  static const int kRfc5011FieldNumber = 7;
  inline bool rfc5011() const;
  inline void set_rfc5011(bool value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 algorithm_;
  ::google::protobuf::uint32 bits_;
  ::google::protobuf::int32 lifetime_;
  ::std::string* repository_;
  static const ::std::string _default_repository_;
  ::google::protobuf::uint32 standby_;
  bool manual_rollover_;
  bool rfc5011_;
  friend void  protobuf_AddDesc_kasp_2eproto();
  friend void protobuf_AssignDesc_kasp_2eproto();
  friend void protobuf_ShutdownFile_kasp_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Csk* default_instance_;
};
// -------------------------------------------------------------------

class Zone : public ::google::protobuf::Message {
 public:
  Zone();
  virtual ~Zone();
  
  Zone(const Zone& from);
  
  inline Zone& operator=(const Zone& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Zone& default_instance();
  void Swap(Zone* other);
  
  // implements Message ----------------------------------------------
  
  Zone* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Zone& from);
  void MergeFrom(const Zone& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 propagationdelay = 1;
  inline bool has_propagationdelay() const;
  inline void clear_propagationdelay();
  static const int kPropagationdelayFieldNumber = 1;
  inline ::google::protobuf::int32 propagationdelay() const;
  inline void set_propagationdelay(::google::protobuf::int32 value);
  
  // optional int32 ttl = 2;
  inline bool has_ttl() const;
  inline void clear_ttl();
  static const int kTtlFieldNumber = 2;
  inline ::google::protobuf::int32 ttl() const;
  inline void set_ttl(::google::protobuf::int32 value);
  
  // optional int32 min = 3;
  inline bool has_min() const;
  inline void clear_min();
  static const int kMinFieldNumber = 3;
  inline ::google::protobuf::int32 min() const;
  inline void set_min(::google::protobuf::int32 value);
  
  // optional .kasp.pb.serial serial = 4;
  inline bool has_serial() const;
  inline void clear_serial();
  static const int kSerialFieldNumber = 4;
  inline kasp::pb::serial serial() const;
  inline void set_serial(kasp::pb::serial value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 propagationdelay_;
  ::google::protobuf::int32 ttl_;
  ::google::protobuf::int32 min_;
  int serial_;
  friend void  protobuf_AddDesc_kasp_2eproto();
  friend void protobuf_AssignDesc_kasp_2eproto();
  friend void protobuf_ShutdownFile_kasp_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Zone* default_instance_;
};
// -------------------------------------------------------------------

class Parent : public ::google::protobuf::Message {
 public:
  Parent();
  virtual ~Parent();
  
  Parent(const Parent& from);
  
  inline Parent& operator=(const Parent& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Parent& default_instance();
  void Swap(Parent* other);
  
  // implements Message ----------------------------------------------
  
  Parent* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Parent& from);
  void MergeFrom(const Parent& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 ttlds = 1;
  inline bool has_ttlds() const;
  inline void clear_ttlds();
  static const int kTtldsFieldNumber = 1;
  inline ::google::protobuf::int32 ttlds() const;
  inline void set_ttlds(::google::protobuf::int32 value);
  
  // optional int32 registrationdelay = 2;
  inline bool has_registrationdelay() const;
  inline void clear_registrationdelay();
  static const int kRegistrationdelayFieldNumber = 2;
  inline ::google::protobuf::int32 registrationdelay() const;
  inline void set_registrationdelay(::google::protobuf::int32 value);
  
  // optional int32 propagationdelay = 3;
  inline bool has_propagationdelay() const;
  inline void clear_propagationdelay();
  static const int kPropagationdelayFieldNumber = 3;
  inline ::google::protobuf::int32 propagationdelay() const;
  inline void set_propagationdelay(::google::protobuf::int32 value);
  
  // optional int32 ttl = 4;
  inline bool has_ttl() const;
  inline void clear_ttl();
  static const int kTtlFieldNumber = 4;
  inline ::google::protobuf::int32 ttl() const;
  inline void set_ttl(::google::protobuf::int32 value);
  
  // optional int32 min = 5;
  inline bool has_min() const;
  inline void clear_min();
  static const int kMinFieldNumber = 5;
  inline ::google::protobuf::int32 min() const;
  inline void set_min(::google::protobuf::int32 value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 ttlds_;
  ::google::protobuf::int32 registrationdelay_;
  ::google::protobuf::int32 propagationdelay_;
  ::google::protobuf::int32 ttl_;
  ::google::protobuf::int32 min_;
  friend void  protobuf_AddDesc_kasp_2eproto();
  friend void protobuf_AssignDesc_kasp_2eproto();
  friend void protobuf_ShutdownFile_kasp_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Parent* default_instance_;
};
// -------------------------------------------------------------------

class Audit : public ::google::protobuf::Message {
 public:
  Audit();
  virtual ~Audit();
  
  Audit(const Audit& from);
  
  inline Audit& operator=(const Audit& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Audit& default_instance();
  void Swap(Audit* other);
  
  // implements Message ----------------------------------------------
  
  Audit* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Audit& from);
  void MergeFrom(const Audit& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional bool partial = 1;
  inline bool has_partial() const;
  inline void clear_partial();
  static const int kPartialFieldNumber = 1;
  inline bool partial() const;
  inline void set_partial(bool value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  bool partial_;
  friend void  protobuf_AddDesc_kasp_2eproto();
  friend void protobuf_AssignDesc_kasp_2eproto();
  friend void protobuf_ShutdownFile_kasp_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Audit* default_instance_;
};
// ===================================================================


// ===================================================================


// ===================================================================

// KaspDocument

// required .kasp.pb.KASP kasp = 2;
inline bool KaspDocument::has_kasp() const {
  return _has_bit(0);
}
inline void KaspDocument::clear_kasp() {
  if (kasp_ != NULL) kasp_->::kasp::pb::KASP::Clear();
  _clear_bit(0);
}
inline const ::kasp::pb::KASP& KaspDocument::kasp() const {
  return kasp_ != NULL ? *kasp_ : *default_instance_->kasp_;
}
inline ::kasp::pb::KASP* KaspDocument::mutable_kasp() {
  _set_bit(0);
  if (kasp_ == NULL) kasp_ = new ::kasp::pb::KASP;
  return kasp_;
}

// -------------------------------------------------------------------

// KASP

// repeated .kasp.pb.Policy policies = 1;
inline int KASP::policies_size() const {
  return policies_.size();
}
inline void KASP::clear_policies() {
  policies_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::kasp::pb::Policy >&
KASP::policies() const {
  return policies_;
}
inline ::google::protobuf::RepeatedPtrField< ::kasp::pb::Policy >*
KASP::mutable_policies() {
  return &policies_;
}
inline const ::kasp::pb::Policy& KASP::policies(int index) const {
  return policies_.Get(index);
}
inline ::kasp::pb::Policy* KASP::mutable_policies(int index) {
  return policies_.Mutable(index);
}
inline ::kasp::pb::Policy* KASP::add_policies() {
  return policies_.Add();
}

// -------------------------------------------------------------------

// Policy

// required string name = 1;
inline bool Policy::has_name() const {
  return _has_bit(0);
}
inline void Policy::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& Policy::name() const {
  return *name_;
}
inline void Policy::set_name(const ::std::string& value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Policy::set_name(const char* value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Policy::set_name(const char* value, size_t size) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Policy::mutable_name() {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// required string description = 2;
inline bool Policy::has_description() const {
  return _has_bit(1);
}
inline void Policy::clear_description() {
  if (description_ != &_default_description_) {
    description_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& Policy::description() const {
  return *description_;
}
inline void Policy::set_description(const ::std::string& value) {
  _set_bit(1);
  if (description_ == &_default_description_) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void Policy::set_description(const char* value) {
  _set_bit(1);
  if (description_ == &_default_description_) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void Policy::set_description(const char* value, size_t size) {
  _set_bit(1);
  if (description_ == &_default_description_) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Policy::mutable_description() {
  _set_bit(1);
  if (description_ == &_default_description_) {
    description_ = new ::std::string;
  }
  return description_;
}

// required .kasp.pb.Signatures signatures = 3;
inline bool Policy::has_signatures() const {
  return _has_bit(2);
}
inline void Policy::clear_signatures() {
  if (signatures_ != NULL) signatures_->::kasp::pb::Signatures::Clear();
  _clear_bit(2);
}
inline const ::kasp::pb::Signatures& Policy::signatures() const {
  return signatures_ != NULL ? *signatures_ : *default_instance_->signatures_;
}
inline ::kasp::pb::Signatures* Policy::mutable_signatures() {
  _set_bit(2);
  if (signatures_ == NULL) signatures_ = new ::kasp::pb::Signatures;
  return signatures_;
}

// required .kasp.pb.Denial denial = 4;
inline bool Policy::has_denial() const {
  return _has_bit(3);
}
inline void Policy::clear_denial() {
  if (denial_ != NULL) denial_->::kasp::pb::Denial::Clear();
  _clear_bit(3);
}
inline const ::kasp::pb::Denial& Policy::denial() const {
  return denial_ != NULL ? *denial_ : *default_instance_->denial_;
}
inline ::kasp::pb::Denial* Policy::mutable_denial() {
  _set_bit(3);
  if (denial_ == NULL) denial_ = new ::kasp::pb::Denial;
  return denial_;
}

// required .kasp.pb.Keys keys = 5;
inline bool Policy::has_keys() const {
  return _has_bit(4);
}
inline void Policy::clear_keys() {
  if (keys_ != NULL) keys_->::kasp::pb::Keys::Clear();
  _clear_bit(4);
}
inline const ::kasp::pb::Keys& Policy::keys() const {
  return keys_ != NULL ? *keys_ : *default_instance_->keys_;
}
inline ::kasp::pb::Keys* Policy::mutable_keys() {
  _set_bit(4);
  if (keys_ == NULL) keys_ = new ::kasp::pb::Keys;
  return keys_;
}

// required .kasp.pb.Zone zone = 6;
inline bool Policy::has_zone() const {
  return _has_bit(5);
}
inline void Policy::clear_zone() {
  if (zone_ != NULL) zone_->::kasp::pb::Zone::Clear();
  _clear_bit(5);
}
inline const ::kasp::pb::Zone& Policy::zone() const {
  return zone_ != NULL ? *zone_ : *default_instance_->zone_;
}
inline ::kasp::pb::Zone* Policy::mutable_zone() {
  _set_bit(5);
  if (zone_ == NULL) zone_ = new ::kasp::pb::Zone;
  return zone_;
}

// required .kasp.pb.Parent parent = 7;
inline bool Policy::has_parent() const {
  return _has_bit(6);
}
inline void Policy::clear_parent() {
  if (parent_ != NULL) parent_->::kasp::pb::Parent::Clear();
  _clear_bit(6);
}
inline const ::kasp::pb::Parent& Policy::parent() const {
  return parent_ != NULL ? *parent_ : *default_instance_->parent_;
}
inline ::kasp::pb::Parent* Policy::mutable_parent() {
  _set_bit(6);
  if (parent_ == NULL) parent_ = new ::kasp::pb::Parent;
  return parent_;
}

// repeated .kasp.pb.Audit audit = 8;
inline int Policy::audit_size() const {
  return audit_.size();
}
inline void Policy::clear_audit() {
  audit_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::kasp::pb::Audit >&
Policy::audit() const {
  return audit_;
}
inline ::google::protobuf::RepeatedPtrField< ::kasp::pb::Audit >*
Policy::mutable_audit() {
  return &audit_;
}
inline const ::kasp::pb::Audit& Policy::audit(int index) const {
  return audit_.Get(index);
}
inline ::kasp::pb::Audit* Policy::mutable_audit(int index) {
  return audit_.Mutable(index);
}
inline ::kasp::pb::Audit* Policy::add_audit() {
  return audit_.Add();
}

// -------------------------------------------------------------------

// Signatures

// optional int32 resign = 1;
inline bool Signatures::has_resign() const {
  return _has_bit(0);
}
inline void Signatures::clear_resign() {
  resign_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 Signatures::resign() const {
  return resign_;
}
inline void Signatures::set_resign(::google::protobuf::int32 value) {
  _set_bit(0);
  resign_ = value;
}

// optional int32 refresh = 2;
inline bool Signatures::has_refresh() const {
  return _has_bit(1);
}
inline void Signatures::clear_refresh() {
  refresh_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 Signatures::refresh() const {
  return refresh_;
}
inline void Signatures::set_refresh(::google::protobuf::int32 value) {
  _set_bit(1);
  refresh_ = value;
}

// optional int32 jitter = 3;
inline bool Signatures::has_jitter() const {
  return _has_bit(2);
}
inline void Signatures::clear_jitter() {
  jitter_ = 0;
  _clear_bit(2);
}
inline ::google::protobuf::int32 Signatures::jitter() const {
  return jitter_;
}
inline void Signatures::set_jitter(::google::protobuf::int32 value) {
  _set_bit(2);
  jitter_ = value;
}

// optional int32 inceptionOffset = 4;
inline bool Signatures::has_inceptionoffset() const {
  return _has_bit(3);
}
inline void Signatures::clear_inceptionoffset() {
  inceptionoffset_ = 0;
  _clear_bit(3);
}
inline ::google::protobuf::int32 Signatures::inceptionoffset() const {
  return inceptionoffset_;
}
inline void Signatures::set_inceptionoffset(::google::protobuf::int32 value) {
  _set_bit(3);
  inceptionoffset_ = value;
}

// optional int32 ttl = 5;
inline bool Signatures::has_ttl() const {
  return _has_bit(4);
}
inline void Signatures::clear_ttl() {
  ttl_ = 0;
  _clear_bit(4);
}
inline ::google::protobuf::int32 Signatures::ttl() const {
  return ttl_;
}
inline void Signatures::set_ttl(::google::protobuf::int32 value) {
  _set_bit(4);
  ttl_ = value;
}

// optional int32 valdefault = 6;
inline bool Signatures::has_valdefault() const {
  return _has_bit(5);
}
inline void Signatures::clear_valdefault() {
  valdefault_ = 0;
  _clear_bit(5);
}
inline ::google::protobuf::int32 Signatures::valdefault() const {
  return valdefault_;
}
inline void Signatures::set_valdefault(::google::protobuf::int32 value) {
  _set_bit(5);
  valdefault_ = value;
}

// optional int32 valdenial = 7;
inline bool Signatures::has_valdenial() const {
  return _has_bit(6);
}
inline void Signatures::clear_valdenial() {
  valdenial_ = 0;
  _clear_bit(6);
}
inline ::google::protobuf::int32 Signatures::valdenial() const {
  return valdenial_;
}
inline void Signatures::set_valdenial(::google::protobuf::int32 value) {
  _set_bit(6);
  valdenial_ = value;
}

// -------------------------------------------------------------------

// Denial

// optional .kasp.pb.NSEC nsec = 1;
inline bool Denial::has_nsec() const {
  return _has_bit(0);
}
inline void Denial::clear_nsec() {
  if (nsec_ != NULL) nsec_->::kasp::pb::NSEC::Clear();
  _clear_bit(0);
}
inline const ::kasp::pb::NSEC& Denial::nsec() const {
  return nsec_ != NULL ? *nsec_ : *default_instance_->nsec_;
}
inline ::kasp::pb::NSEC* Denial::mutable_nsec() {
  _set_bit(0);
  if (nsec_ == NULL) nsec_ = new ::kasp::pb::NSEC;
  return nsec_;
}

// optional .kasp.pb.NSEC3 nsec3 = 2;
inline bool Denial::has_nsec3() const {
  return _has_bit(1);
}
inline void Denial::clear_nsec3() {
  if (nsec3_ != NULL) nsec3_->::kasp::pb::NSEC3::Clear();
  _clear_bit(1);
}
inline const ::kasp::pb::NSEC3& Denial::nsec3() const {
  return nsec3_ != NULL ? *nsec3_ : *default_instance_->nsec3_;
}
inline ::kasp::pb::NSEC3* Denial::mutable_nsec3() {
  _set_bit(1);
  if (nsec3_ == NULL) nsec3_ = new ::kasp::pb::NSEC3;
  return nsec3_;
}

// -------------------------------------------------------------------

// NSEC

// -------------------------------------------------------------------

// NSEC3

// optional bool optout = 1;
inline bool NSEC3::has_optout() const {
  return _has_bit(0);
}
inline void NSEC3::clear_optout() {
  optout_ = false;
  _clear_bit(0);
}
inline bool NSEC3::optout() const {
  return optout_;
}
inline void NSEC3::set_optout(bool value) {
  _set_bit(0);
  optout_ = value;
}

// optional int32 ttl = 2;
inline bool NSEC3::has_ttl() const {
  return _has_bit(1);
}
inline void NSEC3::clear_ttl() {
  ttl_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 NSEC3::ttl() const {
  return ttl_;
}
inline void NSEC3::set_ttl(::google::protobuf::int32 value) {
  _set_bit(1);
  ttl_ = value;
}

// required int32 resalt = 3;
inline bool NSEC3::has_resalt() const {
  return _has_bit(2);
}
inline void NSEC3::clear_resalt() {
  resalt_ = 0;
  _clear_bit(2);
}
inline ::google::protobuf::int32 NSEC3::resalt() const {
  return resalt_;
}
inline void NSEC3::set_resalt(::google::protobuf::int32 value) {
  _set_bit(2);
  resalt_ = value;
}

// required int32 algorithm = 4;
inline bool NSEC3::has_algorithm() const {
  return _has_bit(3);
}
inline void NSEC3::clear_algorithm() {
  algorithm_ = 0;
  _clear_bit(3);
}
inline ::google::protobuf::int32 NSEC3::algorithm() const {
  return algorithm_;
}
inline void NSEC3::set_algorithm(::google::protobuf::int32 value) {
  _set_bit(3);
  algorithm_ = value;
}

// required int32 iterations = 5;
inline bool NSEC3::has_iterations() const {
  return _has_bit(4);
}
inline void NSEC3::clear_iterations() {
  iterations_ = 0;
  _clear_bit(4);
}
inline ::google::protobuf::int32 NSEC3::iterations() const {
  return iterations_;
}
inline void NSEC3::set_iterations(::google::protobuf::int32 value) {
  _set_bit(4);
  iterations_ = value;
}

// required int32 saltlength = 6;
inline bool NSEC3::has_saltlength() const {
  return _has_bit(5);
}
inline void NSEC3::clear_saltlength() {
  saltlength_ = 0;
  _clear_bit(5);
}
inline ::google::protobuf::int32 NSEC3::saltlength() const {
  return saltlength_;
}
inline void NSEC3::set_saltlength(::google::protobuf::int32 value) {
  _set_bit(5);
  saltlength_ = value;
}

// optional string salt = 7;
inline bool NSEC3::has_salt() const {
  return _has_bit(6);
}
inline void NSEC3::clear_salt() {
  if (salt_ != &_default_salt_) {
    salt_->clear();
  }
  _clear_bit(6);
}
inline const ::std::string& NSEC3::salt() const {
  return *salt_;
}
inline void NSEC3::set_salt(const ::std::string& value) {
  _set_bit(6);
  if (salt_ == &_default_salt_) {
    salt_ = new ::std::string;
  }
  salt_->assign(value);
}
inline void NSEC3::set_salt(const char* value) {
  _set_bit(6);
  if (salt_ == &_default_salt_) {
    salt_ = new ::std::string;
  }
  salt_->assign(value);
}
inline void NSEC3::set_salt(const char* value, size_t size) {
  _set_bit(6);
  if (salt_ == &_default_salt_) {
    salt_ = new ::std::string;
  }
  salt_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NSEC3::mutable_salt() {
  _set_bit(6);
  if (salt_ == &_default_salt_) {
    salt_ = new ::std::string;
  }
  return salt_;
}

// -------------------------------------------------------------------

// Keys

// required int32 ttl = 1;
inline bool Keys::has_ttl() const {
  return _has_bit(0);
}
inline void Keys::clear_ttl() {
  ttl_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 Keys::ttl() const {
  return ttl_;
}
inline void Keys::set_ttl(::google::protobuf::int32 value) {
  _set_bit(0);
  ttl_ = value;
}

// required int32 retiresafety = 2;
inline bool Keys::has_retiresafety() const {
  return _has_bit(1);
}
inline void Keys::clear_retiresafety() {
  retiresafety_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 Keys::retiresafety() const {
  return retiresafety_;
}
inline void Keys::set_retiresafety(::google::protobuf::int32 value) {
  _set_bit(1);
  retiresafety_ = value;
}

// required int32 publishsafety = 3;
inline bool Keys::has_publishsafety() const {
  return _has_bit(2);
}
inline void Keys::clear_publishsafety() {
  publishsafety_ = 0;
  _clear_bit(2);
}
inline ::google::protobuf::int32 Keys::publishsafety() const {
  return publishsafety_;
}
inline void Keys::set_publishsafety(::google::protobuf::int32 value) {
  _set_bit(2);
  publishsafety_ = value;
}

// optional bool zones_share_keys = 4;
inline bool Keys::has_zones_share_keys() const {
  return _has_bit(3);
}
inline void Keys::clear_zones_share_keys() {
  zones_share_keys_ = false;
  _clear_bit(3);
}
inline bool Keys::zones_share_keys() const {
  return zones_share_keys_;
}
inline void Keys::set_zones_share_keys(bool value) {
  _set_bit(3);
  zones_share_keys_ = value;
}

// optional int32 purge = 5;
inline bool Keys::has_purge() const {
  return _has_bit(4);
}
inline void Keys::clear_purge() {
  purge_ = 0;
  _clear_bit(4);
}
inline ::google::protobuf::int32 Keys::purge() const {
  return purge_;
}
inline void Keys::set_purge(::google::protobuf::int32 value) {
  _set_bit(4);
  purge_ = value;
}

// repeated .kasp.pb.Ksk ksk = 6;
inline int Keys::ksk_size() const {
  return ksk_.size();
}
inline void Keys::clear_ksk() {
  ksk_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::kasp::pb::Ksk >&
Keys::ksk() const {
  return ksk_;
}
inline ::google::protobuf::RepeatedPtrField< ::kasp::pb::Ksk >*
Keys::mutable_ksk() {
  return &ksk_;
}
inline const ::kasp::pb::Ksk& Keys::ksk(int index) const {
  return ksk_.Get(index);
}
inline ::kasp::pb::Ksk* Keys::mutable_ksk(int index) {
  return ksk_.Mutable(index);
}
inline ::kasp::pb::Ksk* Keys::add_ksk() {
  return ksk_.Add();
}

// repeated .kasp.pb.Zsk zsk = 7;
inline int Keys::zsk_size() const {
  return zsk_.size();
}
inline void Keys::clear_zsk() {
  zsk_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::kasp::pb::Zsk >&
Keys::zsk() const {
  return zsk_;
}
inline ::google::protobuf::RepeatedPtrField< ::kasp::pb::Zsk >*
Keys::mutable_zsk() {
  return &zsk_;
}
inline const ::kasp::pb::Zsk& Keys::zsk(int index) const {
  return zsk_.Get(index);
}
inline ::kasp::pb::Zsk* Keys::mutable_zsk(int index) {
  return zsk_.Mutable(index);
}
inline ::kasp::pb::Zsk* Keys::add_zsk() {
  return zsk_.Add();
}

// repeated .kasp.pb.Csk csk = 8;
inline int Keys::csk_size() const {
  return csk_.size();
}
inline void Keys::clear_csk() {
  csk_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::kasp::pb::Csk >&
Keys::csk() const {
  return csk_;
}
inline ::google::protobuf::RepeatedPtrField< ::kasp::pb::Csk >*
Keys::mutable_csk() {
  return &csk_;
}
inline const ::kasp::pb::Csk& Keys::csk(int index) const {
  return csk_.Get(index);
}
inline ::kasp::pb::Csk* Keys::mutable_csk(int index) {
  return csk_.Mutable(index);
}
inline ::kasp::pb::Csk* Keys::add_csk() {
  return csk_.Add();
}

// -------------------------------------------------------------------

// Ksk

// required uint32 algorithm = 1;
inline bool Ksk::has_algorithm() const {
  return _has_bit(0);
}
inline void Ksk::clear_algorithm() {
  algorithm_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 Ksk::algorithm() const {
  return algorithm_;
}
inline void Ksk::set_algorithm(::google::protobuf::uint32 value) {
  _set_bit(0);
  algorithm_ = value;
}

// optional uint32 bits = 2;
inline bool Ksk::has_bits() const {
  return _has_bit(1);
}
inline void Ksk::clear_bits() {
  bits_ = 0u;
  _clear_bit(1);
}
inline ::google::protobuf::uint32 Ksk::bits() const {
  return bits_;
}
inline void Ksk::set_bits(::google::protobuf::uint32 value) {
  _set_bit(1);
  bits_ = value;
}

// required int32 lifetime = 3;
inline bool Ksk::has_lifetime() const {
  return _has_bit(2);
}
inline void Ksk::clear_lifetime() {
  lifetime_ = 0;
  _clear_bit(2);
}
inline ::google::protobuf::int32 Ksk::lifetime() const {
  return lifetime_;
}
inline void Ksk::set_lifetime(::google::protobuf::int32 value) {
  _set_bit(2);
  lifetime_ = value;
}

// required string repository = 4;
inline bool Ksk::has_repository() const {
  return _has_bit(3);
}
inline void Ksk::clear_repository() {
  if (repository_ != &_default_repository_) {
    repository_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& Ksk::repository() const {
  return *repository_;
}
inline void Ksk::set_repository(const ::std::string& value) {
  _set_bit(3);
  if (repository_ == &_default_repository_) {
    repository_ = new ::std::string;
  }
  repository_->assign(value);
}
inline void Ksk::set_repository(const char* value) {
  _set_bit(3);
  if (repository_ == &_default_repository_) {
    repository_ = new ::std::string;
  }
  repository_->assign(value);
}
inline void Ksk::set_repository(const char* value, size_t size) {
  _set_bit(3);
  if (repository_ == &_default_repository_) {
    repository_ = new ::std::string;
  }
  repository_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Ksk::mutable_repository() {
  _set_bit(3);
  if (repository_ == &_default_repository_) {
    repository_ = new ::std::string;
  }
  return repository_;
}

// optional uint32 standby = 5;
inline bool Ksk::has_standby() const {
  return _has_bit(4);
}
inline void Ksk::clear_standby() {
  standby_ = 0u;
  _clear_bit(4);
}
inline ::google::protobuf::uint32 Ksk::standby() const {
  return standby_;
}
inline void Ksk::set_standby(::google::protobuf::uint32 value) {
  _set_bit(4);
  standby_ = value;
}

// optional bool manual_rollover = 6;
inline bool Ksk::has_manual_rollover() const {
  return _has_bit(5);
}
inline void Ksk::clear_manual_rollover() {
  manual_rollover_ = false;
  _clear_bit(5);
}
inline bool Ksk::manual_rollover() const {
  return manual_rollover_;
}
inline void Ksk::set_manual_rollover(bool value) {
  _set_bit(5);
  manual_rollover_ = value;
}

// optional bool rfc5011 = 7;
inline bool Ksk::has_rfc5011() const {
  return _has_bit(6);
}
inline void Ksk::clear_rfc5011() {
  rfc5011_ = false;
  _clear_bit(6);
}
inline bool Ksk::rfc5011() const {
  return rfc5011_;
}
inline void Ksk::set_rfc5011(bool value) {
  _set_bit(6);
  rfc5011_ = value;
}

// -------------------------------------------------------------------

// Zsk

// required uint32 algorithm = 1;
inline bool Zsk::has_algorithm() const {
  return _has_bit(0);
}
inline void Zsk::clear_algorithm() {
  algorithm_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 Zsk::algorithm() const {
  return algorithm_;
}
inline void Zsk::set_algorithm(::google::protobuf::uint32 value) {
  _set_bit(0);
  algorithm_ = value;
}

// optional uint32 bits = 2;
inline bool Zsk::has_bits() const {
  return _has_bit(1);
}
inline void Zsk::clear_bits() {
  bits_ = 0u;
  _clear_bit(1);
}
inline ::google::protobuf::uint32 Zsk::bits() const {
  return bits_;
}
inline void Zsk::set_bits(::google::protobuf::uint32 value) {
  _set_bit(1);
  bits_ = value;
}

// required int32 lifetime = 3;
inline bool Zsk::has_lifetime() const {
  return _has_bit(2);
}
inline void Zsk::clear_lifetime() {
  lifetime_ = 0;
  _clear_bit(2);
}
inline ::google::protobuf::int32 Zsk::lifetime() const {
  return lifetime_;
}
inline void Zsk::set_lifetime(::google::protobuf::int32 value) {
  _set_bit(2);
  lifetime_ = value;
}

// required string repository = 4;
inline bool Zsk::has_repository() const {
  return _has_bit(3);
}
inline void Zsk::clear_repository() {
  if (repository_ != &_default_repository_) {
    repository_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& Zsk::repository() const {
  return *repository_;
}
inline void Zsk::set_repository(const ::std::string& value) {
  _set_bit(3);
  if (repository_ == &_default_repository_) {
    repository_ = new ::std::string;
  }
  repository_->assign(value);
}
inline void Zsk::set_repository(const char* value) {
  _set_bit(3);
  if (repository_ == &_default_repository_) {
    repository_ = new ::std::string;
  }
  repository_->assign(value);
}
inline void Zsk::set_repository(const char* value, size_t size) {
  _set_bit(3);
  if (repository_ == &_default_repository_) {
    repository_ = new ::std::string;
  }
  repository_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Zsk::mutable_repository() {
  _set_bit(3);
  if (repository_ == &_default_repository_) {
    repository_ = new ::std::string;
  }
  return repository_;
}

// optional uint32 standby = 5;
inline bool Zsk::has_standby() const {
  return _has_bit(4);
}
inline void Zsk::clear_standby() {
  standby_ = 0u;
  _clear_bit(4);
}
inline ::google::protobuf::uint32 Zsk::standby() const {
  return standby_;
}
inline void Zsk::set_standby(::google::protobuf::uint32 value) {
  _set_bit(4);
  standby_ = value;
}

// optional bool manual_rollover = 6;
inline bool Zsk::has_manual_rollover() const {
  return _has_bit(5);
}
inline void Zsk::clear_manual_rollover() {
  manual_rollover_ = false;
  _clear_bit(5);
}
inline bool Zsk::manual_rollover() const {
  return manual_rollover_;
}
inline void Zsk::set_manual_rollover(bool value) {
  _set_bit(5);
  manual_rollover_ = value;
}

// -------------------------------------------------------------------

// Csk

// required uint32 algorithm = 1;
inline bool Csk::has_algorithm() const {
  return _has_bit(0);
}
inline void Csk::clear_algorithm() {
  algorithm_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 Csk::algorithm() const {
  return algorithm_;
}
inline void Csk::set_algorithm(::google::protobuf::uint32 value) {
  _set_bit(0);
  algorithm_ = value;
}

// optional uint32 bits = 2;
inline bool Csk::has_bits() const {
  return _has_bit(1);
}
inline void Csk::clear_bits() {
  bits_ = 0u;
  _clear_bit(1);
}
inline ::google::protobuf::uint32 Csk::bits() const {
  return bits_;
}
inline void Csk::set_bits(::google::protobuf::uint32 value) {
  _set_bit(1);
  bits_ = value;
}

// required int32 lifetime = 3;
inline bool Csk::has_lifetime() const {
  return _has_bit(2);
}
inline void Csk::clear_lifetime() {
  lifetime_ = 0;
  _clear_bit(2);
}
inline ::google::protobuf::int32 Csk::lifetime() const {
  return lifetime_;
}
inline void Csk::set_lifetime(::google::protobuf::int32 value) {
  _set_bit(2);
  lifetime_ = value;
}

// required string repository = 4;
inline bool Csk::has_repository() const {
  return _has_bit(3);
}
inline void Csk::clear_repository() {
  if (repository_ != &_default_repository_) {
    repository_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& Csk::repository() const {
  return *repository_;
}
inline void Csk::set_repository(const ::std::string& value) {
  _set_bit(3);
  if (repository_ == &_default_repository_) {
    repository_ = new ::std::string;
  }
  repository_->assign(value);
}
inline void Csk::set_repository(const char* value) {
  _set_bit(3);
  if (repository_ == &_default_repository_) {
    repository_ = new ::std::string;
  }
  repository_->assign(value);
}
inline void Csk::set_repository(const char* value, size_t size) {
  _set_bit(3);
  if (repository_ == &_default_repository_) {
    repository_ = new ::std::string;
  }
  repository_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Csk::mutable_repository() {
  _set_bit(3);
  if (repository_ == &_default_repository_) {
    repository_ = new ::std::string;
  }
  return repository_;
}

// optional uint32 standby = 5;
inline bool Csk::has_standby() const {
  return _has_bit(4);
}
inline void Csk::clear_standby() {
  standby_ = 0u;
  _clear_bit(4);
}
inline ::google::protobuf::uint32 Csk::standby() const {
  return standby_;
}
inline void Csk::set_standby(::google::protobuf::uint32 value) {
  _set_bit(4);
  standby_ = value;
}

// optional bool manual_rollover = 6;
inline bool Csk::has_manual_rollover() const {
  return _has_bit(5);
}
inline void Csk::clear_manual_rollover() {
  manual_rollover_ = false;
  _clear_bit(5);
}
inline bool Csk::manual_rollover() const {
  return manual_rollover_;
}
inline void Csk::set_manual_rollover(bool value) {
  _set_bit(5);
  manual_rollover_ = value;
}

// optional bool rfc5011 = 7;
inline bool Csk::has_rfc5011() const {
  return _has_bit(6);
}
inline void Csk::clear_rfc5011() {
  rfc5011_ = false;
  _clear_bit(6);
}
inline bool Csk::rfc5011() const {
  return rfc5011_;
}
inline void Csk::set_rfc5011(bool value) {
  _set_bit(6);
  rfc5011_ = value;
}

// -------------------------------------------------------------------

// Zone

// required int32 propagationdelay = 1;
inline bool Zone::has_propagationdelay() const {
  return _has_bit(0);
}
inline void Zone::clear_propagationdelay() {
  propagationdelay_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 Zone::propagationdelay() const {
  return propagationdelay_;
}
inline void Zone::set_propagationdelay(::google::protobuf::int32 value) {
  _set_bit(0);
  propagationdelay_ = value;
}

// optional int32 ttl = 2;
inline bool Zone::has_ttl() const {
  return _has_bit(1);
}
inline void Zone::clear_ttl() {
  ttl_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 Zone::ttl() const {
  return ttl_;
}
inline void Zone::set_ttl(::google::protobuf::int32 value) {
  _set_bit(1);
  ttl_ = value;
}

// optional int32 min = 3;
inline bool Zone::has_min() const {
  return _has_bit(2);
}
inline void Zone::clear_min() {
  min_ = 0;
  _clear_bit(2);
}
inline ::google::protobuf::int32 Zone::min() const {
  return min_;
}
inline void Zone::set_min(::google::protobuf::int32 value) {
  _set_bit(2);
  min_ = value;
}

// optional .kasp.pb.serial serial = 4;
inline bool Zone::has_serial() const {
  return _has_bit(3);
}
inline void Zone::clear_serial() {
  serial_ = 1;
  _clear_bit(3);
}
inline kasp::pb::serial Zone::serial() const {
  return static_cast< kasp::pb::serial >(serial_);
}
inline void Zone::set_serial(kasp::pb::serial value) {
  GOOGLE_DCHECK(kasp::pb::serial_IsValid(value));
  _set_bit(3);
  serial_ = value;
}

// -------------------------------------------------------------------

// Parent

// optional int32 ttlds = 1;
inline bool Parent::has_ttlds() const {
  return _has_bit(0);
}
inline void Parent::clear_ttlds() {
  ttlds_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 Parent::ttlds() const {
  return ttlds_;
}
inline void Parent::set_ttlds(::google::protobuf::int32 value) {
  _set_bit(0);
  ttlds_ = value;
}

// optional int32 registrationdelay = 2;
inline bool Parent::has_registrationdelay() const {
  return _has_bit(1);
}
inline void Parent::clear_registrationdelay() {
  registrationdelay_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 Parent::registrationdelay() const {
  return registrationdelay_;
}
inline void Parent::set_registrationdelay(::google::protobuf::int32 value) {
  _set_bit(1);
  registrationdelay_ = value;
}

// optional int32 propagationdelay = 3;
inline bool Parent::has_propagationdelay() const {
  return _has_bit(2);
}
inline void Parent::clear_propagationdelay() {
  propagationdelay_ = 0;
  _clear_bit(2);
}
inline ::google::protobuf::int32 Parent::propagationdelay() const {
  return propagationdelay_;
}
inline void Parent::set_propagationdelay(::google::protobuf::int32 value) {
  _set_bit(2);
  propagationdelay_ = value;
}

// optional int32 ttl = 4;
inline bool Parent::has_ttl() const {
  return _has_bit(3);
}
inline void Parent::clear_ttl() {
  ttl_ = 0;
  _clear_bit(3);
}
inline ::google::protobuf::int32 Parent::ttl() const {
  return ttl_;
}
inline void Parent::set_ttl(::google::protobuf::int32 value) {
  _set_bit(3);
  ttl_ = value;
}

// optional int32 min = 5;
inline bool Parent::has_min() const {
  return _has_bit(4);
}
inline void Parent::clear_min() {
  min_ = 0;
  _clear_bit(4);
}
inline ::google::protobuf::int32 Parent::min() const {
  return min_;
}
inline void Parent::set_min(::google::protobuf::int32 value) {
  _set_bit(4);
  min_ = value;
}

// -------------------------------------------------------------------

// Audit

// optional bool partial = 1;
inline bool Audit::has_partial() const {
  return _has_bit(0);
}
inline void Audit::clear_partial() {
  partial_ = false;
  _clear_bit(0);
}
inline bool Audit::partial() const {
  return partial_;
}
inline void Audit::set_partial(bool value) {
  _set_bit(0);
  partial_ = value;
}


}  // namespace pb
}  // namespace kasp

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< kasp::pb::serial>() {
  return kasp::pb::serial_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

#endif  // PROTOBUF_kasp_2eproto__INCLUDED
