# $Id$

datatypes xsd = "http://www.w3.org/2001/XMLSchema-datatypes"

start = element kasp {

	# Parameters about the key rollover procedure itself
	# Applies to all policies
	element rollover {
		# Interval between runs of the key rollover procedure
		element interval { xsd:duration }
	},

	element policy {
		attribute name { xsd:string },
		element description { xsd:string },

		# signatures: hold parameters related to signatures
		# These will go in the signature category in the DB
		# Most of these will be passed to the signer without
		# processing
		element signatures {
			# how often should the zone be (re)signed?
			element reSign { xsd:duration },

			# how often should existing signatures be refreshed?
			element refresh { xsd:duration },

			# for how long should we sign?
			element validity {
				element default { xsd:duration },
				element denial { xsd:duration }
			},

			# how much should we jitter the signature expiration time?
			# (e.g. decrease the expiration time by X)
			element jitter { xsd:duration },

			# how much should we predate the signature inception time?
			element clockskew { xsd:duration },

			# TTL for RRSIGs
			ttl
		},

		element denial {
			# TTL for authenticated denial of existence?
			ttl,

			# use NSEC or NSEC3?
			(nsec | nsec3)
		},

		element keys {
			# TTL for DNSKEYs
			ttl,

			# key retirement safety factor
			element retireSafety { xsd:duration },

			# key publication safety factor
			element publishSafety { xsd:duration },

			element ksk {
				# generic key policy, see below
				anykey,

				# use RFC 5011 for key rollover?
				element rfc5011 { empty }?
			}*,

			element zsk {
				# generic key policy, see below
				anykey
			}*
		},

		# Parameters for the SOA that the key rollover uses
		# Really these should come from the registry system
		# that builds the unsigned zone.
		# But they have to get here somehow...
		soa,

		# Parameters about the nameserver infrastructure that serves these zones
		# NOTE: This assumes that all zones with the same policy have the
		# same nameservers or at least nameservers with the same parameters!
		element nameservers {
			# Propagation delay between nameservers
			propagationDelay
		},

		# Parameters about the parent that rollover needs to know
		# These might be guesses or obtained by querying the parent zone
		# NOTE: This assumes that all zones with the same policy have
		# the same parent or at least parents with the same parameters!
		element parent {
			# TTL of DS in parent (informational)
			element TTLds { xsd:duration },

			# Time between submitting a DS to the parent and its publication
			element dsDelay { xsd:duration },

			# Propagation delay in the parent
			propagationDelay,

			# Parents SOA
			soa
		}
	}+,

	element zone {
		attribute name { xsd:string },
		attribute policy { xsd:string },
		empty
	}*
  }

nsec = element nsec { empty }

nsec3 = element nsec3 {
	# use global NSEC3 opt-out?
	element optOut { empty }?,

	# how often should we resalt?
	# (e.g. create new NSEC3 chains)
	element reSalt { xsd:duration },

	# NSEC3 hash parameters
	element hash {
		element algorithm { xsd:positiveInteger },
		element iterations { xsd:positiveInteger },
		element salt {
			attribute length { xsd:positiveInteger },
			  # The actual salt is generated by the Enforcer
			  # Note: the enforcer may decide to store the 
			  # current salt in the DB and so it could be exported
			  # here.
     		xsd:string?
		}
	}
  }

soa = element soa {
		ttl,
		element min { xsd:duration }
	}

anykey = element algorithm {
		attribute length { xsd:positiveInteger }?,
		xsd:positiveInteger
	},
	element lifetime { xsd:duration },
	element repository { xsd:string },

	# Number of emergency keys
	# For KSKs you can use 1 to indicate that you are
	# doing double signatures
	element emergency { xsd:positiveInteger }

ttl = element ttl { xsd:duration }

propagationDelay = element propagationDelay { xsd:duration }
