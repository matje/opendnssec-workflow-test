# $Id$

datatypes xsd = "http://www.w3.org/2001/XMLSchema-datatypes"

start = element KASP {

	# Parameters about the KASP Enforcer itself
	# Applies to all policies
	element Enforcer {
		# Interval between runs of the key rollover procedure
		element Interval { xsd:duration },

		# Interval between runs of the key pre-generation procedure
		element KeygenInterval { xsd:duration },

		# Interval between runs of the key backup procedure
		element BackupDelay { xsd:duration }
	},

	element Policy {
		attribute name { xsd:string },
		element Description { xsd:string },

		# signatures: hold parameters related to signatures
		# These will go in the signature category in the DB
		# Most of these will be passed to the signer without
		# processing
		element Signatures {
			# how often should the zone be (re)signed?
			element Resign { xsd:duration },

			# how often should existing signatures be refreshed?
			element Refresh { xsd:duration },

			# for how long should we sign?
			element Validity {
				element Default { xsd:duration },
				element Denial { xsd:duration }
			},

			# how much should we jitter the signature expiration time?
			# (e.g. decrease the expiration time by X)
			element Jitter { xsd:duration },

			# how much should we predate the signature inception time?
			element InceptionOffset { xsd:duration }
		},

		element Denial {
			# use NSEC or NSEC3?
			(nsec | nsec3)
		},

		element Keys {
			# TTL for DNSKEYs
			ttl,

			# key retirement safety factor
			element RetireSafety { xsd:duration },

			# key publication safety factor
			element PublishSafety { xsd:duration },

			element KSK {
				# generic key policy, see below
				anykey,

				# use RFC 5011 for key rollover?
				element RFC5011 { empty }?
			}*,

			element ZSK {
				# generic key policy, see below
				anykey
			}*
		},

		element Zone {
			# Expected propagation delay in child publication
			propagationdelay,

			# Expected zone SOA parameters
			element SOA {
				anysoa,
				element Serial { "counter" | "unixtime" | "datecounter" }?
			}
		},

		# Excepted paren parameters for key rollover usage.
		# These might be guess or obtained by querying the parent zone
		# NOTE: This assumes that all zones with the same policy have
		# the same parent or at least parents with the same parameters!
		element Parent {
			# Expected propagation delay in parent publication
			propagationdelay,

			# Expected TTL of DS in parent
			element DS { ttl },

			# Expected parent SOA parameters
			element SOA { anysoa }
		}
	}+
}

nsec = element NSEC { empty }

nsec3 = element NSEC3 {
	# use global NSEC3 opt-out?
	element OptOut { empty }?,

	# how often should we resalt?
	# (e.g. create new NSEC3 chains)
	element Resalt { xsd:duration },

	# NSEC3 parameters
	element Parameters {
		# NSEC3PARAMS TTL
		ttl
	},

	# NSEC3 hash parameters
	element Hash {
		element Algorithm { xsd:positiveInteger },
		element Iterations { xsd:positiveInteger },
		element Salt {
			attribute length { xsd:positiveInteger },

			# The actual salt is generated by the Enforcer
			# Note: the enforcer may decide to store the
			# current salt in the DB and so it could be exported
			# here.
			xsd:string?
		}
	}
}

anysoa = ttl, element Minimum { xsd:duration }

anykey = element Algorithm {
		attribute length { xsd:positiveInteger }?,
		xsd:positiveInteger
	},
	element Lifetime { xsd:duration },
	element Repository { xsd:string },

	# Number of emergency keys
	# For KSKs you can use 1 to indicate that you are
	# doing double signatures
	element Emergency { xsd:positiveInteger }

ttl = element TTL { xsd:duration }

propagationdelay = element PropagationDelay { xsd:duration }
