\documentclass[twoside, a4paper]{article}
\usepackage{graphicx}
\usepackage{amssymb,amsmath}
\usepackage[english]{babel}
\usepackage{multirow}

\usepackage{algorithmic}
\usepackage{algorithm}

\usepackage{color}
\definecolor{MinSig}{RGB}{255,163,53}
\definecolor{Stdby}{RGB}{224,41,62}
%~ \definecolor{MinSig}{RGB}{199,154,0}
\newcommand{\highlightMinSig}[1]{\textcolor{MinSig}{\bf{#1}}}
\newcommand{\highlightStandby}[1]{\textcolor{Stdby}{\bf{#1}}}

%~ \newcommand{\mathbox}[1]{\fbox{\begin{minipage}{\linewidth}#1\end{minipage}}}
\newcommand{\mathbox}[1]{#1}

\title{\textsc{Dnssec} Key State Transitions}
\author{Yuri Schaeffer, Yuri@NLnetLabs.nl}
\date{\today}

\begin{document}
\maketitle

%~ \section{Warning}
%~ This document is a rough explanation of an idea. It is based on earlier
%~ work and may use but not introduce terminology of an other document. 
%~ Possibly introduce completely new notations, skip reasoning steps without 
%~ warning (well, you are warned now) and be plain wrong. This document is considered unsuitable
%~ for young children and Liberal-Arts majors. Read at OWN RISK.
%~ 
%~ \tableofcontents

\section{Introduction}

A key roll-over is a process that runs over time, at any time each 
key has a state. Matthijs Mekking introduced the idea that a key has 
a private part, a public part, and a parent part. Each of these 
parts have their own state-machine an together represent a 
'key-state'.

This idea forms the basis for this document. However a cache 
centered rather than a roll-over centered approach is chosen. This 
allows us to generalize much of the logic. All parts of the 
key-state now represent records which are actually published to the 
world. The state of a record tells if and how well the record is 
known to caching resolvers\footnote{ This document happely mixes the 
terms cache, resolver and validator. In all cases a DNSSEC 
validating caching resolver is meant.}. As a result each record now 
has exactly the same state machine. Furthermore instead of 3 parts 
we use 4 parts per key.

With these ingredients we can formalize the boundries of DNSSEC. We say 
a zone is in a valid DNSSEC state if a validator can build a chain of 
trust from that state. Alternatively, a unsigned zone is also considered
valid, as long as it is not bogus\footnote{Bogus: 
		The validating resolver has a trust anchor and a secure
	  delegation indicating that subsidiary data is signed, but the 
	  response fails to validate for some reason: missing 
	  signatures, expired signatures, signatures with unsupported 
	  algorithms, data missing that the relevant NSEC RR says should 
	  be present, and so forth. (RFC4033) }. In terms of end-user, 
	  if the user is able to get an address for
a name, the zone is valid. With our formal definition we can test the
current state for validity and have a precise way of deciding we can
take a transition to a next key state.

\section{Cache Centered Approach}

In a cache centered approach we do not define how rollovers should 
work exactly. The state of a key is represents how well it is know 
to \emph{any} caching validator. Either all caches have a record, no 
caches have a record, or some caches \emph{might} have it en some 
caches \emph{might not}. In the latter case we must simply wait long 
enough and the record will enter one of the certain states again. We 
will discuss the key states in section~\ref{sec:keystates}.

Each key has a goal, an internal desire to be either known to all 
caches around the world or no caches at all. A system can make any 
state transition as long as it makes sure that the validity of a 
zone in general is not compromised. This does also imply that a 
key's goal can be changed at any time without the zone going bogus. 
E.g. if a key has a desire to disappear but is the only key left it 
will stay on duty for as long as necessary. Also, new keys can be 
introduced at any time.

This approach has a number of advantages. Here, in contrast to a 
roll-over centered approach, keys have no direct relation to each 
other. The system does not try to roll from one specific key to 
another specific key but rather satisfy all goals while remaining 
valid as a whole. Essentially the roll-over is a side effect of the 
strive to satisfy key goals. New keys can be introduced and goals 
can be redefined at any time without a problem. This makes the 
system agile, robust, and capable of handling unexpected situations. 
Another advantage is that our system will `think' the same was as 
the validators we are trying to satisfy. It always knows how 
resolvers (might) see the data and makes kepping that data valid its 
core business. 

%~ key ring
%~ key states
%~ ksk vs zsk
%~ mutators (breaks)

\section{Keys}

\subsection{Keyring}

Although zones can share key material the records are published 
independently. As a result each zone must have its own collection of 
key states. Let us refer to this collection as a keyring denoted by 
$\mathbb{K}$. A Keyring and a Zone have a 1-on-1 relation.

Keys not known to any resolver can freely be added to or removed 
from the keyring. Similar, if a key is in none of the keyrings the 
key material can be purged safely from the keystorage.

\subsection{Key States} \label{sec:keystates}

The state of a key is publicly represented as a DS record, DNSKEY 
record, RRSIG DNSKEY record and the RRSIGs over all the data in the 
zone. The latter consists of multiple records but all share the same 
state, although technically incorrect we will refer to it as the 
RRSIG record.

Because each of the four records can be introduced at a different 
time and at a different pace, all need their own state machine 
(Figure~\ref{fig:statemachine}).

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.5]{statemachine.pdf}
	\caption{State diagram for individual records.}
	\label{fig:statemachine}
\end{figure}


\paragraph{Reputation} The state of a resource record is defined by 
its reputation in world's caches. There are 2 certain states, \emph
{Hidden} and \emph {Omnipresent}. In the first state a resource 
record is not available in any cache (anymore). Similarly in the 
latter state we are sure all caches have a copy of the record or can 
at least obtain it (i.e. they have no old unexpired resource record 
set).

The two other states represent uncertainty: \emph{Rumoured} and \emph
{Unretentive}. Both mean that some caches do and some don't know 
about the resource record. In the former state a record is being 
actively published and will somewhere in the future be known by all 
caches. While the latter state the record is not published (any 
longer) and will disappear from collective memory over time.

Since DNS involves caches and TTLs, it is entirely possible for a 
record being in the \emph{Rumoured} state while in fact every cache 
in the world holds the record. The problem is the uncertainty, we 
have no way to know a record is fully propagated other than waiting 
the worst case propagation time. This is also true for the \emph
{Unretentive} state.

TODO: INTRODUCE ORDENING IN STATES, SO WE CAN SAY HIDDEN $<$ RUMOURED.
THIS ALLOWS US TO TELL THE DNSKEY RRSIG NOT TO OVERTAKE THE DNSKEY.

\paragraph{Summary} A record is always in one of these four states:

\begin{itemize}
\item[\emph{Hidden}:] 		
			The record is in no cache at all.
\item[\emph{Rumoured}:] 		
			The record is published but not every cache might be aware.
\item[\emph{Omnipresent}:]
			Every cache has this record.
\item[\emph{Unretentive}:]
			The record is withdrawn but some caches might still have it.
\end{itemize} 

\paragraph{Formal definition of record states} Let $r$ be a record, 
$Anounced$ the collection of records that are actively published, 
and $\mathbb{C}$ the collection of all caches in the world. The 
states are defined by:

\begin{displaymath}
\begin{array}{lllll}
       r\in Hidden      & \equiv & \forall c \in \mathbb{C} \cdot r \not \in c \\
       r\in Rumoured    & \equiv & \exists c \in \mathbb{C} \cdot r \not \in c \wedge \exists c \in \mathbb{C} \cdot r\in c \wedge r\in Announced\\
       r\in Omnipresent & \equiv & \forall c \in \mathbb{C} \cdot r \in c \\
       r\in Unretentive & \equiv & \exists c \in \mathbb{C} \cdot r \not \in c \wedge \exists c \in \mathbb{C} \cdot r \in c \wedge r \notin Announced \\
\end{array}
\end{displaymath}

\subsection{Goal}

Each key in the keyring has a goal. The goal is an internal drive 
for the individual records to reach a certain state. The goal is 
either $introducing$ or $\neg introducing$. While the goal is 
$introducing$ the record tries to go to the Omnipresent state. In 
the other case its direction of movement is towards the hidden 
state. When a record has fulfilled its goal the record is said to be 
stable. The record can become unstable again iff the goal changes.

\subsection{Role}

A key has one or two roles. It is a `key Signing key' (KSK), a `zone 
signing key' (ZSK), or both --- combined signing key (CSK). This 
document does not spent too much time on these roles as our model 
isn't concerned with the difference. It simply checks whether or not 
there is a key with certain properties. For example, a KSK has no 
RRSIG record. Every statement about its RRSIG record evaluates to 
False. A ZSK has no DS and RRSIG DNSKEY record. A CSK has all records.

%~ \subsection{Key Properties}
%~ \label{sec:key_properties}
%~ 
%~ A key and its context can be described as a tuple of states $\langle 
%~ Ds,Dnskey,Rrsig\rangle$ for the resource records DS, DNSKEY and RRSIG.
%~ Only keys acting in the role of $ksk$ have a $Ds$ state, similar
%~ only a $zsk$ has a $Rrsig$ state. Furthermore we require the signature
%~ over the DNSKEY set to propagate together with the DNSKEY.
%~ We define the following operations on a key $k$:
%~ 
%~ \begin{itemize}
	%~ \item[$Ds(k)$] State of DS record belonging key $k$.
	%~ \item[$Dnskey(k)$] State of DNSKEY record belonging key $k$.
	%~ \item[$Rrsig(k)$] State of RRSIG record belonging key $k$.
	%~ \item[$Goal(k)$] $Goal(k) \in \{Omnipresent, Hidden\}$] the state each record
		%~ should move towards.
	%~ \item[$Roles(k)$] $Roles(k) \subseteq \{zsk,ksk\}$] excluding $\emptyset$, the 
		%~ role(s) a key $k$ should be used for.
		%~ $Ds(k) \wedge Dnskey(k) \equiv ksk \in Roles(k)$ and
		%~ $Dnskey(k) \wedge Rrsig(k) \equiv zsk \in Roles(k)$
	%~ \item[$Alg(k)$] Algorithm of key $k$ for which a transitive and 
		%~ commutative equivalence is defined.
	%~ \item[$MinDs(k)$] Boolean. If true, key will strive to keep the DS
			%~ set as small as possible.
	%~ \item[$MinDnskey(k)$] Boolean. If true, key will strive to keep the DNSKEY
			%~ set as small as possible.
	%~ \item[$MinRrsig(k)$] Boolean. If true, key will strive to keep the
			%~ signiture count low.
	%~ \item[$Standby(k)$] Boolean. If true, ksk will not introduce DNSKEY
			%~ and zsk will not introduce RRSIGs.
	%~ \item[$Revoke(k)$] Boolean. 
%~ \end{itemize}

\section{Model}

\subsection{Notation}

For readability let $A$ denote a DS record, $B$ the DNSKEY, $C$ the 
RRSIG DNSKEY, and $D$ the RRSIG. The state of a record is indicated 
with superscript and can be found in Table~\ref{tab:states}. These 
states correspondent directly with the states from Figure~\ref 
{fig:statemachine}. The subscript of a record denotes the key it 
belongs to. When no subscript is given the record belongs to the 
current evaluated key. E.g: the statement ``the DS of key $z$ is in 
the Omnipresent state'' can be written as $A^{+}_{z}$. 


\begin{table}[h]
\centering
\begin{tabular}{ r r | c  c }
	&			&	\multicolumn{2}{c}{P} \\
	&			& 	$\leq$ 1	& 1 \\ \cline{2-4}
\multirow{2}{*}{direction}  
	&	in		& $\uparrow$	& + \\
	&	out		& $\downarrow$	& - \\
\end{tabular}
\caption{Notation of states in superscript}
\label{tab:states}
\end{table}

%~ notation
%~ rules
%~ algorithm

Furthermore, the certain states are a subset of the uncertain states. So 
a Hidden record is also said to be Unretentive. 
$A_{x}^{-} \rightarrow A_{x}^{\downarrow}$.

\subsection{Rules}

The system uses three rules, Equation~\eqref{eqn:rule1}\eqref{eqn:rule2}\eqref{eqn:rule3}.
To see we can transition the state of a record to the next we first 
test the three rules. They \emph{should} all be True, if not we apparently
have an invalid zone on our hands. This isn't our fault (presumably\footnote{
The system should never bring the zone to an invalid state, if it does
it is considered a serious bug!}) but we have to deal with it.

Next we evaluate the rules again but pretend we gave the record the 
requested state. At least the rules with a positive outcome in the 
first test \emph{must} still be positive if we were to apply this 
state transition. Otherwise we may not make the transition as it 
would make the zone \emph{less valid}.

Allowing rules to be negative in the first test while prohibit positive
rules become negative prevents locks in our statemachine and will to
some extend repair invalid situations in a graceful manner. Also, it 
allows unsigned zones to exist without special tricks.

The three rules \emph{should} be true for each record of all keys. The 
rules will be explained in a later section.

\begin{eqnarray}
\label{eqn:rule1}
rule1:	&& A_{x}^{\uparrow} \\
\label{eqn:rule2}
rule2:	&& \neg A_{x}^{\uparrow} (A^{-} \vee B^{+} C^{+}) \vee A_{x}^{\uparrow}
	B_{x}^{+} C_{x}^{+} \vee A_{x}^{+} B_{x}^{\uparrow} C_{x}^{\uparrow}
	A_{y}^{+} B_{y}^{\downarrow} C_{y}^{\downarrow}\\
\label{eqn:rule3}
rule3:	&& \neg B_{x}^{\uparrow} (B^{-} \vee D^{+}) \vee B_{x}^{\uparrow}
	D_{x}^{+} \vee B_{x}^{+} D_{x}^{\uparrow} B_{y}^{+}
	D_{y}^{\downarrow}
\end{eqnarray}

\subsection{Algorithm}

The defined rules are just for deciding if a single record may change its
state to the next. Algorithm~\ref{alg:alg} describes how this can be 
done for a whole zone while also take timing in to account. 

\begin{algorithm}
\caption{Advance keys within a zone, return time for next run.}
\label{alg:alg}
\begin{algorithmic}
\STATE $nextRun \gets \infty$
\REPEAT
\STATE $change \gets \bot$ 
\FORALL {$key \in keyring$}
\FORALL {$record \in key$}
\STATE $nextState \gets desiredState(state(record), goal(key))$
\IF{$nextState = state(record)$}
\STATE \COMMENT{This record is in a stable state}
\STATE continue
\ENDIF
\IF{\NOT $transitionAllowed(keyring, key, record, nextState)$}
\STATE \COMMENT{This transition would make the zone invalid}
\STATE continue
\ENDIF
\STATE $t \gets transitionTime(type(record), state(record), nextState, lastChange(record))$
\IF{$t \geq now()$}
\STATE \COMMENT{We are not allowed to make the transition at this time}
\STATE $nextRun \gets minimum(t, nextRun)$
\STATE continue
\ENDIF
\STATE $state(record) \gets nextState$
\STATE $lastChange(record) \gets now()$
\STATE $change \gets \top$
\ENDFOR
\ENDFOR
\UNTIL \NOT $change$
\RETURN $nextRun$
\end{algorithmic}
\end{algorithm}

Three funtions might need more explanation:
\begin{description}
\item[desiredState(state, goal)]	returns the state a record 
wants to change to given its movement direction and current state.
\item[transitionAllowed(keyring, key, record, state)]	Evaluates the
rules and checks if $record$ can be brought to $state$ with respect
to the DNSSEC validity.
\item[transitionTime(type, state, state, time)]	The absolute time after
which the transition between the two states can take place given the 
type of record and the time of last change. This is policy specific.
\end{description}

\section{Rules explained}

\begin{equation}
A_{x}^{\uparrow} 
\end{equation}

The notation is not sufficient here. What I mean to say is there must
be a DS Rumoured or Omnipresent at all times. Does not matter which key
or what algorithm.

\begin{equation}
\neg A_{x}^{\uparrow} (A^{-} \vee B^{+} C^{+}) \vee A_{x}^{\uparrow}
	B_{x}^{+} C_{x}^{+} \vee A_{x}^{+} B_{x}^{\uparrow} C_{x}^{\uparrow}
	A_{y}^{+} B_{y}^{\downarrow} C_{y}^{\downarrow}\\
\end{equation}

The second rule basically describes the dependency of the DS record
on the DNSKEY record and the signature thereof. Either there is no DS
published and the DNSKEY is well known, another DS is published with the
DNSKEY well known, or two DS's are well known and their DNSKEYS are being 
swapped.

Although not stated explicitly, all records in the statement must have
the same algorithm.

\begin{equation}
\neg B_{x}^{\uparrow} (B^{-} \vee D^{+}) \vee 
	B_{x}^{\uparrow} D_{x}^{+} \vee 
	B_{x}^{+} D_{x}^{\uparrow} B_{y}^{+} D_{y}^{\downarrow}
\end{equation}

The third rule expresses the dependency of the DNSKEY on the RRSIG. 
Either there is no DNSKEY at all, the DNSKEY is being introduced with
the RRSIG well known, or two DNSKEYs exist and their RRSIGS's are being
swapped.

Again, all record must have the same algorithm.

\section{Examples}

%~ \section{Rollover Scenarios}
%~ 
%~ The proposed state machine has no notion of rollover scenarios. It cares
%~ only about the validity of the zone in terms of DNSSEC. Stricly following
%~ the transition rules results in the fastest possible transition. It is
%~ however sometimes desired to do a slower rollover in favor of the size 
%~ of the data, traffic, computing power or external interaction. Current
%~ described rollover mechanisms can be described as a set of constraints
%~ on the previously mentioned quantities.
%~ 
%~ Important to realize is that different rollover mechanisms do not need
%~ different rules. All operate within the boundries of DNSSEC validity
%~ which is descibed by our model. A rollover is nothing more than a
%~ requirement to do certain transitions in a pre defined order. To achieve
%~ that, selective brakes have to be applied on the system.
%~ 
%~ \begin{description}
%~ \item [Minimize Parent Interactions]
	%~ Rolling to a new KSK requires the
	%~ submission of a new and withdrawing of an old DS record in the parent of
	%~ the deligation. Child-Parent interaction may be slow, performing
	%~ these two actions simultainiously could save time and efford.
%~ \item [Minimize Signatures]
	%~ Especially for large zones it may be 
	%~ desireable to prevent having more than one signature over each 
	%~ resource record set. Also this allows the signer to do a smooth
	%~ signature transition.
%~ \item [Minimize DNSKEY Set] Since keys can get rather large one might
	%~ want to limit the size of this set.
%~ \end{description}
%~ 
%~ On top of this one might want to prevent replacing all signatures at 
%~ once. A suddent transition may cause a peak load on the servers and can
%~ cause too much stress on the signer. 
%~ 
%~ These `brakes' are defined for each individual key, as defined in 
%~ Section~\ref{sec:key_properties}. So one key can have the $MinRrsig$ 
%~ property while another keys does not. The big advantage is that a 
%~ policy rollover does not introduce additional complications. 

\end{document}