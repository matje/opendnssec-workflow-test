\documentclass[twoside, a4paper]{article}
\usepackage{graphicx}
\usepackage{amssymb,amsmath}
\usepackage[english]{babel}
\usepackage{multirow}
\usepackage{algorithmic}
\usepackage{algorithm}
%~ \usepackage{subequations}
\usepackage{threeparttable} %footnotes in tables
\usepackage{color}

\definecolor{quotemarkcolor}{rgb}{0.8,0.8,0.8}
\newenvironment{fancyquotation}{
   \begin{quotation}
	\noindent\llap{\raisebox{-2em}[2em][0pt]{\scalebox{5}{\color{quotemarkcolor}``}}}
}{
	\hfill\raisebox{-3em}[0em][0pt]{\scalebox{5}{\color{quotemarkcolor}''}}
   \end{quotation}
}

\title{\textsc{Dnssec} Key State Transitions}
\author{Yuri Schaeffer, Yuri@NLnetLabs.nl}
\date{\today}

\begin{document}
\maketitle

\section{Three Laws of DNSSEC}
\begin{description}
\item[First Law] An Enforcer may not injure a zone by revoking its DS record.
\item[Second Law] An Enforcer must keep a secure KSK or an insecure KSK if that does not conflict with he first rule.
\item[Third Law] An Enforcer must protect its ZSK security unless revoking does not conflict with the first or second rule.
\item[Zeroth Law] An enforcer may not harm a zone, or, by inaction, allow zones to come to harm.
\end{description}

\begin{fancyquotation}
Trevize frowned. ``How do you decide what is injurious, or not injurious, to humanity as a whole?''

``Precisely, sir,'' said Daneel. ``In theory, the Zeroth Law was the answer to our problems. In practice, we could never decide. A human being is a concrete object. Injury to a person can be estimated and judged. Humanity is an abstraction.''
\end{fancyquotation}
\hfill--Foundation and Earth


\section{Warning}
This document is a rough explanation of an idea. It is based on earlier
work and may use but not introduce terminology of an other document. 
Possibly introduce completely new notations, skip reasoning steps without 
warning (well, you are warned now) and be plain wrong. This document is considered unsuitable
for young children and Liberal-Arts majors. Read at OWN RISK.

\pagebreak\tableofcontents

\section{Introduction}

A key roll-over is a process that runs over time, at any time each 
key has a state. Matthijs Mekking introduced the idea\cite{mekking} that a key has 
a private part, a public part, and a parent part. Each of these 
parts have their own state-machine an together represent a 
'key-state'.

%~ However a cache 
%~ centered rather than a roll-over centered approach is chosen. 
This idea forms the basis for this document and 
allows us to generalize much of the logic. All parts of the 
key-state now represent records which are actually published to the 
world. The state of a record tells if and how well the record is 
known to caching resolvers\footnote{ This document mixes the 
terms cache, resolver and validator. In all cases a DNSSEC 
validating caching resolver is meant.}. As a result each record now 
has exactly the same state machine. Furthermore instead of 3 parts 
we use 4 parts per key.

With these ingredients we can formalize the boundries of DNSSEC. We say 
a zone is in a valid DNSSEC state if a validator can build a chain of 
trust from that state. Alternatively, a unsigned zone is also considered
valid, as long as it is not bogus\footnote{Bogus: 
		The validating resolver has a trust anchor and a secure
	  delegation indicating that subsidiary data is signed, but the 
	  response fails to validate for some reason: missing 
	  signatures, expired signatures, signatures with unsupported 
	  algorithms, data missing that the relevant NSEC RR says should 
	  be present, and so forth. (RFC4033) }. In terms of end-user, 
	  if the user is able to get an address for
a name, the zone is valid. With our formal definition we can test the
current state for validity and have a precise way of deciding we can
take a transition to a next key state.

\section{Cache Centered Approach}

In a cache centered approach we do not define how rollovers should 
work exactly. The state of a key is represents how well it is know 
to \emph{any} caching validator. Either all caches have a record, no 
caches have a record, or some caches \emph{might} have it en some 
caches \emph{might not}. In the latter case we must simply wait long 
enough and the record will enter one of the certain states again. We 
will discuss the key states in section~\ref{sec:keystates}.

Each key has a goal, the goal is either to be published and to be 
known to all caches around the world or to none at all. A system can 
make any state transition as long as it makes sure that the validity 
of a zone in general is not compromised. This does also imply that a 
key's goal can be changed at any time without the zone going bogus. 
E.g. if a key has a desire to disappear but is the only key left it 
will stay on duty for as long as necessary. Also, new keys can be 
introduced at any time.

This approach has a number of advantages. Here, in contrast to a 
roll-over centered approach, keys have no direct relation to each 
other. The system does not try to roll from one specific key to 
another specific key but rather satisfy all goals while remaining 
valid as a whole. Essentially the roll-over is a side effect of the 
strive to satisfy key goals. New keys can be introduced and goals 
can be redefined at any time without a problem. This makes the 
system agile, robust, and capable of handling unexpected situations. 
Another advantage is that our system will `think' the same was as 
the validators we are trying to satisfy. It always knows how 
resolvers (might) see the data and makes keeping that data valid its 
core business. 

%~ key ring
%~ key states
%~ ksk vs zsk
%~ mutators (breaks)

\section{Keys}

\subsection{Keyring}

Although zones can share key material the records are published 
independently. As a result each zone must have its own collection of 
key states. Let us refer to this collection as a keyring denoted by 
$\mathbb{K}$. A Keyring and a Zone have a 1-on-1 relation.

Keys not known to any resolver can freely be added to or removed 
from the keyring. Similar, if a key is in none of the keyrings the 
key material can be purged safely from the keystorage.

\subsection{Key States} \label{sec:keystates}

The state of a key is publicly represented by the DS record, DNSKEY 
record, RRSIG DNSKEY record and the RRSIGs over all the data in the 
zone. The latter consists of multiple records but all share the same 
state, although technically incorrect we will refer to it as the 
RRSIG record.

Because each of the four records can be introduced at a different 
time and at a different pace, all need their own state machine 
(Figure~\ref{fig:statemachine}).

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.5]{statemachine.pdf}
	\caption{State diagram for individual records.}
	\label{fig:statemachine}
\end{figure}


\paragraph{Reputation} The state of a resource record is defined by 
its reputation in world's caches. There are 2 certain states, \emph 
{Hidden} and \emph {Omnipresent}. In the first state a resource 
record is not available in any cache (any longer or at start). 
Similarly in the latter state we are sure all caches have a copy of 
the record or can at least obtain it (i.e. they have no old 
resource record set with expired TTL).

The two other states represent uncertainty: \emph{Rumoured} and \emph
{Unretentive}. Both mean that some caches do and some don't know 
about the resource record. In the former state a record is being 
actively published and will somewhere in the future be known by all 
caches. While the latter state the record is not published (any 
longer) and will disappear from collective memory over time.

Since DNS involves caches and TTLs, it is entirely possible for a 
record being in the \emph{Rumoured} state while in fact every cache 
in the world holds the record. The problem is the uncertainty, we 
have no way to know a record is fully propagated other than waiting 
the worst case propagation time. This is also true for the \emph
{Unretentive} state.

\paragraph{Summary} A record is always in one of these four states:

\begin{itemize}
\item[\emph{Hidden}:] 		
			The record is in no cache at all.
\item[\emph{Rumoured}:] 		
			The record is published but not every cache might be aware.
\item[\emph{Omnipresent}:]
			Every cache has this record.
\item[\emph{Unretentive}:]
			The record is withdrawn but some caches might still have it.
\end{itemize} 

\paragraph{Formal definition of record states} Let $r$ be a record, 
$Announced$ the collection of records that are actively published, 
and $\mathbb{C}$ the collection of all caches in the world. The 
states are defined by:

\begin{displaymath}
\begin{array}{lllll}
       r\in Hidden      & \equiv & \forall c \in \mathbb{C} \cdot r \not \in c \\
       r\in Rumoured    & \equiv & \exists c \in \mathbb{C} \cdot r \not \in c \wedge \exists c \in \mathbb{C} \cdot r\in c \wedge r\in Announced\\
       r\in Omnipresent & \equiv & \forall c \in \mathbb{C} \cdot r \in c \\
       r\in Unretentive & \equiv & \exists c \in \mathbb{C} \cdot r \not \in c \wedge \exists c \in \mathbb{C} \cdot r \in c \wedge r \notin Announced \\
\end{array}
\end{displaymath}

\paragraph{Ordering} We also define a ordering on record states so 
we can compare states. $ hidden < rumoured < omnipresent < 
unretentive$. This represents the normal lifecycle for a record as 
depicted in Figure~\ref{fig:statemachine}.


\subsection{Goal}

Each key in the keyring has a goal. The goal is an internal drive 
for the individual records to reach a certain state. The goal is 
either `well-known' or `not-known'. While the goal is 
`well-known' (the key is said to be $introducing$) the record tries to go to the Omnipresent state. In 
the other case its direction of movement is towards the hidden 
state and is said to be $outroducing$. When a record has fulfilled its goal the record is said to be 
stable. The record can become unstable again only if the goal changes (or
the state changes somehow by user intervention, but this is potentially harmful).

\subsection{Role}

A key has one or two roles. It is a `key Signing key' (KSK), a `zone 
signing key' (ZSK), or both --- combined signing key (CSK). This 
document does not spend too much time on these roles as our model 
is not concerned with the difference. It simply checks whether or not 
there is a key with certain properties. For example, a KSK has no 
RRSIG record. Every statement about its RRSIG record evaluates to 
False. A ZSK has no DS and RRSIG DNSKEY record. A CSK has all records.

%~ \subsection{Key Properties}
%~ \label{sec:key_properties}
%~ 
%~ A key and its context can be described as a tuple of states $\langle 
%~ Ds,Dnskey,Rrsig\rangle$ for the resource records DS, DNSKEY and RRSIG.
%~ Only keys acting in the role of $ksk$ have a $Ds$ state, similar
%~ only a $zsk$ has a $Rrsig$ state. Furthermore we require the signature
%~ over the DNSKEY set to propagate together with the DNSKEY.
%~ We define the following operations on a key $k$:
%~ 
%~ \begin{itemize}
	%~ \item[$Ds(k)$] State of DS record belonging key $k$.
	%~ \item[$Dnskey(k)$] State of DNSKEY record belonging key $k$.
	%~ \item[$Rrsig(k)$] State of RRSIG record belonging key $k$.
	%~ \item[$Goal(k)$] $Goal(k) \in \{Omnipresent, Hidden\}$] the state each record
		%~ should move towards.
	%~ \item[$Roles(k)$] $Roles(k) \subseteq \{zsk,ksk\}$] excluding $\emptyset$, the 
		%~ role(s) a key $k$ should be used for.
		%~ $Ds(k) \wedge Dnskey(k) \equiv ksk \in Roles(k)$ and
		%~ $Dnskey(k) \wedge Rrsig(k) \equiv zsk \in Roles(k)$
	%~ \item[$Alg(k)$] Algorithm of key $k$ for which a transitive and 
		%~ commutative equivalence is defined.
	%~ \item[$MinDs(k)$] Boolean. If true, key will strive to keep the DS
			%~ set as small as possible.
	%~ \item[$MinDnskey(k)$] Boolean. If true, key will strive to keep the DNSKEY
			%~ set as small as possible.
	%~ \item[$MinRrsig(k)$] Boolean. If true, key will strive to keep the
			%~ signiture count low.
	%~ \item[$Standby(k)$] Boolean. If true, ksk will not introduce DNSKEY
			%~ and zsk will not introduce RRSIGs.
	%~ \item[$Revoke(k)$] Boolean. 
%~ \end{itemize}

\section{Model}

\subsection{Notation}

For readability let $D$ denote a DS record, $K$ the DNSKEY, $k$ the 
RRSIG DNSKEY, and $S$ the RRSIG. The state of a record is indicated 
with superscript and can be found in Table~\ref{tab:states}. These 
states correspondent directly with the states from Figure~\ref 
{fig:statemachine}. I.e. $hidden \equiv -$, $rumoured \equiv 
\uparrow$, $omnipresent \equiv +$, $unretentive \equiv \downarrow$.
The subscript of a record denotes the key it 
belongs to. The
current evaluated key has subscript $i$. E.g: the statement ``the DS of key $z$ is in 
the Omnipresent state'' can be written as $D^{+}_{z}$. 


\begin{table}[h]
\centering
\begin{tabular}{ r r | c  c }
	&			&	\multicolumn{2}{c}{P} \\
	&			& 	$\leq$ 1	& 1 \\ \cline{2-4}
\multirow{2}{*}{direction}  
	&	in		& $\uparrow$	& + \\
	&	out		& $\downarrow$	& - \\
\end{tabular}
\caption{Notation of states in superscript}
\label{tab:states}
\end{table}

%~ %%%% Depricated
%~ Furthermore, the certain states are a subset of the uncertain states. So 
%~ a Hidden record is also said to be Unretentive. 
%~ $A_{x}^{-} \rightarrow A_{x}^{\downarrow}$.

\subsection{Rules}

The system uses three rules, Equation~\eqref{eqn:rule1}\eqref{eqn:rule2}\eqref{eqn:rule3}.
To see if we can transition a record to the next state we first 
test the three rules. They \emph{should} all be True, if not we apparently
have an invalid zone on our hands. This isn't our fault (presumably\footnote{
The system should never bring the zone to an invalid state, if it does
it is considered a serious bug!}) but we have to deal with it.

Next we evaluate the rules again but pretend we gave the record the 
requested state. At least the rules with a positive outcome in the 
first test \emph{must} still be positive if we were to apply this 
state transition. Otherwise we may not make the transition as it 
would make the zone \emph{less valid}.

Allowing rules to be negative in the first test while prohibit positive
rules become negative prevents locks in our statemachine and will to
some extend repair invalid situations in a graceful manner. Also, it 
allows unsigned zones to exist without special tricks.

The three rules \emph{should} be true for each record of all keys. The 
rules will be explained in a later section.

\newcommand{\record}[3]{#1_{#2}^{#3}}

\newcommand{\A}[2]{\record{D}{#1}{#2}}
\newcommand{\B}[2]{\record{K}{#1}{#2}}
\newcommand{\C}[2]{\record{k}{#1}{#2}}
\newcommand{\D}[2]{\record{S}{#1}{#2}}

\begin{eqnarray}
\label{eqn:rule1}
rule1(i)
&:& 	\exists x\cdot\A{x}{\uparrow} \vee \A{x}{+}\\
\nonumber
\\
\label{eqn:rule2}
rule2(i)
&:&		\forall x \cdot (\A{x}{-} \vee \exists y \cdot \B{y}{+}\C{y}{+} (\A{x}{}=\A{y}{}) ) \nonumber \\
&\vee& 	\exists x\cdot\A{x}{+} \B{x}{+} \C{x}{+} \nonumber \\
&\vee& 	\exists x,y\cdot\A{x}{\uparrow} \B{x}{+} \C{x}{+} \A{y}{\downarrow} \B{y}{+} \C{y}{+} \\
&\vee&	\exists x,y\cdot \A{x}{+} \B{x}{\uparrow +} \C{x}{\uparrow}	\A{y}{+} \B{y}{\downarrow}\C{y}{\downarrow -} \nonumber \\
&;&		alg(i)=alg(x)=alg(y) \nonumber \\
\nonumber 
\\
\label{eqn:rule3}
rule3(i)
&:&		\forall x \cdot (\B{x}{-} \vee \exists y \cdot \D{y}{+} (\B{x}{}=\B{y}{}) ) \nonumber\\
&\vee&	\exists x\cdot \B{x}{+} \D{x}{+} \nonumber\\
&\vee&	\exists x,y\cdot \B{x}{\uparrow} \D{x}{+} \B{y}{\downarrow} \D{y}{+} \\
&\vee&	\exists x,y\cdot \B{x}{+} \D{x}{\uparrow} \B{y}{+} \D{y}{\downarrow} \nonumber \\
&;&		alg(i)=alg(x)=alg(y) \nonumber 
\end{eqnarray}

\subsection{Algorithm}

The defined rules are just for deciding if a single record may change its
state to the next. Algorithm~\ref{alg:alg} describes how this can be 
done for a whole zone while also take timing into account. 

\begin{algorithm}
\caption{Advance keys within a zone, return time for next run.}
\label{alg:alg}
\begin{algorithmic}
\STATE $nextRun \gets \infty$
\REPEAT
\STATE $change \gets \bot$ 
\FORALL {$key \in keyring$}
\FORALL {$record \in key$}
\STATE $nextState \gets desiredState(state(record), goal(key))$
\IF{$nextState = state(record)$}
\STATE \COMMENT{This record is in a stable state}
\STATE continue
\ENDIF
\IF{\NOT $transitionAllowed(keyring, key, record, nextState)$}
\STATE \COMMENT{This transition would make the zone invalid}
\STATE continue
\ENDIF
\STATE $t \gets transitionTime(type(record), state(record), nextState, lastChange(record))$
\IF{$t > now()$}
\STATE \COMMENT{We are not allowed to make the transition at this time}
\STATE $nextRun \gets minimum(t, nextRun)$
\STATE continue
\ENDIF
\STATE $state(record) \gets nextState$
\STATE $lastChange(record) \gets now()$
\STATE $change \gets \top$
\ENDFOR
\ENDFOR
\UNTIL \NOT $change$
\RETURN $nextRun$
\end{algorithmic}
\end{algorithm}

Three functions might need more explanation:
\begin{description}
\item[desiredState(state, goal)]	returns the state a record 
wants to change to given its movement direction and current state.
\item[transitionAllowed(keyring, key, record, state)]	Evaluates the
rules and checks if $record$ can be brought to $state$ with respect
to the DNSSEC validity.
\item[transitionTime(type, state, state, time)]	The absolute time after
which the transition between the two states can take place given the 
type of record and the time of last change. This is policy specific.
\end{description}

\section{Rules explained}

In a nutshell, the first rule makes sure the zone is kept signed at all times, the second keeps the KSK in a valid state and the third the ZSK. The three rules do influence each other. For example rule 3 does allow having no ZSK, but only if there is no KSK. Rule 2 does allow having no KSK but only if there is no DS published. Rule 1 seems simple but it is the only thing that keeps the zone from going unsigned.

Disabling rule 1 will allow both other rules to go to unsigned (in a gracefull manner).

\begin{eqnarray}
\label{eqn:rule1Expl}
rule1(i)
&:& 	\exists x\cdot\A{x}{\uparrow} \vee \A{x}{+}
\end{eqnarray}

At all times there must be a DS published \eqref{eqn:rule1Expl}. The only exception is when the user wants his zone unsigned, this must be explicitly stated. If so, this rule must skipped. Skipping in other situations is possible, but ill advised. The enforcer may do a rollover via an unsigned zone.

In words: there must always exist a DS record introducing or omnipresent. It does not matter what algorithm or which key this DS belongs to. This seems incomplete but really forms a fundament for rule number 2.

\begin{subequations}
\label{eqn:rule2Expl}
\begin{align}
rule2(i)
&:&		\forall x \cdot (\A{x}{-} \vee \exists y \cdot \B{y}{+}\C{y}{+} (\A{x}{}=\A{y}{}) ) \label{r2eUnsigned}\\
&\vee& 	\exists x\cdot\A{x}{+} \B{x}{+} \C{x}{+} \label{r2eTrivial}\\
&\vee& 	\exists x,y\cdot\A{x}{\uparrow} \B{x}{+} \C{x}{+} \A{y}{\downarrow} \B{y}{+} \C{y}{+} \label{r2eMinds}\\
&\vee&	\exists x,y\cdot \A{x}{+} \B{x}{\uparrow +} \C{x}{\uparrow}	\A{y}{+} \B{y}{\downarrow}\C{y}{\downarrow -} \label{r2eMinkey}\\
&;&		alg(i)=alg(x)=alg(y) \label{r2eAlg}
\end{align}
\end{subequations}

Rule 2 describes the dependency of the DS record on the DNSKEY and 
its RRSIG. The subequations represent the different scenarios that 
are valid, at least one of these scenarios must be true at all 
times. The only keys that need to be considered are the keys with 
the same algorithm as the input key $i$ \eqref{r2eAlg}.

Subequation~\eqref{r2eTrivial} is the trivial case: If there is a 
key with the DS, DNSKEY and RRSIG DNSKEY fully propagated all other 
keys of this algorithm can be in any state. No further requirements.

Similar subequation~\eqref{r2eMinds} requires two keys swapping DS 
records. Again, if this is the case, the zone is valid for the KSK 
and other keys can be in any state without consequences.

Subequation~\eqref{r2eMinkey} also requires two keys, but now they 
are swapping DNSKEYs. Notice the DNSKEY of the introducing key and 
the signatures of the outroducing key may be in one of 2 different 
states. This is important since record are evaluated individually, 
omitting these states might block the engine as neither record may 
move on its own.

Finally the unsigned case, subequation~\eqref{r2eUnsigned}. It 
applies to zones unsigned \emph{for this algorithm}, which includes 
unsigned for \emph{any} algorithm. In the unsigned/partially signed 
case no DS may be published. If however a DS of key $x$ is published 
anyway there must be a key $y$ with the DNSKEY set propagated and 
the DS in the same state as key $x$. Like everywhere else $x$ and $y$
may be the same key.

Let us review an example (ignoring rule 1 and 2). Say we have two 
keys: $\A{x}{+}\B{x}{+}\C{x}{+}$ and $\A{y}{+}\B{y}{-}\C{y}{-}$. We 
want the zone to become unsigned. At time 0 the zone is valid 
because of \eqref{r2eTrivial} and we can therefore outroduce the DS 
of $y$. Now, because of \eqref{r2eUnsigned} me may do the same with 
the DS of $x$ at the same time. When both are hidden the last 
mentioned rule allows the remaining DNSKEY and RRSIG DNSKEY to do 
whatever they want.

\begin{subequations}
\label{eqn:rule3Expl}
\begin{align}
rule3(i)
&:&		\forall x \cdot (\B{x}{-} \vee \exists y \cdot \D{y}{+} (\B{x}{}=\B{y}{}) ) \\
&\vee&	\exists x\cdot \B{x}{+} \D{x}{+} \\
&\vee&	\exists x,y\cdot \B{x}{\uparrow} \D{x}{+} \B{y}{\downarrow} \D{y}{+} \\
&\vee&	\exists x,y\cdot \B{x}{+} \D{x}{\uparrow} \B{y}{+} \D{y}{\downarrow} \\
&;&		alg(i)=alg(x)=alg(y)
\end{align}
\end{subequations}

The third rule works exactly the same as rule 2 but reasons about 
the ZSK part. 

\section{Examples}

Names for rollovers are taken from ``DNSSEC Key Timing 
Considerations Follow-Up''. The tables in the following sections 
contain different kind of roll overs. Each row in the table 
represents a time step and the first row is the start situation. 
When a key does not change during a time step the record cells are 
left blank.

\subsection{ZSK Double Signature}

Without any policy directives a 
double signature rollover will be executed as this is the fastest way.

\begin{table}[h]
	\centering
	\begin{threeparttable} 
		
		\begin{tabular}{ |ccc|cc|cc|l| }
		\hline
		\multicolumn{3}{|c|}{KSK1 (in)} & \multicolumn{2}{c|}{ZSK1 (out)} & \multicolumn{2}{c|}{ZSK2 (in)} & Time\\
		\hline
		$A^{+}$ & $B^{+}$ & $C^{+}$ & $B^{+}$          & $D^{+}$          & $B^{-}$        & $D^{-}$        & \\
				&         &         &                  &                  & $B^{\uparrow}$ & $D^{\uparrow}$ & $0$\\
				&         &         & $B^{\downarrow}$ & $D^{\downarrow}$ & $B^{+}$        & $D^{+}$        & $MaxTTL(key, sig)$\\
				&         &         & $B^{-}$          & $D^{-}$          &                &                & $MinTTL(key, sig)$\\
		\hline
		\multicolumn{7}{|l|}{Total time} & $TTL(sig) + TTL(key)$\tnote{1}\\
		\hline
		\end{tabular}
		
		\begin{tablenotes}[para]
		\item[1] The total time does not seem obvious from this table.
			The `fast' record set will have to wait while the `slow'
			record set is swapping keys.
		\end{tablenotes}
		
	\end{threeparttable}
	\caption{ZSK Double Signature rollover}
	\label{tab:roll_dubsig}
\end{table}

Let us walk trough the example in Table~\ref{tab:roll_dubsig}. We'll 
evaluate each record from left to right. The KSK is ignored in our 
description as there are no changes during the rollover.

Since ZSK1 has is outroducing its records try to move to the 
unretentive state ($\downarrow$). This may not happen yet. For 
example the desired state for the DNSKEY (B) of ZSK1 is unretentive. 
Currently using ZSK1 as key $i$ all four rules are true. If we would 
now use the new state rule2 would become false.  the 
$A_{x}^{\uparrow}B_{x}^{+} C_{x}^{+}$ part would no longer be true.
Therefore we may not take this transition at this moment and we may
stop look at the other rules, although rule3 would also become false.

For both the DNSKEY as the RRSIG of ZSK2 all rules are true prior to 
a transition. After a transition they would still be true, so we can 
take these records safely to the nest state.

In the second time step (row 3) we can still not progress ZKS1 
initially. But, given enough time passed we may bring ZSK2's records 
to the next state. Suppose both the DNSKEY and RRSIG of ZSK2 change 
at the same time. In this very same time step we are now suddenly 
allowed to outroduce the records of ZSK1. Because we keep looping 
over all records of all keys till no record changes anymore the 
order of evaluation does not matter for the effectivity of the 
algorithm (it might affect the efficiency however).

The last time step has no actions for ZSK2 as all its records are in 
a stable state. The records in ZSK1 can go to hidden ($-$). Their 
state has no effect on any of the rules as ZSK2 causes all rules to 
be true anyway.

\subsection{Other examples}

Further examples are not explained in detail and are here for reference.

\begin{table}[h]
\centering
\begin{tabular}{ |ccc|cc|cc|l| }
\hline
\multicolumn{3}{|c|}{KSK1 (in)} & \multicolumn{2}{c|}{ZSK1 (out)} & \multicolumn{2}{c|}{ZSK2 (in)} & Time\\
\hline
$A^{+}$ & $B^{+}$ & $C^{+}$ & $B^{+}$          & $D^{+}$          & $B^{-}$        & $D^{-}$        & \\
        &         &         &                  &                  & $B^{\uparrow}$ & $D^{-}$        & $0$\\
        &         &         & $B^{+}$          & $D^{\downarrow}$ & $B^{+}$        & $D^{\uparrow}$ & $TTL(key)$\\
        &         &         & $B^{\downarrow}$ & $D^{-}$          & $B^{+}$        & $D^{+}$        & $TTL(sig)$\\
        &         &         & $B^{-}$          & $D^{-}$          &                &                & $TTL(key)$\\
\hline
\multicolumn{7}{|l|}{Total time} & $2 \times TTL(key) + TTL(sig)$\\
\hline
\end{tabular}
\caption{ZSK Pre-Pubplucation rollover}
\label{tab:roll_prepub}
\end{table}


\begin{table}[h]
\centering
\begin{tabular}{ |ccc|cc|cc|l| }
\hline
\multicolumn{3}{|c|}{KSK1 (in)} & \multicolumn{2}{c|}{ZSK1 (out)} & \multicolumn{2}{c|}{ZSK2 (in)} & Time\\
\hline
$A^{+}$ & $B^{+}$ & $C^{+}$ & $B^{+}$          & $D^{+}$          & $B^{-}$        & $D^{-}$        & \\
        &         &         &                  &                  & $B^{-}$        & $D^{\uparrow}$ & $0$\\
        &         &         & $B^{\downarrow}$ & $D^{+}$          & $B^{\uparrow}$ & $D^{+}$        & $TTL(sig)$\\
        &         &         & $B^{-}$          & $D^{\downarrow}$ & $B^{+}$        & $D^{+}$        & $TTL(key)$\\
        &         &         & $B^{-}$          & $D^{-}$          &                &                & $TTL(sig)$\\
\hline
\multicolumn{7}{|l|}{Total time} & $2 \times TTL(sig) + TTL(key)$\\
\hline
\end{tabular}
\caption{ZSK Double RRSIG rollover}
\label{tab:roll_doublerrsig}
\end{table}


\begin{table}[h]
\centering
\begin{tabular}{ |ccc|cc|cccc|l| }
\hline
\multicolumn{3}{|c|}{KSK1 (out)} & \multicolumn{2}{c|}{ZSK1 (out)} & \multicolumn{4}{c|}{CSK1 (in)} & Time\\
\hline
$A^{+}$ & $B^{+}$ & $C^{+}$ & $B^{+}$          & $D^{+}$          & $A^{-}$ & $B^{-}$ & $C^{-}$ & $D^{-}$               & \\
        &         &         &                  &                  & $A^{-}$ & $B^{-}$ & $C^{-}$ & $D^{\uparrow}$        & 0\\
        &         &         &                  &                  & $A^{-}$ & $B^{\uparrow}$ & $C^{\uparrow}$ & $D^{+}$ & TTL(sig)\\
$A^{\downarrow}$  & $B^{+}$ & $C^{+}$ &        &                  & $A^{\uparrow}$ & $B^{+}$ & $C^{+}$ & $D^{+}$        & TTL(key)\\
$A^{-}$  & $B^{\downarrow}$ & $C^{\downarrow}$ & $B^{\downarrow}$ &$D^{+}$ & $A^{+}$ & $B^{+}$ & $C^{+}$ & $D^{+}$               & TTL(ds)\\
$A^{-}$  & $B^{-}$ & $C^{-}$ & $B^{-}$ &$D^{\downarrow}$ &    &   &   &                                        & TTL(key)\\
        &         &         & $B^{-}$ & $D^{-}$                   &    &   &   &                                        & TTL(sig)\\
\hline
\multicolumn{9}{|l|}{Total time} & $2 \times TTL(key) + 2 \times TTL(sig) + TTL(ds)$\\
\hline
\end{tabular}
\caption{Split Key to Single Key Algorithm rollover}
\label{tab:roll_doublerrsig}
\end{table}


%~ \section{Rollover Scenarios}
%~ 
%~ The proposed state machine has no notion of rollover scenarios. It cares
%~ only about the validity of the zone in terms of DNSSEC. Stricly following
%~ the transition rules results in the fastest possible transition. It is
%~ however sometimes desired to do a slower rollover in favor of the size 
%~ of the data, traffic, computing power or external interaction. Current
%~ described rollover mechanisms can be described as a set of constraints
%~ on the previously mentioned quantities.
%~ 
%~ Important to realize is that different rollover mechanisms do not need
%~ different rules. All operate within the boundries of DNSSEC validity
%~ which is descibed by our model. A rollover is nothing more than a
%~ requirement to do certain transitions in a pre defined order. To achieve
%~ that, selective brakes have to be applied on the system.
%~ 
%~ \begin{description}
%~ \item [Minimize Parent Interactions]
	%~ Rolling to a new KSK requires the
	%~ submission of a new and withdrawing of an old DS record in the parent of
	%~ the deligation. Child-Parent interaction may be slow, performing
	%~ these two actions simultainiously could save time and efford.
%~ \item [Minimize Signatures]
	%~ Especially for large zones it may be 
	%~ desireable to prevent having more than one signature over each 
	%~ resource record set. Also this allows the signer to do a smooth
	%~ signature transition.
%~ \item [Minimize DNSKEY Set] Since keys can get rather large one might
	%~ want to limit the size of this set.
%~ \end{description}
%~ 
%~ On top of this one might want to prevent replacing all signatures at 
%~ once. A suddent transition may cause a peak load on the servers and can
%~ cause too much stress on the signer. 
%~ 
%~ These `brakes' are defined for each individual key, as defined in 
%~ Section~\ref{sec:key_properties}. So one key can have the $MinRrsig$ 
%~ property while another keys does not. The big advantage is that a 
%~ policy rollover does not introduce additional complications. 

\begin{thebibliography}{9}

\bibitem{mekking}
  Matthijs Mekking,
  \emph{DNSSEC Key Timing Considerations Follow-Up}.
  Internet-Draft,
  draft-mekking-dnsop-dnssec-key-timing-bis-00,
  February 25, 2011.

\end{thebibliography}

\end{document}
