\documentclass[twoside,english]{paper}
%~ \usepackage{booktabs}
\usepackage{graphicx}
%~ \usepackage{subfigure}
%~ \usepackage{histogr}
%~ \usepackage{rotating}
\usepackage{amssymb,amsmath}

\newcommand{\union}{\mathrel{\cup}}
\newcommand{\unionprefix}{\mathopen{\cup}\ensuremath{\,}}
\newcommand{\intersection}{\mathrel{\cap}}
\newcommand{\intersectionprefix}{\mathopen{\cap}\ensuremath{\,}}
\renewcommand{\setminus}{\mathrel{\backslash}}
\newcommand{\powerset}{\mathopen{\mathbb{P}}\ensuremath{\,}}

\newcommand{\mathbox}[1]{\fbox{\begin{minipage}{\linewidth}#1\end{minipage}}}
%~ \newcommand{\mathbox}[1]{#1}

\title{DNSSEC Key State Transitions}
\author{Yuri Schaeffer, Yuri@NLnetLabs.nl}
\date{\today}

%~ \parindent 0pt
%~ \parskip 5pt

\begin{document}
\maketitle
\tableofcontents

\section{Introduction}

During a key rollover each involved key has a state. Matthijs 
Mekking pointed out that the statemachine for this key can be 
represented as three individual smaller state machines: The state at 
the parent, the private key state, and the public key state. 

That idea is the basis for this document. A cache centered rather 
than a rollover centered approach is choosen and the three different 
state machines are generalized to one type of state machine. The three
state machines now represent the public records associated with a key 
(\textsc{ds}, \textsc{dnskey}, \textsc{rrsig}). The state of each record is defined by its 
reputation among all DNS caches in the world. 

With this we are able to formalize the boundries of DNSSEC and make
precise statements about the validity of a zone with respect to DNSSEC.
This has two levels: One of them is that we can judge any invariant of
states on validity. The other is that for each state we know under
what exact circumstances we can me a transition to the next state.

\section{Cache Centered Approach}

The cache centered approach uses a few extra concepts. Each key has 
a goal, an internal desire to be either known to all caches around 
the world or no caches at all. A system can make any state 
transition as long as it makes sure that the validity of a zone in 
general is not compromized. This does also imply that a key's goal can
be changed at any time without the zone going bogus. E.g. if a key has
a desire to disappear but is the only key left it will stay on duty for
as long as necessary. Also, new keys can be introduced at any time.

Using a cache centered approach has a number of advantages. Here, in 
contrast to a rollover centered approach, keys have no direct 
relation to each other. The system does not try to roll from one 
specific key to another specific key but rather satisfy all goals 
while remaining valid as a whole. Essentially the rollover is a side 
effect of the strive to satisfy key goals. New keys can be 
introduced and goals can be redefined at any time without a problem. 
This makes the system agile, robust, and capable of handling unexpected
situations.

This point of view makes sense because the identities validating the 
zone are viewing it from a cache's perspective. If we make sure any 
possible view on the data is valid at any point in time we have done 
enough.



\subsection{Key States}

TODO:
Regardless of the record type we can define 5 basic states. The 
distinctive property is its existence in caches world wide, so we 
choose a cache oriented approach. A record 
starts in a Generated state, $G$. Since the record is never 
published yet there is no cache having\footnote{When we say a record 
is in cache we explicitly mean that there are no old versions in 
cache with an unexpired TTL. Having to fetch a record from the 
authorities is also considered in cache.} this record. The next state is 
Submitted, $S$. In this state the record could be known to \emph
{any} cache, but might as well be none. As for all state the exact 
meaning depends on the record type, e.g. Submitted may mean emailed 
to parent or published in zone. State three is Propagated, $P$, 
which means all caches have the record or can obtain it. In the 
Withdrawn $W$ state not all caches have the record or are able to 
get it. Finally Ceased $C$ denotes no cache will try to use the 
record any longer.

To summarize:

\begin{description}
       \item[$G$] The record is not used.
       \item[$S$] Submitted, some caches might have seen the record.
       \item[$P$] Propagated, all caches have seen the record or will see it.
       \item[$W$] Withdrawn, some caches are unable to get the record.
       % \item[$C$] Ceased, the record is cashed nowhere.
\end{description} 

%~ \section{State Transition}

%~ Let $\mathbb{R}$ be the set of possible resource records, according to the
%~ RFCs.  Note that this includes all possible records, including many
%~ that make no sense to any zone owner anywhere.

% Yuri: \powerset(X) means the set of all subsets of X

%~ Model a cache as the set of resource records from $\mathbb{R}$ that it currently
%~ holds.  The type of the cache is $C:\powerset(\mathbb{R})$.  We will assume
%~ that every cache adheres to the timing constraints imposed upon it by RFCs.
%~ These constraints cannot be made explicit in this model, because this model
%~ captures the (possible) situation(s) at a certain point in time.  A more
%~ elaborate model, such as a Petri net, may add timing and thus capture the
%~ additional detail.
%~ 
%~ \begin{figure}[t]
	%~ \begin{tabular}{lll}
	%~ $\emptyset$ & Empty set & $\emptyset = \{ \}$ \\
	%~ $X\cup Y$ & Union between two sets & $\{1,2\} \cup \{2,3\} = \{1,2,3\}$ \\
	%~ $X\cap Y$ & Intersection of two sets & $\{1,2\} \cap \{2,3\} = \{2\}$ \\
	%~ $X\setminus Y$ & Set subtraction & $\{1,2\}\setminus \{2,3\} = \{1\}$ \\
	%~ $\union X$ & Union iterated over set elements & $\union\{X,Y,Z\} = X\cup Y\cup Z$ \\
	%~ $\intersection X$ & Intersection over set elements & $\intersection\{X,Y,Z\} = X\cap Y\cap Z$ \\
	%~ $\powerset(X)$ & Powerset, or set of all subsets & $\powerset(\{1,2\}) = \{ \emptyset, \{1\}, \{2\}, \{1,2\}\}$ \\
	%~ \end{tabular}
	%~ \caption{Mathematical notation used}
%~ \end{figure}

%~ \paragraph{Caches.}
%~ It is particularly useful to model a set $\mathbb{C}\subseteq\powerset(\mathbb{R})$ of all
%~ possible caches around the World, as this represents all possible states
%~ that could challenge a DNSSEC signer to behave properly.  Again, this
%~ model will not capture the timing constraints that define precisely what
%~ subset of $\powerset(\mathbb{R})$ actually forms $\mathbb{C}$.

% Yuri: Meestal gebruik je \mathbb alleen voor speciale (meta) gevallen

%~ Based on these definitions, we can derive a meaningful partition of the
%~ resource records $\mathbb{R}$ depending on how widely it is published:
%~ 
%~ \begin{eqnarray}\label{states}
	%~ \emph{Hidden} &=& \mathbb{R}~\setminus~\unionprefix \mathbb{C} \\
	%~ \emph{Propagating} &=& \unionprefix \mathbb{C}~\setminus~\intersectionprefix \mathbb{C} \\
	%~ \emph{Omnipresent} &=& \intersectionprefix \mathbb{C}
%~ \end{eqnarray}

%~ \paragraph{Setting a goal.}
%~ The above partition of $\mathbb{R}$ suffices to know what can be relied upon from the
%~ caches in the World.  But, since DNS is not a static system, this state will evolve
%~ with time.  Specifically, the \emph{Propagating} state is a temporary one that will be
%~ departed as soon as the right TTL timing has passed.  This however, can go either
%~ way; it depends on a new model element which way.  This model element is the goal
%~ set for a resource record: Does it want to be \emph{Omnipresent} or \emph{Hidden}?
%~ 
%~ We therefore introduce another set named $\emph{Announced}\subseteq\mathbb{R}$ to hold
%~ those resource records whose goal it is to end up in $\emph{Omnipresent}$.  Based on
%~ this, it is possible to partition $\emph{Propagating}$ even further:
%~ %
%~ \begin{eqnarray}\label{states}
	%~ \emph{Rumoured} &=& \emph{Propagating} \cap \emph{Announced}\\
	%~ \emph{Squashed} &=& \emph{Propagating} \setminus \emph{Announced}
%~ \end{eqnarray}

\begin{figure}[t]
	\centering
	\includegraphics[scale=0.5]{states.pdf}
	\caption{State diagram for individual key components.}
	\label{fig:states}
\end{figure}

\paragraph{Predicate logic.}
The definitions above are in terms of set theory.  Although entirely equivalent, it is
probably useful to write the same thing in terms of predicate logic.  We introduce the
following boolean functions on $\mathbb{R}$, with shorthand names for reference in the
remaining pages of this document.

\begin{displaymath}
\begin{array}{lllll}
       H(r) & \equiv & r\in\emph{Hidden} &=& \forall c \in \mathbb{C}: r \not \in c \\
       R(r) & \equiv & r\in\emph{Rumoured} &=& (\exists c \in \mathbb{C}: r \not \in c) \wedge (\exists c \in \mathbb{C}: r\in c) \wedge r\in\emph{Announced}\\
       O(r) & \equiv & r\in\emph{Omnipresent} &=& \forall c \in \mathbb{C}: r \in c \\
       S(r) & \equiv & r\in\emph{Squashed} &=& (\exists c \in \mathbb{C}: r \not \in c) \wedge (\exists c \in \mathbb{C}: r \in c)\wedge r\notin\emph{Announced} \\
       %~ C(r) & \equiv & G(r)
\end{array}
\end{displaymath}



\subsection{Definitions}

Keys do not stand on their own, but actually require a number of resource records in
their context.  Specifically, a key and its context can be described as a tuple
$\langle\emph{ds},\emph{dnskey},emph{rrsig}\rangle$ with the resource records for
a DS, DNSKEY and RRSIG record, all for the same signing key.  Define the type
$K=\mathbb{R}\times\mathbb{R}\times\mathbb{R}$ represent such key with context.

\newcommand{\state}{\emph{State}}
\newcommand{\stateDS}{\emph{State}_\textrm{DS}}
\newcommand{\stateDNSKEY}{\emph{State}_\textrm{DNSKEY}}
\newcommand{\stateRRSIG}{\emph{State}_\textrm{RRSIG}}

Now define the following functions to capture the state $H$, $R$, $O$ or 
$S$
for each of the three components of a key with context tuple:
\begin{eqnarray*}
	\state(r) &\equiv& H\textrm{, if $r\in\emph{Hidden}$}\\
	          &\equiv& R\textrm{, if $r\in\emph{Rumoured}$}\\
	          &\equiv& O\textrm{, if $r\in\emph{Omnipresent}$}\\
	          &\equiv& S\textrm{, if $r\in\emph{Squashed}$}\\
	\stateDS(r,x,y) &\equiv& \state(r)\\
	\stateDNSKEY(x,r,y) &\equiv& \state(r)\\
	\stateRRSIG(x,y,r) &\equiv& \state(r)
\end{eqnarray*}

\begin{itemize}
	%~ \item $\mathbb{C}$ is a set of all caches
	%~ \item Cache $c \in \mathbb{C}$, a set of record sets r
	\item Key $k = \langle ds, dnskey, rrsig\rangle$, a tuple of states
	\item Key chain $\mathbb{K}$, a set of keys
	%~ \item $State(r) \in \{H, R, O, S\}$, with r one from k.
	\item $Goal(k) \in \{O, H\}$
	\item $Roles(k) \subseteq \{ksk, zsk\}$
	\item $Alg(k) \in \mathbb{N}$, Algorithm number of key
\end{itemize}

Each zone has its own key chain (but not necessarily unique key 
material). A key chain is a collection of keys currently involved with 
the zone, regardless of their state. The key itself consists of three 
states, one for each record involved. It also defines a goal to which
the records should try to move.

Each record is evaluated individually for the next state transition. 
If it not already reached its goal, it will try to move towards it 
provided the result is a valid DNSSEC configuration. This way only a 
small set of conditions is evaluated each time. 

Roll overs are not explicitly defined but derived from the 
set of rules. As a result the system or a user could insert a new key 
at any time in the process. For example a user has a dual key signing 
scheme and sets the goal of all current keys to Ceased. Then he inserts
a combined ZSK/KSK. From here the system will figure out the (save) way
to having the new key introduced. It might finish pending roll overs 
but if possible will try to discard the old keys as soon as possible.

Setting the goal of all your keys to ceased without first introducing 
a new key has no implication for the validity of the zone. The system 
always maintains a valid configuration. If it wants to remove old keys 
but can not, it won't.

%~ \subsection{Shorthands}
%~ 
%~ \begin{itemize}
	%~ \item This key is a KSK and active; we can rely on it. 
	%~ \\$kskready(k) \leftrightarrow ksk \in Roles(k) \wedge State(k_{ds}) = P \wedge State(k_{dnskey}) = P \wedge State(k_{rrsig}) = P$
	%~ \item If k' is a backup for k, k can safely be removed
	%~ \\$backupfor(k', k) \leftrightarrow k' \not = k \wedge Alg(k)=Alg(k') \wedge kskready(k')$
%~ \end{itemize}

\section{DNSSEC Validity}

A consistent key(context) is defined as a key that does not introduce 
internal inconsistencies. A (partially) propagated KSK must have a fully
propagated ZSK.

\begin{displaymath}
\begin{array}{l}
ConsistentKeys \equiv \{ k | k\in\mathbb{K}, \\
\hskip 1cm	Roles(k) \subseteq {ksk} \rightarrow (\neg H(Ds(k)) \rightarrow O(Dnskey(k))) \wedge \\
\hskip 1cm	\neg H(Dnskey(k)) \rightarrow O(Rrsig(k)) \wedge \\
\hskip 1cm	( \\
\hskip 2cm		H(Dnskey(k)) \vee \\
\hskip 2cm		ksk=Roles(k) \rightarrow \exists k' \in \mathbb{K} \cdot (\\
\hskip 3cm			zsk \in Roles(k') \wedge \\
\hskip 3cm			Alg(k)=Alg(k') \wedge \\
\hskip 3cm			O(Dnskey(k')) \wedge \\
\hskip 3cm			O(Rrsig(k'))\\
\hskip 2cm		)\\
\hskip 1cm	)\\
\}
\end{array}
\end{displaymath}

SafeKeys are keys that might be internally inconsistent but for which
a consistent counterpart exists.

\begin{displaymath}
\begin{array}{l}
SafeKeys \equiv \{ k | k\in\mathbb{K}, \\
\hskip 1cm 		k \in ConsistentKeys \vee \\
\hskip 1cm 		\forall r \in Roles(k) \cdot ( \\
\hskip 2cm 			\exists k' \in \mathbb{K} \cdot ( \\
\hskip 3cm 				Alg(k') = Alg(k) \wedge \\
\hskip 3cm 				r \in Roles(k') \wedge \\
\hskip 3cm 				l \in ConsistentKeys \wedge \\
\hskip 3cm 				r = ksk \rightarrow (\neg H(Ds(k)) \rightarrow O(Ds(k'))) \wedge \\
\hskip 3cm 				\neg H(Dnskey(k)) \rightarrow O(Dnskey(k')) \\
\hskip 2cm 			)\\
\hskip 1cm 		)\\
\}
\end{array}
\end{displaymath}

A zone is valid if no single key breaks validity and at least one complete
chain for any algorithm exists. An insecure zone is represented by a NULL
key.

\begin{displaymath}
\begin{array}{l}
Valid(\mathbb{K}) \Leftrightarrow \\
\hskip 1cm	\forall k \in \mathbb{K} \cdot k \in SafeKeys \wedge \\
\hskip 1cm	\exists k \in \mathbb{K} \cdot ( \\
\hskip 2cm		ksk \in Roles(k) \wedge \\
\hskip 2cm		O(Ds(k)) \wedge \\
\hskip 2cm		O(Dnskey(k)) \wedge \\
\hskip 2cm		O(Rrsig(k)) \wedge \\
\hskip 2cm		\exists k' \in \mathbb{K} \cdot ( \\
\hskip 3cm			zsk \in Roles(k') \wedge \\
\hskip 3cm			O(Dnskey(k')) \wedge \\
\hskip 3cm			O(Rrsig(k')) \wedge \\
\hskip 3cm			Alg(k)=Alg(k')\\
\hskip 2cm		)\\
\hskip 1cm	)
\end{array}
\end{displaymath}

\section{Transition Rules}
\subsection{Transition rules for $Ds(k)$}

\subsubsection*{$H(Ds(k))$}

\mathbox{
	%~ DS was never published so we can do a quick transition
	%~ \begin{equation}
		%~ \begin{split}
			%~ Goal(k)=C \rightarrow State(k_{ds})=C
		%~ \end{split}
	%~ \end{equation}

	If k is not a KSK the DS state does not matter. If is \emph{is}, before
	submitting either DNSKEY must be propagated or an other key with the 
	same algorithm should be ready.
	\begin{equation}
		\left.
		\begin{split}
			Goal(k)=O & \wedge ksk \not \in Roles(k) \\
			\\
			Goal(k)=O & \wedge O(Dnskey(k)) \\
			\\
			Goal(k)=O & \wedge 
				\exists k' \in \mathbb{K} 
				( \\
					& Alg(k)=Alg(k') \\
					& \wedge ksk \in Roles(k') \\
					& \wedge O(Ds(k')) \\
					& \wedge O(Dnskey(k')) \\
					& \wedge O(Rrsig(k')) 
				) 
		\end{split}
		\right\}\rightarrow [submit], R(Ds(k)) 
	\end{equation}
}

\subsubsection*{$R(Ds(k))$}

\mathbox{
	
	Nothing should depend on this RR yet.
	\begin{equation}
		\begin{split}
			Goal(k)=H \rightarrow S(Ds(k))
		\end{split}
	\end{equation}

	Has the user confirmed the DS is on its way to the parent and are 
	we sure everything propagated since then?
	\begin{equation}
		\left.
		\begin{split}
			Goal(k)=O & \wedge ksk \not \in Roles(k) \\
			\\
			Goal(k)=O 	& \wedge Confirmed(k_{ds}) \\
						& \wedge T_{now} \geq T_{whatever}
		\end{split}
		\right\}\rightarrow O(Ds(k))
	\end{equation}

	Postpone for later.

	\begin{equation}
		\begin{split}
			Goal(k)=O 	& \wedge Confirmed(k_{ds}) \\
						& \wedge T_{now} < T_{whatever} \\
						& \rightarrow [event]
		\end{split}
	\end{equation}
}

\subsubsection*{$O(Ds(k))$}

\mathbox{

	%~ A non-KSK can be set to withdrawn.
	%~ \begin{equation}
		%~ \begin{split}
			%~ Goal(k)=C \wedge ksk \not \in Roles(k) \rightarrow S(Ds(k))
		%~ \end{split}
	%~ \end{equation}

	DS may go in State W if it refers to nothing.
	Or if there are other keys with the same algorithm which are valid.
	Or we don't break other keys and we have some other valid key(s).
	\begin{equation}
		\left.
		\begin{split}
			Goal(k)=H 	& \wedge \forall r \in Roles(k) \\
			( \\
				& \exists k' \in \mathbb{K} ( k' \not = k \\
				&\wedge Alg(k) = Alg(k') \\
				& \wedge r \in Roles(k') \\
				& \wedge O(Ds(k')) \\
				& \wedge O(Dnskey(k')) \\
				& \wedge O(Rrsig(k'))) \\
			)\\
			\\
			%~ TODO: replace forall(implication) with not exists
			Goal(k)=H 	& \wedge ksk \in Roles(k) \\
			& \wedge \forall r \in Roles(k) \\
			( \\
				& \forall k' \in \mathbb{K} ( k' \not = k \\
					& \wedge Alg(k) = Alg(k')  \\
					& \wedge r \in Roles(k') \\ 
					& \rightarrow H(Ds(k'))
				)\\
				& \wedge \\
					&\exists k' \in \mathbb{K} (k' \not = k \\
					%~ & Alg(k) \not = Alg(k') \\
					& \wedge r \in Roles(k') \\
					& \wedge O(Ds(k')) \\
					& \wedge O(Dnskey(k')) \\
					& \wedge O(Rrsig(k'))
				) \\
			)\\
			\\
			Goal(k)=H 	& \wedge ksk \not \in Roles(k) \\
				& \wedge \exists k' \not \in \mathbb{K} (k' \not = k \\
				& Alg(k) = Alg(k') \\
				& \wedge ksk \in Roles(k') \\
				%~ & \wedge State(k'_{ds}) = P \\
				%~ & \wedge O(Dnskey(k')) \\
				& \wedge \neg H(Dnskey(k')) \\
				& \wedge O(Rrsig(k'))
				)
		\end{split}
		\right\} \rightarrow S(Ds(k)) \\
	\end{equation}
}

\subsubsection*{$S(Ds(k))$}

\mathbox{

	We must wait till at least $T_{whatever}$ before transition to State 
	Ceased. As a bonus, ZSKs may transition immediately.
	\begin{equation}
		\left.
		\begin{split}
			%~ Goal(k)=H & \wedge 
			ksk \not \in Roles(k)\\
			\\
			%~ Goal(k)=H 	& \wedge 
			T_{now} \geq T_{whatever}
		\end{split}
		\right\} \rightarrow H(Ds(k))
	\end{equation}

	\begin{equation}
		\begin{split}
			%~ Goal(k)=H 	& \wedge 
			T_{now} < T_{whatever}
						& \rightarrow [event]
		\end{split}
	\end{equation}
}


\subsection{Transition rules for $Dnskey(k)$}

\subsubsection*{$H(Dnskey(k))$}

\mathbox{

	%~ We want to move away from this key and DNSKEY was never published, retire immediately.
	%~ \begin{equation}
		%~ \begin{split}
			%~ Goal(k)=C \rightarrow State(k_{dnskey})=C
		%~ \end{split}
	%~ \end{equation}

	If the signatures are propagated we may submit the Dnskey. 
	Some other valid key is also acceptable.
	\begin{equation}
		\left.
		\begin{split}
			Goal(k)=O &\wedge O(Rrsig(k))\\
						&\wedge zsk \in Roles(k) \\
			\\
			Goal(k)=O & \wedge O(Rrsig(k))\\
					& \wedge \exists k' \in \mathbb{K}( \\
					& Alg(k')=Alg(k) \\
					&\wedge zsk \in Roles(k') \\
					&\wedge O(Ds(k')) \\
					&\wedge O(Dnskey(k')) \\
					&\wedge O(Rrsig(k'))) \\
			\\
			Goal(k) = O 
				&\wedge \forall r \in Roles(k) \\
				(\\
					& \exists k' \in \mathbb{K}(k' \not = k \\
					&\wedge Alg(k')=Alg(k) \\
					&\wedge r \in Roles(k') \\
					&\wedge O(Ds(k')) \\
					&\wedge O(Dnskey(k')) \\
					&\wedge O(Rrsig(k'))) \\
				)\\
		\end{split}
		\right\} \rightarrow R(Dnskey(k))
	\end{equation}
}

\subsubsection*{$R(Dnskey(k))$}

\mathbox{

	Skip the propagated state. Nobody heard of it anyway.
	\begin{equation}
		\begin{split}
			Goal(k)=H \rightarrow S(Dnskey(k))
		\end{split}
	\end{equation}

	We did wait long enough to make sure the dnskey record is known in 
	every cache?
	\begin{equation}
		\begin{split}
			Goal(k)=O \wedge T_{now} \geq T_{whatever} \rightarrow O(Dnskey(k))
		\end{split}
	\end{equation}

	We did not wait long enough: Wait some more.
	\begin{equation}
		\begin{split}
			Goal(k)=O \wedge T_{now} < T_{whatever} \rightarrow event(T_{whatever})
		\end{split}
	\end{equation}
}

\subsubsection*{$O(Dnskey(k))$}

\mathbox{

	If not part of a chain, withdraw. If there is still a DS make sure 
	there is some other valid chain for this algorithm. If none for 
	this algorithm are broken, some other algorithm will do as well.
	
	\begin{equation}
		\left.
		\begin{split}
			Goal(k)=H 
				&\wedge H(Ds(k))\\
				&\wedge H(Rrsig(k)) \\
			\\
			Goal(k)=H 
			%~ &\wedge State(k_{ds}) = C \\
				& \wedge \forall r \in Roles(k) \\
				(\\
				& \exists k' \in \mathbb{K} ( k' \not = k \\
				& \wedge Alg(k')=Alg(k) \\
				& \wedge r \in Roles(k') \\
				& \wedge O(Ds(k')) \\
				& \wedge O(Dnskey(k')) \\
				& \wedge O(Rrsig(k')) )\\
				) \\
				\\
			Goal(k)=H  &\wedge H(Ds(k))\\
				& \wedge \forall r \in Roles(k) \\
				(\\
				& \forall k' \in \mathbb{K} ( k' \not = k \\
				& \wedge Alg(k')=Alg(k) \\
				& \wedge r \in Roles(k') \\
				& \rightarrow H(Dnskey(k'))) \\
				& \wedge \\
				& \exists k' \in \mathbb{K} ( k' \not = k \\
				%~ & \wedge Alg(k') \not = Alg(k) \\
				& \wedge r \in Roles(k') \\
				& \wedge O(Ds(k')) \\
				& \wedge O(Dnskey(k')) \\
				& \wedge O(Rrsig(k')) )\\
				)
		\end{split}
		\right\} \rightarrow S(Dnskey(k))
	\end{equation}
}

			%~ Goal(k)=C 	& \wedge State(k_{ds})=C \\
						%~ & \wedge State(k_{rrsig})=C \\
			%~ \\
			%~ Goal(k)=C 	& \wedge State(k_{ds})=C \\
						%~ & \wedge (\exists k' \in \mathbb{K}: k' \not = k \\
						%~ & \wedge Alg(k) = Alg(k')\\
						%~ & \wedge State(k'_{dnskey}) = P \\
						%~ & \wedge State(k'_{rrsig}) = P) \\
						%~ & \wedge Roles(k) \subseteq Roles(k') \\
			%~ \\
			%~ Goal(k)=C 	& \wedge (\exists k' \in \mathbb{K}: k' \not = k \\
						%~ & \wedge Alg(k) = Alg(k')\\
						%~ & \wedge State(k'_{dnskey}) = P \\
						%~ & \wedge State(k'_{rrsig}) = P) \\
						%~ & \wedge (\exists k' \in \mathbb{K}: k' \not = k \\
						%~ & \wedge Alg(k) = Alg(k')\\
						%~ & \wedge State(k'_{dsy}) = P \\
						%~ & \wedge State(k'_{dnskey}) = P) \\
						%~ & \wedge Roles(k) \subseteq Roles(k') \\


\subsubsection*{$S(Dnskey(k))$}

\mathbox{

	State may transition to Ceased given enough time passed to propagate 
	change. 
	%~ Or when DS is already Ceased (only the DS is waiting this 
	%~ transition).
	\begin{equation}
		\left.
		\begin{split}
			%~ Goal(K) &=H \wedge 
			ksk \not \in Roles(k)\\
			\\
			%~ Goal(k)&=H \wedge 
			T_{now} \geq T_{whatever}
			%~ \\
			%~ Goal(k)&=C \wedge State(k_{ds})=C
		\end{split}
		\right\}\rightarrow H(Dnskey(k))
	\end{equation}

	Else, schedule event.
	\begin{equation}
		\begin{split}
			%~ Goal(k)=H \wedge 
			T_{now} < T_{whatever} \rightarrow event(T_{whatever})
		\end{split}
	\end{equation}
}

\subsection{Transition rules for $Rrsig(k)$}

\subsubsection*{$H(Rrsig(k))$}

\mathbox{

	%~ Nobody ever saw this signatures, we won't need it.
	%~ \begin{equation}
		%~ \begin{split}
			%~ Goal(k)=C
		%~ \end{split}
		%~ \rightarrow State(k_{rrsig})=C
	%~ \end{equation}

	Signatures for ZSKs can be introduced. For KSKs there must be a 
	valid ZSK.
	\begin{equation}
		%~ \left.
		\begin{split}
			Goal(k)=O 
		\end{split}
		%~ \right\} 
		\rightarrow R(Rrsig(k))
	\end{equation}
}

\subsubsection*{$R(Rrsig(k))$}

\mathbox{

Don't wait till signatures are propagated.
	\begin{equation}
		\begin{split}
			Goal(k)=H \rightarrow S(Rrsig(k))
		\end{split}
	\end{equation}

Enough time passed to propagate signatures. Or if we do a smooth 
transition 
	\begin{equation}
		\left.
		\begin{split}
			Goal(k)=O &\wedge T_{now} \geq T_{whatever} \\
			\\
			Goal(k)=O & \wedge AllowSmooth \\
					& \wedge \forall r \in Roles(k) (\\
						& \exists k' \in \mathbb{K} ( \\
							& Alg(k') = Alg(k) \\
							& \wedge r \in Roles(k') \\
							& \wedge O(Dnskey(k')) \\
							& \wedge O(Rrsig(k')) \\
						)
					)
		\end{split}
		 \right\} \rightarrow O(Rrsig(k))
	\end{equation}
	


Not enough time passed to propagate signatures.
	\begin{equation}
		\begin{split}
			Goal(k)=O \wedge T_{now} < T_{whatever} \rightarrow event(T_{whatever})
		\end{split}
	\end{equation}
}


\subsubsection*{$O(Rrsig(k))$}

\mathbox{

	If the dnskey is gone from all caches can we withdraw the 
	signatures. We may break the chain if other valid keys are 
	available.

	\begin{equation}
		\left.
		\begin{split}
			Goal(k)=H &\wedge H(Dnskey(k)) \\
			\\
			Goal(k)=H
				& \wedge \forall r \in Roles(k) \\
				( \\
				& \exists k' \in \mathbb{K} ( k' \not = k \\
					& \wedge Alg(k) = Alg(k') \\
					& \wedge r \in Roles(k')\\
					& \wedge O(Ds(k')) \\
					& \wedge O(Dnskey(k')) \\
					& \wedge O(Rrsig(k'))) \\
				)
		\end{split}
		\right\} \rightarrow S(Rrsig(k))
	\end{equation}
}

\subsubsection*{$S(Rrsig(k))$}

\mathbox{

	Dnskey is gone so no one needs these signatures.
	\begin{equation}
		\left.
		\begin{split}
			%~ Goal(k)=H &\wedge 
			H(Dnskey(k)) \\
			\\
			%~ Goal(k)=H &\wedge 
			T_{now} \geq T_{whatever} 
		\end{split}
		\right\} \rightarrow H(Rrsig(k))
	\end{equation}

	\begin{equation}
		\begin{split}
			%~ Goal(k)=H \wedge 
			T_{now} < T_{whatever} \rightarrow event(T_{whatever})
		\end{split}
	\end{equation}
}


\end{document}
